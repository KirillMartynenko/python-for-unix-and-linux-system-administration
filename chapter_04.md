## Глава 4. Создание документации и отчетов

С нашей точки зрения, одним из самых утомительных и наименее же
лательных аспектов работы системного администратора является сбор
различной информации и составление документации для пользовате
лей. Эта работа может нести прямую выгоду вашим пользователям,
которые будут читать документацию, или, возможно, косвенную вы
году пользователям, потому что вы или человек, пришедший вам на
замену, сможете обратиться к ней при необходимости внести измене
ния в будущем. В любом случае создание документации является кри
тически важным аспектом вашей деятельности. Но если это не та рабо
та, выполнением которой вам хотелось бы заняться, тогда вы, скорее
всего, отложите ее. Выполнить эту работу вам поможет Python. Нет,
Python не напишет за вас документацию, но он поможет собрать, от
форматировать и отправить документацию заинтересованным лицам.

В этой главе мы сосредоточим все свое внимание на следующих темах:
сбор, форматирование и передача информации о написанных вами
программах. Любая информация, которой вы предполагаете поде
литься, гдето существует: она может находиться в файлах журналов,
у вас в голове, она может быть доступна в виде результатов выполне
ния некоторых команд, она может даже находиться гденибудь в базе
данных. Самое первое, что необходимо сделать, это собрать необходи
мую информацию. Следующий шаг на пути к передаче информации
другим людям заключается в том, чтобы оформить собранную инфор
мацию. Для оформления можно использовать такие форматы, как
PDF, PNG, JPG, HTML или даже обычный текст. Наконец, необходи
мо передать эту информацию людям, которые заинтересованы в ней.
Надо понять, каким образом заинтересованным лицам будет удобнее
получать требуемую информацию: по электронной почте, на вебсайте
или просматривая файлы на совместно используемом диске.

### Автоматизированный сбор информации.


Первый шаг на пути к совместному использованию информации заклю
чается в том, чтобы собрать ее. В этой книге имеются две главы, где рас
сматриваются способы сбора информации: «Текст» (глава 3) и «SNMP»
(глава 7). В третьей главе содержатся примеры, демонстрирующие
различные способы анализа и извлечения данных из текста. В частно
сти, в одном из примеров этой главы из файлов журналов вебсервера
Apache извлекаются IPадреса клиентов, количество переданных бай
тов каждому клиенту и код состояния протокола HTTP. В главе 7 име
ются примеры выполнения запросов к системе на получение самой
разнообразной информации, начиная от объема ОЗУ до пропускной
способности сетевых интерфейсов.
Сбор информации может оказаться более сложным делом, чем простой
поиск и извлечение определенных данных. Часто этот процесс может
оказаться связанным с получением информации из одного представле
ния, например, из файла журнала вебсервера Apache, и сохранением
ее в некотором промежуточном виде для последующего использова
ния. Например, если представить, что вам необходимо создать диа
грамму, показывающую количество байтов, загруженных каждым от
дельным клиентом с уникальным IPадресом за месяц с определенного
вебсервера Apache, тогда процесс сбора информации мог бы включать
в себя ежедневный анализ файла журнала вебсервера Apache, в ходе
которого извлекается необходимая информация (в данном случае: IP
адрес и «количество переданных байтов» для каждого запроса), и со
хранение ее в некотором хранилище данных, откуда потом ее можно
будет получить. Примерами таких хранилищ данных могут служить
реляционные базы данных, объектные базы данных, файлыхранили
ща объектов, файлы в формате CSV и обычные текстовые файлы.
В оставшейся части этого раздела мы попробуем объединить некото
рые понятия из глав, посвященных обработке текста и хранению дан
ных. В частности, здесь будет показано, как соединить вместе приемы
извлечения данных из главы 3 с приемами сохранения данных, обсуж
даемыми в главе 12. При этом мы будем использовать те же библиоте
ки, что описывались в главе, касающейся вопросов обработки текста.
Мы также будем использовать модуль shelve, который будет представ
лен в главе 12, для сохранения информации об HTTPзапросах, посту
пающих от каждого конкретного клиента.
Ниже приводится простой модуль, в котором используются модуль
анализа файлов журналов вебсервера Apache, созданный в предыду
щей главе, и модуль shelve:

```
#!/usr/bin/env python
import shelve
import apache_log_parser_regex
logfile = open('access.log', 'r')
shelve_file = shelve.open('access.s')
for line in logfile:
d_line = apache_log_parser_regex.dictify_logline(line)
shelve_file[d_line['remote_host']] = \
shelve_file.setdefault(d_line['remote_host'], 0) + \
int(d_line['bytes_sent'])
logfile.close()
shelve_file.close()
```

В этом примере сначала импортируются модули shelve и apache_log_
parser_regex. Модуль shelve входит в состав стандартной библиотеки
языка Python. Модуль apache_log_parser_regex – это модуль, который
был создан нами в главе 3. Затем открываются файл журнала вебсер
вера Apache access.log и файл, куда будет сохраняться извлеченная
информация, access.s. Далее выполняется обход всех строк в файле
журнала и с помощью модуля разбора журнала для каждой строки
создается словарь. Словарь содержит код состояния запроса HTTP, IP
адрес клиента и число байтов, переданных клиенту. После этого мы
прибавляем число байтов для данного запроса к общему числу байтов,
которое уже было сохранено ранее в объекте shelve для данного IPад
реса. Если в объекте shelve еще отсутствует запись для указанного IP
адреса, общее число переданных байтов автоматически устанавлива
ется равным нулю. После обхода всех строк в файле журнала мы за
крываем этот файл, а также объект shelve. Этот пример будет исполь
зоваться далее в этой главе, когда мы подойдем к вопросу форматиро
вания информации.

**Прием электронной почты**

Вы наверное даже подумать не могли, что электронная почта может
играть роль средства сбора информации и, тем не менее, это так. Пред
ставьте, что у вас имеется несколько серверов, ни один из которых не
может соединяться с другими, но каждый из них обладает возможно
стью отправлять сообщения электронной почты. При наличии сцена
рия, выполняющего мониторинг вебприложений путем подключения
к ним каждые несколько минут, можно было бы в этом случае исполь
зовать электронную почту как механизм передачи информации. В слу
чае удачного или неудачного подключения можно было бы отправлять
сообщения электронной почты с информацией об успехе или неудаче.
И эти сообщения можно было бы использовать для составления отче
тов – с целью предупредить ответственное лицо в случае появления
проблем.
Для получения сообщений от сервера электронной почты обычно ис
пользуются два протокола: IMAP и POP3. В стандартной поставке Py
thon, куда «входят батарейки», имеются модули, поддерживающие
оба эти протокола.
Из этих двух протоколов, пожалуй, наиболее часто используется про
токол POP3 и доступ к электронной почте через этот протокол легко
можно организовать с помощью модуля poplib. В примере 4.1 демонст
рируется программный код, использующий модуль poplib для получе
ния всех сообщений, хранящихся на указанном сервере, и записываю
щий их в отдельные файлы на диске.


_Пример 4.1. Получение электронной почты по протоколу POP3_

```
#!/usr/bin/env python
import poplib
username = 'someuser'
password = 'S3Cr37'
mail_server = 'mail.somedomain.com'
p = poplib.POP3(mail_server)
p.user(username)
p.pass_(password)
for msg_id in p.list()[1]:
print msg_id
outf = open('%s.eml' % msg_id, 'w')
outf.write('\n'.join(p.retr(msg_id)[1]))
outf.close()
p.quit()
Как видите, в этом примере для начала определяются username (имя
пользователя), password (пароль) и mail_server (сервер электронной поч
ты). Затем выполняется подключение к серверу, которому передаются
предопределенные имя пользователя и пароль. Предположим, что со
единение было выполнено успешно, и мы получили возможность про
сматривать электронную почту для данной учетной записи. После это
го в цикле выполняется обход списка сообщений, извлечение и запись
этих сообщений в файлы на диске. Единственное, что не предусмотре
но в этом сценарии – сообщения не удаляются с сервера после их полу
чения. Чтобы удалить эти сообщения, достаточно было бы добавить
в сценарий вызов метода dele() после retr().
Работа с протоколом IMAP реализуется почти так же просто, как
и с протоколом POP3, но этот протокол не так хорошо описан в доку
ментации к стандартной библиотеке языка Python. В примере 4.2 при
водится программный код, который выполняет те же самые действия,
что и предыдущий пример, но с использованием протокола IMAP.
```
```
Пример 4.2. Получение электронной почты по протоколу IMAP
#!/usr/bin/env python
import imaplib
username = 'some_user'
password = '70P53Cr37'
mail_server = 'mail_server'
i = imaplib.IMAP4_SSL(mail_server)
print i.login(username, password)
print i.select('INBOX')
for msg_id in i.search(None, 'ALL')[1][0].split():
print msg_id
outf = open('%s.eml' % msg_id, 'w')
outf.write(i.fetch(msg_id, '(RFC822)')[1][0][1])
outf.close()
i.logout()
```
```
Как и в предыдущем примере, здесь также в самом начале сценария
определяются username (имя пользователя), password (пароль) и mail_
server (сервер электронной почты). Затем выполняется подключение
к серверу IMAP через SSL. Затем выполняется вход и выбор папки
электронной почты INBOX. Затем начинается обход всего, что будет най
дено в папке. Метод search() плохо описан в документации к стандарт
ной библиотеке языка Python. Этот метод имеет два обязательных ар
гумента – набор символов и критерий поиска. Какой набор символов
является допустимым? В каком формате он должен указываться? Ка
кие критерии поиска могут использоваться? Как правильно оформля
ется критерий? Мы можем, конечно, предполагать, что чтение IMAP
RFC окажется полезным, но, к счастью, в примере использования про
токола IMAP имеется достаточно информации, позволяющей органи
зовать извлечение всех сообщений, хранящихся в папке. На каждой
итерации цикла выполняется запись содержимого сообщения на диск.
Следует заметить, что при этом все сообщения в папке будут помечены
как «прочитанные». Для вас это может и не представлять большой
проблемы, проблема была бы гораздо большей, если бы сообщения
удалялись, но вам следует знать об этой особенности.
```
### Сбор информации вручную

```
Рассмотрим также более сложный способ – сбор информации вруч
ную. Здесь подразумевается информация, которая собирается вами
путем просмотра и ввода вручную. В качестве примеров можно при
вести список серверов с соответствующими им IPадресами и описани
ем функций, список контактов с адресами электронной почты, номе
рами телефонов и псевдонимами IM или список с датами отпусков чле
нов вашей команды. Есть, конечно, инструменты, способные управ
лять, если не всей, то большей частью такой информации. Список
серверов можно хранить в файлах Excel или OpenOffice Spreadsheet.
Контакты можно хранить в Outlook или AddressBook.app. А расписа
ние отпусков можно хранить как в Excel/OpenOffice Spreadsheet, так
и в Outlook. Применение таких инструментов может стать решением
в ситуациях, когда технологии свободно доступны, исходные данные
могут представлять собой простой текст, а инструменты обеспечивают
легко настраиваемый вывод информации и поддерживают формат
HTML (или, что еще лучше, XHTML).

ПОРТРЕТ ЗНАМЕНИТОСТИ: ПАКЕТ RESTLESS
```
**Аарон Хиллегасс (Aaron Hillegass)**

```
Аарон Хиллегасс, работавший в компаниях NeXT
и Apple, является экспертом в области разработ
ки приложений для операционной системы Mac.
Он является автором книги «Cocoa Programming
for Mac OS X» (Big Nerd Ranch) и преподает про
граммирование на платформе Cocoa в компании
Big Nerd Ranch.
Загрузите полные исходные тексты пакета ReSTless из репозита
рия с примерами программного кода к этой книге по адресу: http:/
/www.oreilly.com/9780596515829. Ниже показано, как вызвать
сценарий на языке Python из вымышленного Cocoaприложения:
```
```
#import "MyDocument.h"
@implementation MyDocument
```
```
(id)init
{
if (![super init]) {
return nil;
}
// Что должно быть получено в случае нового документа
textStorage = [[NSTextStorage alloc] init];
return self;
}
(NSString *)windowNibName
{
return @"MyDocument";
}
(void)prepareEditView
{
// Менеджер размещения следит за хранилищем текста
// и размещает текст в текстовом поле
NSLayoutManager *lm = [editView layoutManager];
```
```
// Отсоединить прежнее хранилище текста
[[editView textStorage] removeLayoutManager:lm];
```
```
// Присоединить новое хранилище текста
[textStorage addLayoutManager:lm];
}
(void)windowControllerDidLoadNib:(NSWindowController *) aController
{
```

Сбор информации вручную **165**

```
[super windowControllerDidLoadNib:aController];
// Отобразить содержимое хранилища текста в текстовом поле
[self prepareEditView];
}
#pragma mark Сохранение и загрузка
// Сохранение (URL всегда имеет тип file:)
(BOOL)writeToURL:(NSURL *)absoluteURL
ofType:(NSString *)typeName
error:(NSError **)outError;
{
return [[textStorage string] writeToURL:absoluteURL
atomically:NO
encoding:NSUTF8StringEncoding
error:outError];
}
// Чтение (URL всегда имеет тип file:)
(BOOL)readFromURL:(NSURL *)absoluteURL
ofType:(NSString *)typeName
error:(NSError **)outError
{
NSString *string = [NSString stringWithContentsOfURL:absoluteURL
encoding:NSUTF8StringEncoding
error:outError];
// Ошибка чтения?
if (!string) {
return NO;
}
[textStorage release];
textStorage = [[NSTextStorage alloc] initWithString:string
attributes:nil];
// Это возврат?
if (editView) {
[self prepareEditView];
}
return YES;
}
#pragma mark Создание и сохранение HTML
(NSData *)dataForHTML
{
// Создать задачу для запуска rst2html.py
NSTask *task = [[NSTask alloc] init];
// Предполагаемое местонахождение программы
NSString *path = @"/usr/local/bin/rst2html.py";
// Файл отсутствует? Попробовать отыскать внутри платформы python
```

**166** Глава 4. Создание документации и отчетов

```
if (![[NSFileManager defaultManager] fileExistsAtPath:path]) {
path = @"/Library/Frameworks/Python.framework/Versions/
/Current/bin/rst2html.py;
}
[task setLaunchPath:path];
// Подключить канал для ввода ReST
NSPipe *inPipe = [[NSPipe alloc] init];
[task setStandardInput:inPipe];
[inPipe release];
// Подключить канал для вывода HMTL
NSPipe *outPipe = [[NSPipe alloc] init];
[task setStandardOutput:outPipe];
[outPipe release];
// Запустить процесс
[task launch];
// Получить данные из текстового поля
NSData *inData = [[textStorage string] dataUsingEncoding:
NSUTF8StringEncoding];
// Передать данные в канал и закрыть его
[[inPipe fileHandleForWriting] writeData:inData];
[[inPipe fileHandleForWriting] closeFile];
// Прочитать данные из канала
NSData *outData = [[outPipe fileHandleForReading]
readDataToEndOfFile];
// Завершить задачу
[task release];
return outData;
}
(IBAction)renderRest:(id)sender
{
// Запустить индикатор, чтобы пользователь видел,
// что идет обработка
[progressIndicator startAnimation:nil];
// Получить html в виде NSData
NSData *htmlData = [self dataForHTML];
// Выдать html в основной WebFrame
WebFrame *wf = [webView mainFrame];
[wf loadData:htmlData
MIMEType:@"text/html"
textEncodingName:@"utf8"
baseURL:nil];
// Остановить индикатор, чтобы пользователь видел,
// что обработка закончена
```

Сбор информации вручную **167**

```
[progressIndicator stopAnimation:nil];
}
// Вызывается при выборе пункта меню
(IBAction)startSavePanelForHTML:(id)sender
{
// Куда сохранять по умолчанию?
NSString *restPath = [self fileName];
NSString *directory = [restPath stringByDeletingLastPathComponent];
NSString *filename = [[[restPath lastPathComponent]
stringByDeletingPathExtension]
stringByAppendingPathExtension:@"html"];
// Запустить диалог сохранения
NSSavePanel *sp = [NSSavePanel savePanel];
[sp setRequiredFileType:@"html"];
[sp setCanSelectHiddenExtension:YES];
[sp beginSheetForDirectory:directory
file:filename
modalForWindow:[editView window]
modalDelegate:self
didEndSelector:@selector(htmlSavePanel:endedWithCode:context:)
contextInfo:NULL];
}
```
```
// Вызывается при закрытии диалога сохранения
(void)htmlSavePanel:(NSSavePanel *)sp
endedWithCode:(int)returnCode
context:(void *)context
{
// Пользователь щелкнул на кнопке Cancel?
if (returnCode != NSOKButton) {
return;
}
// Получить выбранное имя файла
NSString *savePath = [sp filename];
// Получить данные в формате HTML
NSData *htmlData = [self dataForHTML];
// Записать в файл
NSError *writeError;
BOOL success = [htmlData writeToFile:savePath
options:NSAtomicWrite
error:&writeError];
```
```
// Записать не удалось?
if (!success) {
// Показать пользователю причину
NSAlert *alert = [NSAlert alertWithError:writeError];

Несмотря на наличие различных альтернатив, мы собираемся предло
жить здесь текстовый формат, который называется reStructuredText
(или reST). Вот как описывается формат reStructuredText на вебсайте:
reStructuredText – это легкая для чтения, обеспечивающая отобра
жение текста в режиме «что видишь, то и получаешь» простая тек
стовая разметка и одновременно система синтаксического анализа.
Ее удобно использовать для встроенной документации к программам
(например, в строках документирования языка Python), для быстро
го создания вебстраниц, для создания самостоятельных докумен
тов. Разметка reStructuredText предусматривает возможность рас
ширения под нужды различных прикладных областей. Синтаксиче
ский анализатор reStructuredText является составной частью пакета
Docutils. Разметка reStructuredText представляет собой пересмот
ренную реализацию легковесных систем разметки StructuredText
иSetext.
```
```
Формат ReST считается предпочтительным форматом для создания
документации в языке Python. Если вы создали программный пакет
на языке Python и решили выложить его в репозитарий PyPI, то от вас
будут ожидать, что сопроводительная документация к пакету будет
иметь формат ReST. Многие самостоятельные проекты, использую
```
```
[alert beginSheetModalForWindow:[editView window]
modalDelegate:nil
didEndSelector:NULL
contextInfo:NULL];
return;
}
}
#pragma mark Поддержка печати
```
```
(NSPrintOperation *)printOperationWithSettings:(NSDictionary *)
printSettings error:(NSError **)outError
{
// Получить информацию о параметрах настройки печати
NSPrintInfo *printInfo = [self printInfo];
// Получить поле, где отображается весь документ HTML
NSView *docView = [[[webView mainFrame] frameView] documentView];
// Создать задание печати
return [NSPrintOperation printOperationWithView:docView
printInfo:printInfo];
}
@end
щие язык Python, применяют формат ReST в качестве основного для
оформления своей документации.
Итак, какими же преимуществами обладает ReST как формат, исполь
зуемый для создания документации? Вопервых, он достаточно прост.
Вовторых, знакомство с разметкой происходит практически сразу.
Как только перед вами оказывается структура документа, вы быстро
начинаете понимать, что имел в виду автор. Ниже приводится очень
простой пример файла в формате ReST:
```
```
=======
Heading
=======
SubHeading
```
```
This is just a simple
little subsection. Now,
we'll show a bulleted list:
```
```
item one
item two
item three
```
```
Этот пример позволяет без чтения документации представить, как вы
глядит правильно оформленный файл в формате reStructuredText.
Возможно, при этом вы еще не в состоянии создать текстовый файл
в формате ReST, но, по крайней мере, вы сможете читать его.
Втретьих, преобразование документов из формата ReST в формат
HTML выполняется очень просто. И на этом третьем пункте мы сосре
доточим свое внимание в этом разделе. Мы не будем пытаться предста
вить здесь учебник по reStructuredText. Если вам захочется ознако
миться с синтаксисом разметки, посетите страницу http://docutils.so>
urceforge.net/docs/user/rst/quickref.html.
Мы пройдем все этапы преобразования разметки ReST в HTML, исполь
зуя документ, который мы только что показали в качестве примера:
```
```
In [2]: import docutils.core
In [3]: rest = '''=======
...: Heading
...: =======
...: SubHeading
...:
...: This is just a simple
...: little subsection. Now,
...: we'll show a bulleted list:
...:
...: item one
...: item two
...: item three
...: '''
In [4]: html = docutils.core.publish_string(source=rest, writer_name='html')
In [5]: print html[html.find('<body>') + 6:html.find('</body>')]
```
```
<div class="document" id="heading">
<h1 class="title">Heading</h1>
<h2 class="subtitle" id="subheading">SubHeading</h2>
<p>This is just a simple
little subsection. Now,
we'll show a bulleted list:</p>
<ul class="simple">
<li>item one</li>
<li>item two</li>
<li>item three</li>
</ul>
</div>
```
```
Это оказалось совсем несложно. Мы импортировали модуль docutils.co
re. Затем определили строку, содержащую текст в формате reStruc
turedText, передали эту строку методу docutils.core.publish_string()
и потребовали от него преобразовать строку в формат HTML. Затем с по
мощью операции извлечения среза мы извлекли текст, заключенный
между тегами <body> и </body>. Мы извлекли срез потому, что библиоте
ка docutils, использованная здесь для преобразования текста в формат
HTML, вставляет в страницу HTML, созданную с ее помощью, каскад
ные таблицы стилей, чтобы она не выглядела слишком уныло.
Теперь, когда вы увидели, насколько все просто, рассмотрим другой
пример, который находится ближе к системному администрирова
нию. Любой хороший сисадмин должен помнить перечень своих серве
ров и задачи, которые они решают. Поэтому ниже приводится пример,
показывающий, как можно составить список серверов сначала в про
стом текстовом виде, а затем преобразовать его в формат HTML:
In [6]: server_list = '''============== ============ ================
...: Server Name IP Address Function
...: ============== ============ ================
...: card 192.168.1.2 mail server
...: vinge 192.168.1.4 web server
...: asimov 192.168.1.8 database server
...: stephenson 192.168.1.16 file server
...: gibson 192.168.1.32 print server
...: ============== ============ ================'''
```
```
In [7]: print server_list
============== ============ ================
Server Name IP Address Function
============== ============ ================
card 192.168.1.2 mail server
vinge 192.168.1.4 web server
asimov 192.168.1.8 database server
stephenson 192.168.1.16 file server
gibson 192.168.1.32 print server
============== ============ ================
```
```
In [8]: html = docutils.core.publish_string(source=server_list,
writer_name='html')
```
```
In [9]: print html[html.find('<body>') + 6:html.find('</body>')]
<div class="document">
<table border="1" class="docutils">
<colgroup>
<col width="33%" />
<col width="29%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr><th class="head">Server Name</th>
<th class="head">IP Address</th>
<th class="head">Function</th>
</tr>
</thead>
<tbody valign="top">
<tr><td>card</td>
<td>192.168.1.2</td>
<td>mail server</td>
</tr>
<tr><td>vinge</td>
<td>192.168.1.4</td>
<td>web server</td>
</tr>
<tr><td>asimov</td>
<td>192.168.1.8</td>
<td>database server</td>
</tr>
<tr><td>stephenson</td>
<td>192.168.1.16</td>
<td>file server</td>
</tr>
<tr><td>gibson</td>
<td>192.168.1.32</td>
<td>print server</td>
</tr>
</tbody>
</table>
</div>
```

Еще одна замечательная и простая текстовая разметка называется Textile. Согласно описанию на вебсайте: «Textile получает текст с *про
стой* разметкой и воспроизводит корректный код разметки XHTML.
Этот формат используется в вебприложениях, в системах управления
содержимым, программным обеспечением блогов и форумов». Если
Textile является языком разметки, то почему он описывается в книге, посвященной языку Python? Причина в том, что для языка Python су
ществует библиотека, которая позволяет обрабатывать разметку Textile
и преобразовывать ее в XHTML. Вы можете написать отдельную утили
ту командной строки, которая с помощью библиотеки будет преобразо
вывать файлы из формата Textile в формат XHTML. Или можно вызы
вать модуль, выполняющий преобразование формата Textile, в некото
ром сценарии и программным способом обработать полученную размет
ку XHTML. В любом случае разметка Textile и модуль обработки Textile
могут оказаться неплохим подспорьем в создании документации.
Установить модуль Textile можно с помощью команды easy_install
textile или с помощью системы управления пакетами, имеющейся
в вашем дистрибутиве. В Ubuntu, например, пакет называется python–
textile и установить его можно командой apt–get install python–textile.
Как только модуль Textile будет установлен, вы сможете приступить
к его использованию, просто импортируя его, создавая объект Textiler
и вызывая единственный метод этого объекта. Ниже приводится при
мер преобразования маркированного списка из формата Textile в фор
мат XHTML:

```
In [1]: import textile
In [2]: t = textile.Textiler('''* item one
...: * item two
...: * item three''')
```
```
In [3]: print t.process()
<ul>
<li>item one</li>
<li>item two</li>
<li>item three</li>
</ul>
```

Мы не будем пытаться дать здесь описание формата Textile. В Сети
имеется множество ресурсов с этой информацией. Например, по адресу
http://hobix.com/textile/ вы найдете отличное руководство по использо
ванию Textile. Хотя мы и не собираемся слишком углубляться в описа
ние формата Textile, тем не менее, мы посмотрим, как применить фор
мат Textile для оформления информации, собранной вручную, – спис
ка серверов с соответствующими им IPадресами и функциями:

```
In [1]: import textile
```
```
In [2]: server_list = '''|_. Server Name|_. IP Address|_. Function|
...: |card|192.168.1.2|mail server|
...: |vinge|192.168.1.4|web server|
...: |asimov|192.168.1.8|database server|
...: |stephenson|192.168.1.16|file server|
...: |gibson|192.168.1.32|print server|'''
```
```
In [3]: print server_list
|_. Server Name|_. IP Address|_. Function|
|card|192.168.1.2|mail server|
|vinge|192.168.1.4|web server|
|asimov|192.168.1.8|database server|
|stephenson|192.168.1.16|file server|
|gibson|192.168.1.32|print server|
In [4]: t = textile.Textiler(server_list)
In [5]: print t.process()
<table>
<tr>
<th>Server Name</th>
<th>IP Address</th>
<th>Function</th>
</tr>
<tr>
<td>card</td>
<td>192.168.1.2</td>
<td>mail server</td>
</tr>
<tr>
<td>vinge</td>
<td>192.168.1.4</td>
<td>web server</td>
</tr>
<tr>
<td>asimov</td>
<td>192.168.1.8</td>
<td>database server</td>
</tr>
<tr>
<td>stephenson</td>
<td>192.168.1.16</td>
<td>file server</td>
</tr>
<tr>
<td>gibson</td>
<td>192.168.1.32</td>
<td>print server</td>
</tr>
</table>
```

Как видите, оба формата, ReST и Textile, могут эффективно использо
ваться в сценариях на языке Python для преобразования текстовых
данных. Если у вас действительно имеются такие данные, как списки
серверов и контактов, которые требуется преобразовывать в формат
HTML и затем предпринимать какиелибо дополнительные действия
(например, отправлять HTML по электронной почте или передавать
HTMLстраницы куданибудь на вебсервер по протоколу FTP), то биб
лиотека docutils или Textile может оказаться для вас полезным инст
рументом.

### Форматирование информации

Следующий этап на пути передачи информации в руки тех, кому она
необходима, заключается в форматировании данных так, чтобы их
легко можно было воспринимать и понимать. Мы считаем, что инфор
мация должна быть представлена в том виде, в каком, по крайней ме
ре, ее легко будет воспринимать, но еще лучше, если оформление бу
дет еще и привлекательным. С технической точки зрения применение
форматов ReST и Textile охватывает сразу оба этапа – сбора и форма
тирования информации, но в следующих примерах мы сосредоточим
ся исключительно на преобразовании уже собранных данных в более
представительный вид.

**Графические изображения**

В следующих двух примерах мы продолжим пример анализа файла журнала вебсервера Apache, из которого извлекаются IPадреса клиентов и количество переданных байтов. В предыдущем разделе, про
должая этот пример, мы создали промежуточный файл, содержащий
информацию, которой мы предполагаем поделиться с другими. Поэто
му на основе этого промежуточного файла мы создадим диаграмму,
чтобы эти данные было проще воспринимать:

```
#!/usr/bin/env python
import gdchart
import shelve
shelve_file = shelve.open('access.s')
items_list = [(i[1], i[0]) for i in shelve_file.items()]
items_list.sort()
bytes_sent = [i[0] for i in items_list]
#ip_addresses = [i[1] for i in items_list]
ip_addresses = ['XXX.XXX.XXX.XXX' for i in items_list]

chart = gdchart.Bar()
chart.width = 400
chart.height = 400
chart.bg_color = 'white'
chart.plot_color = 'black'
chart.xtitle = "IP Address"
chart.ytitle = "Bytes Sent"
chart.title = "Usage By IP Address"
chart.setData(bytes_sent)
chart.setLabels(ip_addresses)
chart.draw("bytes_ip_bar.png")
shelve_file.close()
```

В этом примере были импортированы два модуля, gdchart и shelve. За
тем был открыт файл хранилища объектов, созданный в предыдущем
примере. Объект shelve обладает тем же интерфейсом, что и встроенный тип dictionary, поэтому имеется возможность вызвать его метод
items(). Этот метод возвращает список кортежей, где первый элемент
кортежа соответствует ключу словаря, а второй элемент – значению
этого ключа. Применение метода items() обеспечивает возможность
сортировки данных, что определенно будет иметь смысл, когда мы
начнем рисовать диаграмму. Кроме того, с помощью генератора спи
сков мы меняем порядок следования элементов в кортежах. То есть
вместо кортежей с элементами (ip_address, bytes_sent) мы получаем
кортежи (bytes_sent, ip_address). Затем выполняется сортировка кор
тежей в списке, а поскольку в каждом кортеже первым элементом яв
ляется значение bytes_sent, метод list.sort() выполнит сортировку по
этому элементу. Далее с помощью генератора списков извлекаются
значения bytes_sent и ip_address. Обратите внимание, что мы прибегли
к сокрытию IPадресов, заменив их значением XXX.XXX.XXX.XXX, потому
что данные для этого примера были получены нами из файла журнала
действующего вебсервера.
После выборки данных, на основе которых будет построена диаграм
ма, можно приступать к созданию ее графического представления, ис
пользуя модуль gdchart. Сначала создается объект gdchart.Bar. Это про
стой объект диаграммы, в котором необходимо установить значения
некоторых атрибутов, а затем с его помощью можно будет отобразить
диаграмму в файл PNG. После этого определяются размеры диаграм
мы в пикселях, цвет фона и цвет переднего плана и создаются заголов
ки. Устанавливаются данные и метки для диаграммы, полученные
в результате анализа файла журнала вебсервера Apache. В заключение
вызывается метод draw(), который выводит диаграмму в файл, и произ
водится закрытие файла хранилища. Изображение полученной диа
граммы показано на рис. 4.1.
Ниже приводится другой пример сценария, выполняющего визуали
зацию данных, находящихся в файле хранилища, но на этот раз про
грамма создает не гистограмму, а круговую диаграмму:

```
#!/usr/bin/env python

import gdchart
import shelve
import itertools
shelve_file = shelve.open('access.s')
items_list = [(i[1], i[0]) for i in shelve_file.items() if i[1] > 0]
items_list.sort()
bytes_sent = [i[0] for i in items_list]
#ip_addresses = [i[1] for i in items_list]
ip_addresses = ['XXX.XXX.XXX.XXX' for i in items_list]
chart = gdchart.Pie()
chart.width = 800
chart.height = 800
chart.bg_color = 'white'
color_cycle = itertools.cycle([0xDDDDDD, 0x111111, 0x777777])
color_list = []
for i in bytes_sent:
color_list.append(color_cycle.next())
chart.color = color_list
chart.plot_color = 'black'
chart.title = "Usage By IP Address"
chart.setData(*bytes_sent)
chart.setLabels(ip_addresses)
chart.draw("bytes_ip_pie.png")
shelve_file.close()
```

Принцип действия этого сценария практически идентичен предыду
щему за несколькими исключениями. Вопервых, в этом сценарии
создается экземпляр объекта gdchart.Pie, а не gdchart.Bar. Вовторых,
мы определили отдельные цвета для каждого сектора диаграммы. Это
круговая диаграмма и поэтому, если все сектора вывести черным цве
том, такую диаграмму будет невозможно читать, в связи с чем нами
было принято решение организовать чередование трех градаций серо
го цвета. Чередование этих трех цветов было реализовано с помощью

Рис. 4.1. Гистограмма количества байтов, переданных по запросам с каждого IP-адреса

функции cycle() из модуля itertools. Мы рекомендуем вам обратить
свое внимание на модуль itertools. В нем имеется значительное число
интересных функций, которые помогут вам в работе с итерируемыми
объектами (такими, как списки). Результат работы этого сценария,
создающего круговую диаграмму, приводится на рис. 4.2.
Единственный недостаток круговой диаграммы состоит в том, что про
изошло наложение (сокрытие) IPадресов, соответствующих секторам
с минимальными значениями переданных байтов. Гистограммы и кру
говые диаграммы существенно облегчают восприятие данных, находя
щихся в файле хранилища, процесс создания диаграмм оказался на
удивление простым, и включение данных было удивительно легким
делом.
```
```
Рис. 4.2. Круговая диаграмма с количеством байтов, переданных
по запросам с каждого IP>адреса

**PDF**

Другой способ представления информации из файлов с данными за
ключается в сохранении их в формате PDF. Формат PDF приобрел гос
подствующее положение, и мы готовы предполагать, что все докумен
ты можно преобразовать в PDF. Знание и умение создавать документы
в формате PDF может существенно облегчить жизнь вам как систем
ным администраторам. После прочтения этого раздела вы сможете
применять полученные знания для создания отчетов в формате PDF
о загруженности сети, об учетных записях пользователей и так далее.
Мы также опишем способ автоматического встраивания документов
PDF в сообщения электронной почты с использованием языка Python.
Библиотеку ReportLab в мире библиотек, предназначенных для рабо
ты с форматом PDF, можно сравнить с 350килограммовой гориллой.
В документе, расположенном по адресу http://www.reportlab.com/
docs/userguide.pdf , вы найдете значительное число примеров исполь
зования библиотеки ReportLab. Кроме этого раздела мы настоятельно
рекомендуем вам ознакомиться с официальной документацией проек
та ReportLab. Для установки библиотеки ReportLab в Ubuntu доста
точно дать команду apt–get install python–reportlab. Если вы пользуе
тесь другим дистрибутивом, воспользуйтесь помощью менеджера па
кетов в своей операционной системе. Иначе у вас всегда есть возмож
ность получить дистрибутив с исходными текстами.
В примере 4.3 приводится пример использования библиотеки Report
Lab для создания простого документа PDF «Hello World».
```
```
Пример 4.3. Документ PDF – «Hello World»
#!/usr/bin/env python
```
```
from reportlab.pdfgen import canvas
def hello():
c = canvas.Canvas("helloworld.pdf")
c.drawString(100,100,"Hello World")
c.showPage()
c.save()
hello()
```
```
Нам хотелось бы сделать несколько замечаний к процессу создания
PDFдокумента «Hello World». Вопервых, сначала был создан объект
canvas. Далее был использован метод drawString(), который можно счи
тать эквивалентом метода file_obj.write() в случае текстовых файлов.
В заключение были вызваны метод showPage(), завершающий процесс
рисования, и метод save(), который фактически создает файл PDF. Ес
ли выполнить этот сценарий, в результате будет получен пустой одно
страничный документ PDF с надписью «Hello World» в самом низу.
Если вы загрузили дистрибутив с исходными текстами библиотеки Re
portLab, вы можете воспользоваться тестами, которые были включены как примеры оформления документации. То есть при запуске эти тес
ты создают комплект файлов PDF, которые можно изучить и посмот
реть, как с помощью библиотеки ReportLab можно добиться различ
ных визуальных эффектов.
Теперь, когда вы увидели, как с помощью библиотеки ReportLab соз
даются документы PDF, посмотрим, как с ее же помощью создать от
чет об использовании дискового пространства. Такой отчет может ока
заться весьма полезным. Взгляните на пример 4.4.

```
Пример 4.4. Отчет об использовании дискового пространства
#!/usr/bin/env python
import subprocess
import datetime
from reportlab.pdfgen import canvas
from reportlab.lib.units import inch
```
```
def disk_report():
p = subprocess.Popen("dfh", shell=True,
stdout=subprocess.PIPE)
return p.stdout.readlines()
```
```
def create_pdf(input,output="disk_report.pdf"):
now = datetime.datetime.today()
date = now.strftime("%h %d %Y %H:%M:%S")
c = canvas.Canvas(output)
textobject = c.beginText()
textobject.setTextOrigin(inch, 11*inch)
textobject.textLines('''
Disk Capacity Report: %s
''' % date)
for line in input:
textobject.textLine(line.strip())
c.drawText(textobject)
c.showPage()
c.save()
```
```
report = disk_report()
create_pdf(report)
```

Этот сценарий генерирует отчет с заголовком «Disk Capacity Report»
(Отчет об использовании дискового пространства), отображающий те
кущую информацию об использовании дискового пространства, а так
же указывается дата и время создания отчета. Для сценария такого не
значительного размера это очень неплохо. Рассмотрим некоторые осо
бенности этого примера. Вопервых, функция disk_report() просто при
нимает вывод команды df – h и возвращает его в виде списка строк.
Далее, в функции create_pdf() сначала создается надпись с текущей да
той и временем. Самая важная часть этого примера – объект textobject.
Объект textobject создается, чтобы потом поместить его в документ
PDF. Создание объекта textobject производится с помощью метода
beginText(). Затем определяется способ размещения данных на страни
це. Наш документ будет содержать страницы размером 8.5×11 дюй
мов, поэтому, чтобы поместить текст в самом верху страницы, мы со
общаем текстовому объекту, что текст будет находиться в 11 дюймах
от начала координат. После этого создается заголовок выводом строки
в текстовый объект, и мы завершаем работу, выполняя обход списка
строк, полученных в результате работы команды df. Обратите внима
ние: здесь использован метод line.strip() для удаления символов но
вой строки. Если этого не сделать, символы новой строки будут при
сутствовать в документе в виде черных квадратов.
Имеется возможность создавать намного более сложные документы
PDF, добавляя цвета и изображения, но обо всем этом вы сможете
узнать во время чтения превосходного руководства пользователя, по
ставляемого вместе с библиотекой ReportLib. Главное, что следует из
этих примеров, текст является основным объектом, хранящим дан
ные, которые требуется отобразить.

### Распространение информации

После того как данные будут собраны и отформатированы, необходи
мо передать их тем, кто заинтересован в их получении. В этом разделе
мы сосредоточим основное внимание на передаче документации с по
мощью электронной почты. Если вам потребуется передать некоторую
документацию на вебсервер, где ее смогут увидеть ваши пользовате
ли, вы сможете использовать для этого протокол FTP. Использование
стандартного модуля Python для работы с протоколом FTP мы рас
смотрим в следующей главе.
```
**Передача электронной почты**

```
Работа с электронной почтой является важной составляющей в дея
тельности системного администратора. Мало того, что нам приходится
управлять почтовыми серверами, но нам часто приходится придумы
вать способы отправки предупреждений по электронной почте. Стан
дартная библиотека языка Python обладает потрясающей поддержкой
возможности отправлять сообщения электронной почты, но в книгах
об этом упоминается очень редко. Любой системный администратор
должен иметь тщательно налаженный механизм автоматизированной
отправки электронной почты, поэтому с этом разделе будет показано,
как можно решать разнообразные задачи, связанные с электронной
почтой, используя язык Python.
```
```
Передача простых сообщений
В состав Python входят два независимых друг от друга пакета, позво
ляющих отправлять сообщения по электронной почте. Один низко
уровневый пакет, smtplib, представляет собой интерфейс к протоколу SMTP, отвечающий требованиям различных спецификаций RFC. Дру
гой пакет, email, помогает выполнять анализ и создание сообщений
электронной почты. В примере 4.5 с помощью средств пакета smtplib
создается строка, представляющая тело сообщения, а затем с помощью
пакета email производится его отправка серверу электронной почты.
```
```
Пример 4.5. Отправка сообщений по протоколу SMTP
#!/usr/bin/env python
import smtplib
mail_server = 'localhost'
mail_server_port = 25
from_addr = 'sender@example.com'
to_addr = 'receiver@example.com'
```
```
from_header = 'From: %s\r\n' % from_addr
to_header = 'To: %s\r\n\r\n' % to_addr
subject_header = 'Subject: nothing interesting'
body = 'This is a notveryinteresting email.'
```
```
email_message = '%s\n%s\n%s\n\n%s' % (from_header, to_header,
subject_header, body)
```
```
s = smtplib.SMTP(mail_server, mail_server_port)
s.sendmail(from_addr, to_addr, email_message)
s.quit()
```
```
Здесь мы определили имя хоста и номер порта сервера электронной
почты, а также адреса «to» (получатель) и «from» (отправитель). За
тем производится сборка самого сообщения путем объединения заго
ловков с телом сообщения. В заключение выполняется подключение
к серверу SMTP и производится отправка сообщения по адресу to_addr
с адреса from_addr. Следует также заметить, что добавление комбина
ций символов \r\n в поля From: и To: выполнено в соответствии с требо
ваниями RFC.
В главе 10 в разделе «Планирование процессов Python» приводится
пример программного кода на языке Python, который запускается как
задание планировщика cron выполняющее отправку сообщений элек
тронной почты. А теперь перейдем от этого простого примера к более
сложным операциям с электронной почтой, которые можно реализо
вать на языке Python.
```
```
Аутентификация по протоколу SMTP
Наш последний пример был чрезвычайно прост, поскольку нет ничего
сложного в том, чтобы реализовать отправку почты на языке Python,
но, к сожалению, подавляющее большинство серверов SMTP вынудят
вас проходить процедуру аутентификации, поэтому предыдущий при
мер в таких ситуациях окажется бесполезным. Порядок выполнения
аутентификации демонстрируется в примере 4.6.

_Пример 4.6. Аутентификация по протоколу SMTP_

```
#!/usr/bin/env python
import smtplib
mail_server = 'smtp.example.com'
mail_server_port = 465
from_addr = 'foo@example.com'
to_addr = 'bar@exmaple.com'
from_header = 'From: %s\r\n' % from_addr
to_header = 'To: %s\r\n\r\n' % to_addr
subject_header = 'Subject: Testing SMTP Authentication'
body = 'This mail tests SMTP Authentication'
email_message = '%s\n%s\n%s\n\n%s' % (from_header, to_header,
subject_header, body)
s = smtplib.SMTP(mail_server, mail_server_port)
s.set_debuglevel(1)
s.starttls()
s.login("fatalbert", "mysecretpassword")
s.sendmail(from_addr, to_addr, email_message)
s.quit()
```

Основное отличие от предыдущего примера заключается в том, что
здесь указываются имя пользователя и пароль. Перед отправкой вызо
вом метода debuglevel() мы активировали режим отладки и затем за
пустили соединение SSL с использованием метода starttls(). Включе
ние режима отладки перед прохождением аутентификации – это заме
чательная идея. Если взглянуть на отладочную информацию, полу
ченную в случае неудачи, она будет иметь вид, как показано ниже:

```
$ python2.5 mail.py
send: 'ehlo example.com\r\n'
reply: '250example.com Hello example.com [127.0.0.1], pleased to meet
you\r\n'
reply: '250ENHANCEDSTATUSCODES\r\n'
reply: '250PIPELINING\r\n'
reply: '2508BITMIME\r\n'
reply: '250SIZE\r\n'
reply: '250DSN\r\n'
reply: '250ETRN\r\n'
reply: '250DELIVERBY\r\n'
reply: '250 HELP\r\n'
reply: retcode (250); Msg: example.com example.com [127.0.0.1], pleased to
meet you
ENHANCEDSTATUSCODES
PIPELINING
8BITMIME
SIZE
DSN
ETRN
DELIVERBY
HELP
send: 'STARTTLS\r\n'
reply: '454 4.3.3 TLS not available after start\r\n'
reply: retcode (454); Msg: 4.3.3 TLS not available after start
```

В этом примере сервер, с которым мы попытались установить соедине
ние SSL, не поддерживает такую возможность. Можно без особого тру
да обойти эту и другие потенциальные проблемы, создавая сценарии,
которые включают в себя обработку ошибок отправки электронной
почты, реализуя попытки отправки через каскад серверов, вплоть до
попытки отправить почту через локальный сервер.
Реализация отправки вложений на языке Python
Отправка сообщений, состоящих исключительно из текста, выполня
ется очень просто. Однако на языке Python можно реализовать отправ
ку сообщений с использованием стандарта MIME, что означает воз
можность добавлять вложения в исходящие сообщения. В предыду
щем разделе этой главы мы рассматривали возможность создания от
четов в формате PDF. Системные администраторы – нетерпеливые
люди, поэтому мы опустим подробности о происхождении MIME и сра
зу же перейдем к отправке электронной почты с вложениями, как по
казано в примере 4.7.

```
Пример 4.7. Отправка документа PDF, вложенного в сообщение
электронной почты
import email
from email.MIMEText import MIMEText
from email.MIMEMultipart import MIMEMultipart
from email.MIMEBase import MIMEBase
from email import encoders
import smtplib
import mimetypes
from_addr = 'noah.gift@gmail.com'
to_addr = 'jjinux@gmail.com'
subject_header = 'Subject: Sending PDF Attachemt'
attachment = 'disk_usage.pdf'
body = '''
This message sends a PDF attachment created with Report
Lab.
'''
m = MIMEMultipart()
m["To"] = to_addr
m["From"] = from_addr
m["Subject"] = subject_header
ctype, encoding = mimetypes.guess_type(attachment)
print ctype, encoding
maintype, subtype = ctype.split('/', 1)
print maintype, subtype
m.attach(MIMEText(body))
fp = open(attachment, 'rb')
msg = MIMEBase(maintype, subtype)
msg.set_payload(fp.read())
fp.close()
encoders.encode_base64(msg)
msg.add_header("ContentDisposition", "attachment", filename=attachment)
m.attach(msg)
s = smtplib.SMTP("localhost")
s.set_debuglevel(1)
s.sendmail(from_addr, to_addr, m.as_string())
s.quit()
```

Итак, мы совсем немного поколдовали, чтобы закодировать и отпра
вить по электронной почте наш созданный ранее отчет в формате PDF
об использовании дискового пространства.

**Trac**

Trac – это вики (wiki) и система отслеживания проблем. Она обычно
используется в процессе разработки программного обеспечения и на
писана на языке Python, но в действительности может использоваться
везде, где необходима вики или система регистрации сообщений. По
следнюю версию документации к системе Trac можно найти по адресу:
http://trac.edgewall.org/. Детальное обсуждение Trac выходит далеко
за рамки этой книги, но это достаточно хороший инструмент, который
может использоваться для регистрации поступающих сообщений об
ошибках. Одна из интересных особенностей Trac состоит в том, что эта
система допускает возможность расширения с помощью дополнитель
ных модулей.
Мы упомянули эту систему, потому что она вписывается во все три по
следние темы, которые мы обсуждали: сбор информации, форматиро
вание и распространение. Реализация вики в системе дает возмож
ность пользователям создавать вебстраницы с помощью броузеров.
Информация, которую они добавляют таким способом, становится
доступна в формате HTML другим пользователям. Таким образом, сис
тема реализует полный цикл, обсуждаемый в этой главе.
Точно так же система регистрации и отслеживания сообщений дает
возможность пользователям помещать свои предложения или сообще
ния об обнаруженных проблемах. Вы с ее помощью сможете состав
лять отчеты о сообщениях, введенных через вебинтерфейс, и даже ге
нерировать отчеты в формате CSV. Напомним еще раз, что система
Trac охватывает полный цикл от сбора до распространения информа
ции, который рассматривается в этой главе.

Мы рекомендуем вам познакомиться с системой Trac поближе, чтобы
понять, насколько полно она отвечает вашим потребностям. Может
быть, вам потребуется нечто более мощное или наоборот, чтонибудь
попроще, но эта система достойна того, чтобы познакомиться с ней по
ближе.

### В заключение.

В этой главе мы рассмотрели автоматизированный и ручной способы
сбора информации. Мы также рассмотрели способы объединения соб
ранных данных в документы наиболее распространенных форматов,
а именно: HTML, PDF и PNG. В заключение мы рассмотрели способы
передачи информации заинтересованным в ней лицам. Как мы уже го
ворили в начале главы, составление документации может быть не са
мой приятной частью вашей работы. Возможно, при поступлении на
работу вы даже не представляли себе, что придется заниматься доку
ментацией. Но ясная и понятная документация – это чрезвычайно
важный элемент системного администрирования. Мы надеемся, что
советы из этой главы помогут сделать несколько рутинную работу по
созданию документации намного более увлекательной.
