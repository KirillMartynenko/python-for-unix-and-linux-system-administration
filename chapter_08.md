## Глава 8. Окрошка из операционных систем

**Введение**

Быть системным администратором зачастую означает быть брошен
ным на съедение волкам. Правила, предварительное планирование
и даже выбор операционной системы часто находятся вне сферы ваше
го влияния. В настоящее время чтобы быть хотя бы маломальски эф
фективным системным администратором, вам необходимо знать их
все, мы имеем в виду все операционные системы. От Linux до Solaris,
Mac OS X и FreeBSD – все эти системы должны быть вам знакомы.
Только время покажет, продолжат ли свое существование такие па
тентованные операционные системы, как AIX или HPUX, но они все
еще необходимы многим людям.

К счастью, здесь нам на помощь опять приходит язык Python – мы на
деемся, что вы обратили внимание, что в состав языка входит полно
масштабная стандартная библиотека, которая способна удовлетворить
практически все потребности администраторов самых разнообразных
операционных систем. В составе стандартной библиотеки имеются мо
дули, которые позволят системному администратору реализовать все,
что ему необходимо, от архивирования каталогов и сравнения файлов
и каталогов до анализа конфигурационных файлов. Зрелость языка
Python вместе с его элегантностью и удобочитаемостью – причина то
го, что он не имеет себе равных в системном администрировании.

Во многих сложнейших областях человеческой деятельности, где тре
буются услуги системного администратора, таких как производство
мультипликационных фильмов или в вычислительных центрах, про
исходит отказ от применения языка Perl в пользу языка Python, пото
му что последний позволяет писать более элегантный и удобочитае
мый программный код. Язык Ruby – это достаточно интересный язык
программирования, в котором используются положительные особен


Кросс;платформенное программирование на языке Python в UNIX **279**

```
ности языка Python, но, тем не менее, мощность стандартной библио
теки и широта возможностей языка Python дает ему преимущества пе
ред языком Ruby при использовании в качестве языка системного ад
министрирования.
В этой главе будут рассматриваться несколько операционных систем,
поэтому у нас не будет времени исследовать какуюлибо из них доста
точно глубоко, но мы углубимся настолько, чтобы показать, что Python
может играть роль как универсального кроссплатформенного языка
сценариев, так и уникального средства администрирования каждой из
операционных систем. Кроме того, на горизонте замаячила «новая
операционная система», которая обретает форму центра обработки
данных. Эта новая платформа получила название «(за)облачная» обра
ботка данных (Cloud Computing), и мы поговорим о том, что предлага
ют компании Amazon и Google.
Но довольно бездельничать и балагурить. С кухни потянуло чемто
восхитительным... это что, окрошка из операционных систем?
```
**Кроссплатформенное программирование**

### на языке Python в UNIX Кроссплатформенное программирование

```
Хотя между разными UNIXподобными операционными системами
существуют некоторые значимые различия, но общего в них намного
больше. Один из способов примирить различные версии *nix состоит
в том, чтобы создавать кроссплатформенные инструменты и библио
теки, которые скрывают различия между операционными системами.
Основной способ добиться этого – использовать условные инструкции,
которые проверяют тип и версию операционной системы.
Язык Python неизменно следует философии «батарейки входят в ком
плект поставки» и предоставляет инструменты для решения практи
чески любой проблемы, с которой вы можете столкнуться. Для опреде
ления типа платформы, на которой выполняется ваш программный
код, существует модуль platform. Давайте поближе познакомимся с ос
новами использования этого модуля.
Самый простой способ познакомиться с возможностями модуля plat
form – написать сценарий, который будет выводить всю доступную ин
формацию о системе, как показано в примере 8.1.
```
```
Пример 8.1. Использование модуля platform для получения информации
о системе
#!/usr/bin/env python
import platform
```
```
profile = [
platform.architecture(),
platform.dist(),
```

**280** Глава 8. Окрошка из операционных систем

```
platform.libc_ver(),
platform.mac_ver(),
platform.machine(),
platform.node(),
platform.platform(),
platform.processor(),
platform.python_build(),
platform.python_compiler(),
platform.python_version(),
platform.system(),
platform.uname(),
platform.version(),
]
for item in profile:
print item
```
```
Ниже приводится результат работы этого сценария в операционной
системе OS X Leopard 10.5.2:
[ngift@Macintosh6][H:10879][J:0]% python cross_platform.py
('32bit', '')
('', '', '')
('', '')
('10.5.2', ('', '', ''), 'i386')
i386
Macintosh6.local
Darwin9.2.0i38632bit
i386
('r251:54863', 'Jan 17 2008 19:35:17')
GCC 4.0.1 (Apple Inc. build 5465)
2.5.1
Darwin
('Darwin', 'Macintosh6.local', '9.2.0', 'Darwin Kernel Version 9.2.0:
Tue Feb 5 16:13:22 PST 2008; root:xnu1228.3.13~1/
RELEASE_I386','i386','i386')
Darwin Kernel Version 9.2.0: Tue Feb 5 16:13:22 PST 2008;
root:xnu1228.3.13~1/RELEASE_I386
```
```
Этот пример позволяет получить представление о том, какого рода ин
формация об операционной системе нам доступна. Следующий шаг на
пути к созданию кроссплатформенного программного кода состоит
в необходимости создать модуль fingerprint, который будет «брать от
печатки пальцев», определяя, на какой платформе, с каким номером
версии он выполняется. В следующем примере мы «взяли отпечатки
пальцев» у следующих операционных систем: Mac OS X, Ubuntu, Red
Hat/CentOS, FreeBSD и SunOS. Взгляните на пример 8.2.
```
```
Пример 8.2. Определение типа операционной системы
#!/usr/bin/env python
import platform
```

Кросс;платформенное программирование на языке Python в UNIX **281**

```
"""
Определение принадлежности к одной из следующих операционных систем:
* Mac OS X
* Ubuntu
* Red Hat/Cent OS
* FreeBSD
* SunOS
"""
class OpSysType(object):
"""Определяет тип ОС с помощью модуля platform"""
def __getattr__(self, attr):
if attr == "osx":
return "osx"
elif attr == "rhel":
return "redhat"
elif attr == "ubu":
return "ubuntu"
elif attr == "fbsd":
return "FreeBSD"
elif attr == "sun":
return "SunOS"
elif attr == "unknown_linux":
return "unknown_linux"
elif attr == "unknown":
return "unknown"
else:
raise AttributeError, attr
def linuxType(self):
"""Определяет разновидность Linux с помощью различных методов"""
if platform.dist()[0] == self.rhel:
return self.rhel
elif platform.uname()[1] == self.ubu:
return self.ubu
else:
return self.unknown_linux
def queryOS(self):
if platform.system() == "Darwin":
return self.osx
elif platform.system() == "Linux":
return self.linuxType()
elif platform.system() == self.sun:
return self.sun
elif platform.system() == self.fbsd:
return self.fbsd
```
```
def fingerprint():
type = OpSysType()
print type.queryOS()
if __name__ == "__main__":
fingerprint()
```

**282** Глава 8. Окрошка из операционных систем

```
Теперь посмотрим, что выводит этот модуль при запуске на различных
платформах.
Red Hat:
[root@localhost]/# python fingerprint.py
redhat
```
```
Ubuntu:
```
```
root@ubuntu:/# python fingerprint.py
ubuntu
```
```
Solaris 10 или SunOS:
bash3.00# python fingerprint.py
SunOS
```
```
FreeBSD:
```
```
# python fingerprint.py
FreeBSD
```
```
Хотя в выводе этой команды не содержится ничего особенно интерес
ного, но в действительности она предоставляет нам очень мощный ин
струмент. Этот простой модуль позволит нам писать кроссплатфор
менный программный код, так как мы, например, можем определить
словарь с типами этих операционных систем и при нахождении соот
ветствия выполнять соответствующий платформозависимый про
граммный код. Одним из примеров получения самой ощутимой выго
ды от использования приемов кроссплатформенного программирова
ния могут служить сценарии, используемые для администрирования
сети посредством применения ssh с ключами. В этом случае программ
ный код может работать на многих платформах и давать непротиворе
чивые результаты.
```
**Использование SSH с ключами, каталога NFS**

**и кроссплатформенных сценариев Python**

**для управления системами**

```
Один из способов управления инфраструктурой из компьютеров, рабо
тающих под управлением разнотипных систем *nix, заключается в ис
пользовании ssh с ключами, общего каталога, монтируемого как том
NFS, и кроссплатформенного программного кода на языке Python.
Разобьем этот процесс на несколько шагов, чтобы было понятнее:
Шаг 1: создать открытый ключ ssh в системе, откуда будет выполнять
ся администрирование. Обратите внимание: для разных платформ эта
процедура может существенно отличаться. За подробностями обра
щайтесь к документации по операционной системе и к справочному
руководству по команде ssh. Создание ключа демонстрируется в при
мере 8.3.
```

Кросс;платформенное программирование на языке Python в UNIX **283**

```
Примечание к примеру ниже: с целью демонстрации мы созда
ли ключ для пользователя root, однако для обеспечения более
высокого уровня безопасности было бы лучше создать учетную
запись пользователя, для которого определить привилегии sudo
на запуск только этого сценария.
```
```
Пример 8.3. Создание открытого ключа ssh
[ngift@Macintosh6][H:11026][J:0]% sshkeygent rsa
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
6c:2f:6e:f6:b7:b8:4d:17:05:99:67:26:1c:b9:74:11 root@localhost.localdomain
[ngift@Macintosh6][H:11026][J:0]%
```
```
Шаг 2: Скопировать открытый ключ на администрируемые машины
исоздать файл authorized_keys , как показано в примере 8.4.
```
```
Пример 8.4. Копирование открытого ключа ssh
[ngift@Macintosh6][H:11026][J:0]% scp id_leop_lap.pub root@10.0.1.51:~/
.ssh/
root@10.0.1.51’s password:
id_leop_lap.pub
100% 403 0.4KB/s 00:00
[ngift@Macintosh6][H:11027][J:0]% ssh root@10.0.1.51
root@10.0.1.51’s password:
Last login: Sun Mar 2 06:26:10 2008
[root@localhost]~# cd .ssh
[root@localhost]~/.ssh# ll
total 8
rwrr 1 root root 403 Mar 2 06:32 id_leop_lap.pub
rwrr 1 root root 2044 Feb 14 05:33 known_hosts
[root@localhost]~/.ssh# cat id_leop_lap.pub > authorized_keys
[root@localhost]~/.ssh# exit
```
```
Connection to 10.0.1.51 closed.
[ngift@Macintosh6][H:11028][J:0]% ssh root@10.0.1.51
Last login: Sun Mar 2 06:32:22 2008 from 10.0.1.3
[root@localhost]~#
```
```
Шаг 3: смонтировать общий каталог NFS, содержащий модули, кото
рые потребуется запускать на стороне клиентов. Часто самый простой
способ добиться этого заключается в использовании функции autofs
и в последующем создании символической ссылки. Однако то же са
мое можно реализовать на основе системы управления версиями, с по
мощью которой через ssh обновлять локальные репозитарии SVN
с программным кодом на администрируемых машинах. После таких
```

**284** Глава 8. Окрошка из операционных систем

```
обновлений сценарии будут использовать самые свежие версии моду
лей. Например, в системе на базе дистрибутива Red Hat можно было
бы выполнить, например, такую команду:
lns /net/nas/python/src /src
```
```
Шаг 4: написать сценарий, который будет запускать программный код
на удаленных машинах. Теперь, когда у нас имеются ключи ssh и смон
тированный каталог NFS (или каталог, находящийся под контролем
системы управления версиями), это достаточно простая задача. Как
обычно, начнем с примера наиболее простого сценария, выполняюще
го администрирование удаленных систем через ssh. Если ранее вам ни
когда не приходилось делать ничего подобного, вас наверняка удивит,
насколько просто можно выполнять достаточно сложные действия.
В примере 8.5 реализован запуск простой команды uname.
```
```
Пример 8.5. Простой управляющий сценарий
#!/usr/bin/env python
import subprocess
```
```
"""
Система управления на основе ssh
"""
machines = ["10.0.1.40",
"10.0.1.50",
"10.0.1.51",
"10.0.1.60",
"10.0.1.80"]
```
```
cmd = "uname"
for machine in machines:
subprocess.call("ssh root@%s %s" % (machine, cmd), shell=True)
```
```
Выполнив этот сценарий на пяти машинах с указанными IPадресами,
которые работают под управлением CentOS 5, FreeBSD 7, Ubuntu 7.1
и Solaris 10, мы получили следующие результаты:
```
```
[ngift@Macintosh6][H:11088][J:0]% python dispatch.py
Linux
Linux
Linux
SunOS
FreeBSD
```
```
Однако у нас имеется модуль, более точно определяющий тип опера
ционной системы, поэтому используем его для получения более точно
го описания машин, которым посылаются команды, для чего создадим
временный каталог src на каждой удаленной машине и скопируем ту
да наш программный код. Конечно, после создания управляющего
сценария становится очевидной потребность в устойчивом интерфейсе
командной строки к нему, так как в противном случае нам придется
```

Кросс;платформенное программирование на языке Python в UNIX **285**

```
изменять сам сценарий, чтобы выполнить какуюнибудь другую ко
манду, как показано ниже:
```
```
cmd = "mkdir /src"
```
```
или:
```
```
cmd = "python /src/fingerprint.py"
```
```
или даже:
```
```
subprocess.call("scp fingerprint.py root@%s:/src/" % machine, shell=True)
```
```
Мы сделаем это, как только запустим наш сценарий fingerprint.py, но
сначала посмотрим на новую команду:
#!/usr/bin/env python
import subprocess
"""
Система управления на основе ssh
"""
machines = ["10.0.1.40",
"10.0.1.50",
"10.0.1.51",
"10.0.1.60",
"10.0.1.80"]
cmd = "python /src/fingerprint.py"
for machine in machines:
subprocess.call("ssh root@%s %s" % (machine, cmd), shell=True)
```
```
А теперь посмотрим, что получилось:
[ngift@Macintosh6][H:11107][J:0]# python dispatch.py
redhat
ubuntu
redhat
SunOS
FreeBSD
```
```
Благодаря модулю fingerprint.py результаты выглядят намного луч
ше. Безусловно, несколько строк в нашем управляющем сценарии тре
буют кардинальной перестройки, потому что в противном случае нам
всякий раз будет необходимо редактировать его. Нам требуется более
удобный инструмент, поэтому давайте создадим его.
```
**Создание кроссплатформенного**

**инструмента управления**

```
Решение об использовании ключей ssh в соединении с простой систе
мой управления оказалось недостаточно удобным, потому что его
сложно расширять или повторно использовать. Попробуем определить
перечень проблем, характерных для предыдущего инструмента, а затем
```

**286** Глава 8. Окрошка из операционных систем

```
составим список требований, устраняющих эти проблемы. Проблемы:
список администрируемых машин определяется жестко, в самом сце
нарии; выполняемая команда жестко задана в сценарии; допускается
запуск только одной команды за раз; один и тот же набор команд вы
полняется на всех машинах, мы лишены возможности выбора; наш
управляющий сценарий ожидает, пока не будет получен ответ на каж
дую команду. Требования: нам необходим инструмент командной
строки, который будет получать IPадреса и команды, которые надле
жит выполнить, из конфигурационного файла; нам необходим интер
фейс командной строки с параметрами, чтобы можно было передавать
команды машинам; нам необходим инструмент управления, который
будет запускать команды в отдельных потоках выполнения, чтобы не
блокировать процесс.
Похоже, что нам необходимо выработать элементарный синтаксис
конфигурационного файла с разделом для машин и с разделом для ко
манд. Взгляните на пример 8.6.
```
```
Пример 8.6. Конфигурационный файл для управляющего сценария
[MACHINES]
CENTOS: 10.0.1.40
UBUNTU: 10.0.1.50
REDHAT: 10.0.1.51
SUN: 10.0.1.60
FREEBSD: 10.0.1.80
[COMMANDS]
FINGERPRINT : python /src/fingerprint.py
```
```
Теперь нам необходимо написать функцию, которая будет читать со
держимое конфигурационного файла и выделять разделы MACHINES
и COMMANDS, чтобы можно было выполнять обход этих разделов по
очереди, как показано в примере 8.7.
```
```
Следует заметить, что команды из конфигурационного файла
будут импортироваться в случайном порядке. В большинстве
случаев это может оказаться неприемлемым и, возможно, было
бы лучше просто написать модуль на языке Python, который бу
дет играть роль конфигурационного файла.
```
```
Пример 8.7. Улучшенный сценарий управления
#!/usr/bin/env python
import subprocess
import ConfigParser
```
```
"""
Система управления на основе ssh
"""
def readConfig(file="config.ini"):
"""
Извлекает IPадреса и команды из конфигурационного файла
```

Кросс;платформенное программирование на языке Python в UNIX **287**

```
и возвращает кортеж
"""
ips = []
cmds = []
Config = ConfigParser.ConfigParser()
Config.read(file)
machines = Config.items("MACHINES")
commands = Config.items("COMMANDS")
for ip in machines:
ips.append(ip[1])
for cmd in commands:
cmds.append(cmd[1])
return ips, cmds
ips, cmds = readConfig()
```
```
#Выполнить все команды для каждого IPадреса
for ip in ips:
for cmd in cmds:
subprocess.call("ssh root@%s %s" % (ip, cmd), shell=True)
```
```
Эти несложные изменения повысили удобство использования. Мы мо
жем произвольно изменять список команд и машин и выполнять сразу
все команды. Если теперь взглянуть на вывод сценария, можно убе
диться, что он не изменился:
```
```
[ngift@Macintosh6][H:11285][J:0]# python advanced_dispatch1.py
redhat
redhat
ubuntu
SunOS
FreeBSD
```
```
Хотя это весьма усовершенствованный инструмент, у нас попрежне
му отсутствует механизм выполнения команд в отдельных потоках,
наличие которого определено в нашей спецификации. К счастью, мы
можем воспользоваться некоторыми приемами, описанными в главе,
посвященной процессам, и легко реализовать многопоточный режим
выполнения. В примере 8.8 показано, что для этого можно сделать.
```
```
Пример 8.8. Многопоточный инструмент управления командами
#!/usr/bin/env python
import subprocess
import ConfigParser
from threading import Thread
from Queue import Queue
import time
"""
Многопоточная система управления на основе ssh
"""
start = time.time()
queue = Queue()
```

**288** Глава 8. Окрошка из операционных систем

```
def readConfig(file="config.ini"):
"""
Извлекает IPадреса и команды из конфигурационного файла
и возвращает кортеж
"""
ips = []
cmds = []
Config = ConfigParser.ConfigParser()
Config.read(file)
machines = Config.items("MACHINES")
commands = Config.items("COMMANDS")
for ip in machines:
ips.append(ip[1])
for cmd in commands:
cmds.append(cmd[1])
return ips, cmds
```
```
def launcher(i,q, cmd):
"""Запускает команды в потоке выполнения, отдельном для каждого IP"""
while True:
#Получить ip, cmd из очереди
ip = q.get()
print "Thread %s: Running %s to %s" % (i, cmd, ip)
subprocess.call("ssh root@%s %s" % (ip, cmd), shell=True)
q.task_done()
```
```
#Получить IPадреса и команды из конфигурационного файла
ips, cmds = readConfig()
```
```
#Определить количество используемых потоков, но не более 25
if len(ips) < 25:
num_threads = len(ips)
else:
num_threads = 25
#Запустить потоки
for i in range(num_threads):
for cmd in cmds:
worker = Thread(target=launcher, args=(i, queue,cmd))
worker.setDaemon(True)
worker.start()
print "Main Thread Waiting"
for ip in ips:
queue.put(ip)
queue.join()
end = time.time()
print "Dispatch Completed in %s seconds" % end – start
```
```
Если теперь взглянуть на вывод нового многопоточного механизма
управления, можно заметить, что на выполнение всех команд потребо
валось около 1,2 секунды. Чтобы увидеть различия в скорости выпол
```

Кросс;платформенное программирование на языке Python в UNIX **289**

```
нения, нам следует добавить измерение времени в оригинальный
управляющий сценарий и сравнить полученные результаты:
```
```
[ngift@Macintosh6][H:11296][J:0]# python threaded_dispatch.py
Main Thread Waiting
Thread 1: Running python /src/fingerprint.py to 10.0.1.51
Thread 2: Running python /src/fingerprint.py to 10.0.1.40
Thread 0: Running python /src/fingerprint.py to 10.0.1.50
Thread 4: Running python /src/fingerprint.py to 10.0.1.60
Thread 3: Running python /src/fingerprint.py to 10.0.1.80
redhat
redhat
ubuntu
SunOS
FreeBSD
Dispatch Completed in 1 seconds
```
```
После добавления в оригинальный управляющий сценарий простого
программного кода, выполняющего замер времени, мы получили сле
дующее:
```
```
[ngift@Macintosh6][H:11305][J:0]# python advanced_dispatch1.py
redhat
redhat
ubuntu
SunOS
FreeBSD
Dispatch Completed in 3 seconds
```
```
Исходя из этих результатов, можно сказать, что наша многопоточная
версия оказалась примерно в три раза быстрее. Если бы мы использова
ли этот инструмент для опроса сети, скажем, из 500 машин, а не из 5,
разница в производительности могла бы оказаться еще более сущест
венной. Пока разработка нашего кроссплатформенного инструмента
управления продвигается достаточно успешно, поэтому сделаем сле
дующий шаг и создадим кроссплатформенный инструмент сборки.
```
```
Следует заметить, что для реализации этого сценария, возмож
но, более удачным решением было бы использование многоза
дачной версии IPython. За подробностями обращайтесь по адре
су: http://ipython.scipy.org/moin/Parallel_Computing.
```
**Создание кроссплатформенного инструмента сборки**

```
Мы уже знаем, как распределять работу между несколькими машина
ми, как определять тип операционной системы, под управлением ко
торой выполняется сценарий, и, наконец, создавать универсальную
декларацию с помощью менеджера пакетов EPM, который способен
создавать специализированные пакеты в зависимости от типа опера
ционной системы. Почему бы нам не объединить все это вместе? Мы
```

**290** Глава 8. Окрошка из операционных систем

```
можем использовать эти три приема, чтобы создать кроссплатфор
менный инструмент сборки.
С появлением технологии виртуальных машин стало весьма просто
создавать виртуальные машины для любых свободно распространяе
мых UNIXподобных операционных систем, таких как Debian/Ubuntu,
Red Hat/CentOS, FreeBSD и Solaris. Теперь, создав инструмент, кото
рый вы хотите сделать доступным всему миру или просто коллегам
в вашей компании, вы легко и просто можете создать «сборочный цех»,
возможно даже на своем ноутбуке, где ведется разработка сценария,
и создавать специализированные пакеты сразу же с этим сценарием.
Как это будет работать? Самый простой способ достичь этого – создать
общее дерево сборки пакета на разделе NFS и предоставить доступ
к этой точке монтирования всем серверам сборки. После этого, исполь
зуя инструменты, созданные нами ранее, настроить серверы на сборку
пакетов в каталоге NFS. Менеджер пакетов EPM позволяет создавать
простые декларации, или «списки» файлов, кроме того, у нас имеется
модуль fingerprint, поэтому самое сложное уже позади. Осталось на
писать программный код, который делает только то, что осталось.
Ниже показано, как может выглядеть сценарий сборки:
#!/usr/bin/env python
from fingerprint import fingerprint
from subprocess import call
```
```
os = fingerprint()
#Получить корректный ключ для EPM
epm_keyword = {"ubuntu":"dpkg", "redhat":"rpm", "SunOS":"pkg", "osx":"osx"}
try:
epm_keyword[os]
except Exception, err:
print err
subprocess.call("epmf %s helloEPM hello_epm.list" %
platform_cmd,shell=True)
```
```
Теперь можно отредактировать конфигурационный файл config.ini , пе
реориентировав его на запуск нового сценария.
[MACHINES]
CENTOS: 10.0.1.40
UBUNTU: 10.0.1.50
REDHAT: 10.0.1.51
SUN: 10.0.1.60
FREEBSD: 10.0.1.80
[COMMANDS]
FINGERPRINT = python /src/create_package.py
```
```
Теперь осталось только запустить многопоточную версию инструмента
сборки и – эврика! – нам удалось создать пакеты для CentOS, Ubuntu,
```

PyInotify **291**

```
Red Hat, FreeBSD и Solaris за считанные секунды. Этот сценарий еще
нельзя рассматривать как окончательную рабочую версию программ
ного кода, так как в нем отсутствует обработка ошибок, но он прекрас
но демонстрирует, что позволяет сделать язык Python на скорую руку,
всего за несколько минут или часов.
```
**PyInotify**

```
Если вам выпадет честь работать с платформами GNU/Linux, вы по
достоинству оцените возможности PyInotify. Согласно документации
это: «модуль Python для обнаружения изменений в файловой систе
ме». Официальная страница проекта находится по адресу http://pyino>
tify.sourceforge.net.
В примере 8.9 показано, как работать с этим модулем.
```
```
Пример 8.9. Сценарий слежения за событиями с помощью модуля Pyinotify
import os
import sys
from pyinotify import WatchManager, Notifier, ProcessEvent, EventsCodes
```
```
class PClose(ProcessEvent):
"""
Обработка события закрытия
"""
def __init__(self, path):
self.path = path
self.file = file
def process_IN_CLOSE(self, event):
"""
Обработка событий 'IN_CLOSE_*'
может принимать функциюобработчик
"""
path = self.path
if event.name:
self.file = "%s" % os.path.join(event.path, event.name)
else:
self.file = "%s" % event.path
print "%s Closed" % self.file
print "Performing pretend action on %s...." % self.file
import time
time.sleep(2)
print "%s has been processed" % self.file
```
```
class Controller(object):
def __init__(self, path='/tmp'):
self.path = path
def run(self):
self.pclose = PClose(self.path)
```

**292** Глава 8. Окрошка из операционных систем

```
PC = self.pclose
# следить только за этими событиями
mask = EventsCodes.IN_CLOSE_WRITE | EventsCodes.IN_CLOSE_NOWRITE
# экземпляр менеджера слежения за событиями
wm = WatchManager()
notifier = Notifier(wm, PC)
```
```
print 'monitoring of %s started' % self.path
added_flag = False
# читать и обрабатывать события
while True:
try:
if not added_flag:
# на первой итерации добавить слежение за каталогом:
# обрабатываемые события определяются маской.
wm.add_watch(self.path, mask)
added_flag = True
notifier.process_events()
if notifier.check_events():
notifier.read_events()
except KeyboardInterrupt:
# ...пока не будет нажата комбинация CtrlC
print 'stop monitoring...'
# прекратить слежение за событиями
notifier.stop()
break
except Exception, err:
# продолжить слежение
print err
```
```
def main():
monitor = Controller()
monitor.run()
if __name__ == '__main__':
main()
```
```
Если запустить этот сценарий, он начнет выполнять «требуемые» дей
ствия при помещении чего бы то ни было в каталог /tmp. Этот пример
должен дать вам некоторое представление о том, как фактически сде
лать чтонибудь полезное, например, добавить функцию обратного вы
зова для выполнения требуемых действий. Здесь же можно было ис
пользовать часть программного кода из главы «Данные», например,
для автоматического поиска и удаления дубликатов или для архиви
рования файлов, если их имена соответствуют определяемому вами
критерию в функции fnmatch(). В общем, это интересный и полезный
модуль Python, который работает только в Linux.
```

#### OS X 293

### OS X.

```
OS X является довольно экзотической операционной системой, если не
сказать больше. С одной стороны, она обладает, пожалуй, самым луч
шим пользовательским интерфейсом Cocoa, а с другой, в версии Leo
pard, она является полностью POSIXсовместимой операционной сис
темой UNIX. Системе OS X удалось добиться того, чего не удалось ни
одному производителю операционных систем UNIX: она вывела UNIX
на уровень массового потребления. Версия OS X Leopard включает в се
бя Python 2.5.1, Twisted и многие другие замечательные программные
компоненты на языке Python.
Разработчики системы OS X следуют несколько странной парадигме,
предлагая операционную систему и в серверном, и в обычном исполне
нии. Хотя, безусловно, компания Apple имеет на это полное право,
возможно, ей стоит отказаться от такой архаичной идеи; мы же здесь
не будем обсуждать плюсы и минусы концепции единой ОС по единой
цене. Серверная версия операционной системы предлагает более пол
ный комплект инструментов командной строки для администрирова
ния, а также ряд компонентов, характерных для Apple, таких как воз
можность загрузки по сети, возможность работы с серверами катало
гов LDAP, и многие другие особенности.
```
**Взаимодействие с DSCL, утилитой службы каталогов**

```
Название DSCL происходит от Directory Services Command Line (ко
мандная строка службы каталогов) и представляет собой удобный спо
соб доступа к прикладному интерфейсу службы каталогов в OS X.
DSCL позволяет читать, создавать и удалять записи, что язык Python
позволяет делать естественным образом. В примере 8.10 демонстриру
ется взаимодействие с DSCL в оболочке IPython для чтения атрибутов
службы Open Directory и их значений.
```
```
Обратите внимание, что в этом примере мы только читаем зна
чения атрибутов, но точно так же, используя тот же прием,
можно было бы организовать и их изменение.
```
```
Пример 8.10. Получение записи пользователя в интерактивной оболочке
IPython с помощью DSCL
In [40]: import subprocess
```
```
In [41]: p = subprocess.Popen("dscl. read /Users/ngift",
shell=True,stdout=subprocess.PIPE)
```
```
In [42]: out = p.stdout.readlines()
In [43]: for line in out:
line.strip().split()
Out[46]: ['NFSHomeDirectory:', '/Users/ngift']
```

**294** Глава 8. Окрошка из операционных систем

```
Out[46]: ['Password:', '********']
Out[46]: ['Picture:']
Out[46]: ['/Library/User', 'Pictures/Flowers/Sunflower.tif']
Out[46]: ['PrimaryGroupID:', '20']
Out[46]: ['RealName:', 'ngift']
Out[46]: ['RecordName:', 'ngift']
Out[46]: ['RecordType:', 'dsRecTypeStandard:Users']
Out[46]: ['UniqueID:', '501']
Out[46]: ['UserShell:', '/bin/zsh']
```
```
Это замечательно, что в Apple организовали централизованное управле
ние локальными учетными записями и учетными записями LDAP/Ac
tive Directory с помощью команды dscl. Утилита dscl – это как глоток
свежего воздуха по сравнению с другими средствами управления LDAP,
даже если вынести использование Python за скобки. У нас недостаточно
места, чтобы углубляться в подробности. Тем не менее, заметим, что
с помощью языка Python и утилиты dscl можно очень легко организо
вать программное управление учетными записями как в локальной ба
зе данных, так и в базе данных LDAP, такой как Open Directory, а пре
дыдущий пример должен показать вам, с чего следует начинать.
```
**Взаимодействие с прикладным интерфейсом OS X**

```
Часто администратору OS X бывает необходимо знать, как организо
вать взаимодействие с фактическим интерфейсом пользователя. В OS X
Leopard для языков Python и Ruby предоставляется доступ к механиз
му Scripting Bridge. За дополнительной информацией по этому меха
низму обращайтесь по адресу http://developer.apple.com/documentation/
Cocoa/Conceptual/RubyPythonCocoa/Introduction/Introduction.html.
Как вариант, для доступа к OSA, или Open Scripting Architecture (от
крытая архитектура сценариев), можно использовать модуль py–app
script со страницей проекта по адресу http://sourceforge.net/projects/
appscript.
Работать с модулем py–appscript – одно удовольствие, так как он дает
возможность из языка Python взаимодействовать с очень богатой воз
можностями архитектурой OSA. Но прежде чем познакомится с ним
поближе, мы сначала воспользуемся простым инструментом команд
ной строки osascript, на примере которого продемонстрируем, как
можно организовать взаимодействие с прикладным интерфейсом сце
нариев. В OS X Leopard теперь имеется возможность писать инстру
менты командной строки, работающие под управлением osascript,
и выполнять их как обычные сценарии Bash или Python. Давайте на
пишем сценарий с именем bofh.osa, как показано ниже, и затем запус
тим его. Текст сценария приводится в примере 8.11.
```
```
Пример 8.11. Сценарий «Hello, Bastard Operator From Hell»
#!/usr/bin/osascript
say "Hello, Bastard Operator From Hell" using "Zarvox"
```

#### OS X 295

```
Если запустить этот сценарий из командной строки, механический го
лос поприветствует нас. Это немножко глупо, но это же Mac OS X; она
вполне допускает такие вещи.
А теперь погрузимся в использование модуля appscript для доступа
к тому же самому API из сценариев на языке Python, но сделаем это
в интерактивном режиме, в оболочке IPython. Ниже представлена инте
рактивная версия примера, включенного в исходные тексты appscript,
который выводит список всех запущенных процессов в алфавитном
порядке:
In [4]: from appscript import app
```
```
In [5]: sysevents = app('System Events')
In [6]: processnames = sysevents.application_processes.name.get()
```
```
In [7]: processnames.sort(lambda x, y: cmp(x.lower(), y.lower()))
In [8]: print '\n'.join(processnames)
Activity Monitor
AirPort Base Station Agent
AppleSpell
Camino
DashboardClient
DashboardClient
Dock
Finder
Folder Actions Dispatcher
GrowlHelperApp
GrowlMenu
iCal
iTunesHelper
JavaApplicationStub
loginwindow
mdworker
PandoraBoy
Python
quicklookd
Safari
Spotlight
System Events
SystemUIServer
Terminal
TextEdit
TextMate
```
```
Если вам придется решать задачи автоматизации с применением при
ложений OS X, модуль appscript окажется для вас удачной находкой,
так как с его помощью в языке Python можно реализовать такие дейст
вия, которые ранее были возможны только в языке Applescript. Ноа
Гифт (Noah Gift) написал статью, в которой немного рассказывается
```

**296** Глава 8. Окрошка из операционных систем

```
об этом: http://www.macdevcenter.com/pub/a/mac/2007/05/08/using>
python>and>applescript>to>get>the>most>out>of>your>mac.html.
Коечто системный администратор может выполнять с помощью Final
Cut Pro, создавая пакеты операций, взаимодействующих, например,
с Adobe After Effects. Кроме того, в OS X с помощью Applescript Studio
можно быстро создать графический интерфейс и вызывать из него сце
нарий на языке Python командой do shell script. Мало кому известно,
что оригинальная версия Carbon Copy Cloner была написана в App
lescript Studio. Если у вас есть свободное время, вам стоит познако
миться с этой средой поближе.
```
**Автоматическое восстановление системы**

```
ASR – это еще один революционный, опередивший время инструмент
командной строки, разработанный для OS X. Этот инструмент являет
ся ключевым компонентом очень популярной утилиты с именем Car
bon Copy Cloner и служит для автоматизации многих ситуаций. Ноа
(Noah) использовал утилиту asr в паре с Netboot для автоматического
восстановления – фактически он ввел полную автоматизацию этого
процесса в одном из мест, где он работал. Пользователю достаточно
было просто перезагрузить свою машину и удерживать клавишу «N»,
чтобы перейти в режим загрузки по сети, и в результате либо наступал
«конец игры», либо машина сама исправляла повреждения.
Пожалуйста, не рассказывайте об этом никому, потому что многие до
сих пор думают, что он все еще работает там. Ниже, в примере 8.12
приводится упрощенная версия сценария для автоматического восста
новления системы, который может быть запущен при загрузке по сети
или со второго раздела жесткого диска. С точки зрения настроек, ката
лог /Users , как и любой другой жизненно важный каталог, должен
быть символической ссылкой, ведущей в другой раздел, или должен
находиться в сети, что еще лучше. Смотрите пример 8.12.
```
```
Пример 8.12. Сценарий автоматического восстановления раздела жесткого
диска в OS X, демонстрирующий ход выполнения с помощью
виджета из библиотеки WXPython
#!/usr/bin/env pythonw
#автоматически восстанавливает раздел жесткого диска
```
```
import subprocess
import os
import sys
import time
from wx import PySimpleApp, ProgressDialog, PD_APP_MODAL, PD_ELAPSED_TIME
#команда пересоздания главного раздела с помощью утилиты asr
asr = '/usr/sbin/asrsource '
#переменные, содержащие различные пути
os_path = '/Volumes/main’
```

#### OS X 297

```
ipath = '/net/server/image.dmg '
dpath = 'target /Volumes/mainerase nopromptoverify &'
reimage_cmd = "%s%s%s" % (asr,ipath, dpath)
#Команды перезагрузки
reboot = 'reboot'
bless = '/usr/sbin/blessfolder /Volumes/main/System/Library/CoreServices
setOF'
#часть использования wxpython
application = PySimpleApp()
dialog = ProgressDialog ('Progress', 'Attempting Rebuild of Main Partition',
maximum = 100, style = PD_APP_MODAL | PD_ELAPSED_TIME)
def boot2main():
"""Делает новый раздел загружаемым и выполняет перезагрузку"""
subprocess.call(bless, shell=True)
subprocess.call(reboot, shell=True)
def rebuild():
"""Пересоздает раздел"""
try:
time.sleep(5) #Дать диалогу время на запуск
subprocess.call(reimage_cmd)
except OSError:
print "CMD: %s [ERROR: invalid path]" % reimage_cmd
sys.exit(1)
time.sleep(30)
while True:
if os.path.exists(os_path):
x = 0
wxSleep(1)
dialog.Update (x + 1,
"Rebuild is complete...\n rebooting to main partition\n
...in 5 seconds..")
wxSleep(5)
print "repaired volume.." + os_path
boot2main() #вызывает функции reboot/bless
break
else:
x = 0
wxSleep(1)
dialog.Update ( x + 1, 'Reimaging.... ')
def main():
if os.path.exists(os_path):
rebuild()
else:
print "Could not find valid path...FAILED.."
sys.exit(1)
if __name__ == "__main__":
main()
```

**298** Глава 8. Окрошка из операционных систем

```
Этот сценарий пытается пересоздать раздел и выводит средствами биб
лиотеки WXPython индикатор хода выполнения. Если путь указан
корректно и не обнаружено ошибок, выполняется пересоздание разде
ла жесткого диска с помощью команды asr, в процессе выполнения ко
торой выводится индикатор, показывающий ход выполнения опера
ции, затем новый раздел назначается загружаемым с помощью коман
ды bless, после чего выполняется перезагрузка машины.
Этот сценарий легко можно превратить в основу системы управления
и распространения дистрибутива системы уровня предприятия, по
скольку достаточно легко организовать установку различных образов,
основываясь на данных об аппаратной комплектации или даже считы
вая «старую» метку жесткого диска. После этого можно, например,
организовать программную установку пакетов программного обеспе
чения с помощью системы управления пакетами в OS X или с помо
щью свободно распространяемого инструмента radmind. Ноа (Noah)
реализовал один интересный сценарий, в котором сначала в автомати
ческом режиме развертывал базовую систему OS X, а затем завершал
установку остальных пакетов с помощью radmind.
Если вы всерьез собираетесь заниматься администрированием систем
OS X, то вам определенно стоило бы поближе познакомиться с radmind.
Radmind – это своего рода система автоматического обновления, кото
рая обнаруживает изменения в файловой системе и обеспечивает воз
можность восстановления машин на основе этих изменений. Дополни
тельную информацию о radmind вы найдете на странице http://
rsug.itd.umich.edu/software/radmind/. Несмотря на то, что программа
radmind написана не на языке Python, ее легко можно было бы пере
писать на этом языке.
```
### Управление DNS с помощью сценариев на языке Python

```
В главе 3 мы выполняли анализ потока информации в формате XML,
генерируемого утилитой system_profiler, используя для этого библио
теку ElementTree. Но в OS X в Python встроена поддержка библиотеки
plistlib, которая позволяет анализировать и создавать файлы Plist.
Сам модуль тоже называется plistlib. У нас нет возможности проде
монстрировать этот модуль на примерах, но вам стоит познакомиться
с ним поближе самостоятельно.
```
### Администрирование систем Red Hat Linux

```
В Red Hat язык Python используется очень широко – и в компании,
и в операционной системе. Некоторые из наиболее интересных новых
способов использования Python родились в группе Emerging Technolo
gies: http://et.redhat.com/page/Main_Page. Ниже приводится список
некоторых проектов, использующих язык Python:
```
**-** Libvert – API виртуализации менеджера виртуальных машин


Администрирование Ubuntu **299**

**-** VirtInst – приложение управления виртуальными машинами на ба
    зе библиотеки libvirt^1 , написанное на языке Python + PyGTK
**-** Библиотека Python, упрощающая инициализацию гостевых вирту
    альных машин на основе libvirt
**-** Cobbler – продукт, позволяющий создавать полностью автоматизи
    рованные серверы загрузки для нужд PXE и виртуализации
**-** VirtFactory: сетевая среда управления виртуальными приложе
    ниями
**-** FUNC (Fedora Unified Network Controller)

### Администрирование Ubuntu.

```
Можно сказать, что из всех основных дистрибутивов Linux Ubuntu яв
ляется одним из самых влюбленных в Python. Отчасти потому, что
Марк Шаттлворт (Mark Shuttleworth), создатель дистрибутива, долгое
время – с начала 90 годов – работал с языком Python. Одним из заме
чательных источников пакетов на языке Python для Ubuntu является
Launchpad: http://launchpad.net.
```
### Администрирование систем Solaris.

```
С конца 90х до начала 2000х годов операционная система Solaris за
нимала практически непоколебимое место в мире UNIX. В начале
2000х годов Linux подобно метеориту врезался в Solaris, в связи с чем
компании Sun пришлось испытать вполне реальные неприятности. Од
нако с недавнего времени все больше системных администраторов, раз
работчиков и предпринимателей снова начинают говорить о Solaris.
Из наиболее интересных нововведений, которые предполагает внести
Sun, можно назвать 6месячный цикл выпуска новых версий системы,
так же, как и в Ubuntu, с 18месячным периодом технической под
держки; отказ от создания объемного дистрибутива на DVDдиске
в пользу единственного CD, как в Ubuntu. Наконец, были заимствова
ны некоторые идеи из Red Hat и Fedora по созданию версии Solaris,
разрабатываемой сообществом. Загрузить или заказать загрузочный
CD можно по адресу: http://www.opensolaris.com.
Что все это означает для системного администратора, использующего
язык Python? Интерес к Sun быстро растет, и у нее имеется большое
количество весьма интересных технологий, начиная от ZFS и заканчи
вая контейнерами и LDOM, которые в некотором смысле можно срав
нить с виртуальными машинами VMware. Имеется даже связь с этой
книгой. Интерпретатор Python прекрасно работает в операционной
```
(^1) libvert и libvirt – это разные библиотеки! – _Прим. перев._


**300** Глава 8. Окрошка из операционных систем

```
системе Solaris и даже широко используется в разработке системы
управления пакетами для нее.
```
**Виртуализация**

```
14 августа 2007 года состоялось первое открытое размещение акций
компании VMware, которое принесло ей миллионы долларов и укре
пило позиции виртуализации как крупного направления в развитии
информационных технологий. Предсказание будущего всегда было
рискованным делом, однако все чаще в крупных компаниях слышны
слова «операционная система центра обработки данных», и все, от Mi
crosoft до Red Hat и Oracle, стремятся не опоздать сесть в поезд виртуа
лизации. Можно смело сказать, что со временем виртуализация пол
ностью изменит центры обработки данных и работу системных адми
нистраторов. Виртуализация – это элементарный пример действия
слишком частого использования фразы «прорывная технология».
Виртуализация – это обоюдоострое оружие для системных админист
раторов, так как, с одной стороны, позволяет легко тестировать систе
мы и приложения, но, с другой стороны, чрезвычайно увеличивает
сложность администрирования. Теперь на одной машине одновремен
но может работать сразу несколько операционных систем, здесь могут
находиться приложения для малого бизнеса или крупная часть вычис
лительного центра. За эффективность приходится платить, а обеспече
ние эффективности – прямая обязанность среднего системного адми
нистратора.
Возможно, прямо сейчас, читая эти строки, вы могли бы подумать: ка
кое отношение все это имеет к языку Python? Самое непосредственное.
В компании Racemi, где недавно работал Ноа (Noah), на языке Python
было написано полноценное приложение управления центром обра
ботки данных, которое имеет дело с виртуализацией. Python может
и действительно очень тесно взаимодействует с механизмами виртуа
лизации, начиная от управления виртуальными машинами и заканчи
вая перемещением систем с физических машин на виртуальные, ис
пользуя для этого Python API. В этом виртуализованном мире Python
чувствует себя как дома и можно смело утверждать, что он будет иг
рать далеко не последнюю роль в будущей операционной системе цен
тра обработки данных.
```
**VMware**

```
Как уже говорилось выше, компания VMware является лидером по
разработке технологий виртуализации. Наличие полного программно
го контроля над виртуальной машиной – это своего рода Чаша Грааля.
К счастью, существует несколько API на выбор: Perl, XMLRPC, Py
thon и C. К моменту написания этих строк некоторые реализации Py
thon имели определенные ограничения, но такое положение дел могло
```

Облачная обработка данных **301**

```
измениться. Похоже, что в VMware выбрали новое направление –
XMLRPC API.
Компания VMware выпускает несколько различных продуктов с раз
личными API. Из продуктов, с которыми вам может потребоваться
взаимодействовать, можно назвать VMware Site Recovery Manager,
VMware ESX Server, VMware Server и VMware Fusion.
У нас недостаточно места, чтобы охватить принципы взаимодействия
с этими технологиями, поскольку эта тема выходит далеко за рамки
данной книги, но они стоят того, чтобы следить за их развитием и за
тем, какую роль будет играть Python.
```
**Облачная обработка данных**

```
Толькотолько утихла шумиха вокруг виртуализации, как вдруг воз
ник шум об «облачной» обработке данных (cloud computing). Термин
«облачная обработка данных» обозначает технологию выделения вы
числительных ресурсов по требованию, в зависимости от величины ра
бочей нагрузки. В сфере развития технологии «облачной» обработки
данных присутствуют два крупных игрока – Amazon и Google. Бук
вально за несколько недель до передачи этой книги издателю компа
ния Google взорвала настоящую бомбу. Компания предложила инте
реснейшую «фишку», которая пока поддерживается только языком
Python. Поскольку эта книга посвящена языку Python, мы думаем,
что такое ограничение не слишком огорчит вас. В некотором смысле
такое предпочтение, отданное языку Python, напоминает нам рекламу
American Express.
В этом разделе мы пройдемся по некоторым имеющимся API, с кото
рыми вам придется столкнуться при работе с Amazon и с Google App
Engine. В заключение мы поговорим о том, как это может касаться
системных администраторов.
```
```
Вебслужбы Amazon на основе Boto
Отличную возможность для работы с инфраструктурой «облачной» об
работки данных Amazon предоставляет интерфейс Boto. Посредством
Boto обеспечивается доступ к таким службам, как Simple Storage Ser
vice, Simple Queue Service, Elastic Compute Cloud, Mechanical Turk,
SimpleDB. Это совершенно новый и очень мощный API, поэтому мы
рекомендуем заглянуть на домашнюю страницу проекта http://code.
google.com/p/boto/. Здесь вы сможете почерпнуть самую свежую ин
формацию, что лучше, чем приведение нами сведений, доступных на
данный момент.
Ниже приводится короткий пример взаимодействия со службой Sim
pleDB.
Соединение со службой:
```

**302** Глава 8. Окрошка из операционных систем

```
In [1]: import boto
In [2]: sdb = boto.connect_sdb()
```
```
Создание нового домена:
In [3]: domain = sdb.create_domain('my_domain')
```
```
Добавление нового элемента:
In [4]: item = domain.new_item('item')
```
```
Примерно так выглядит API в настоящее время, но, чтобы получить
полное представление, вам необходимо взглянуть на примеры в репо
зитарии svn: http://code.google.com/p/boto/source/browse. Заметим,
что изучение примеров – это один из лучших способов понять, как ра
ботает новая библиотека.
```
```
Google App Engine
Служба Google App Engine выпущена в состоянии бетаверсии и со дня
объявления была широко разрекламирована. Она позволяет свободно
запускать приложения в инфраструктуре Google. Приложения App
Engine имеют API пока только для Python, но со временем такое поло
жение дел может измениться. Одна из интереснейших особенностей
App Engine заключается в том, что она интегрирована с другими служ
бами Google.
Все более возможным становится перемещение большей части из того,
что находилось у вас в центре обработки данных, в другие центры, по
этому это все более затрагивает системных администраторов. Умение
взаимодействовать со службой Google App Engine может оказаться ка
```
```
ПОРТ РЕТ ЗНА МЕ НИ ТО СТИ: КО МАН ДА РАЗ РА БОТ ЧИ КОВ GOOGLE APP ENGINE
```
**Кевин Гиббс (Kevin Gibbs)**

```
Кевин Гиббс – технический лидер проекта Goo
gle App Engine. Кевин присоединился к Google
в 2004 году. До работы над Google App Engine
в течение ряда лет работал в группе разработки
инфраструктуры систем, где занимался система
ми управления кластерами, которые составляют
основу продуктов и служб компании Google. Кро
ме того, Кевин является автором Google Suggest, программного
продукта, обеспечивающего вывод интерактивных подсказок
в процессе ввода с клавиатуры. До присоединения к Google Ке
вин работал в группе передовых интернеттехнологий компании
IBM, где занимался созданием инструментов разработчика.
```

Облачная обработка данных **303**

```
чественно новым навыком для системного администратора, поэтому
есть смысл заняться ее исследованием.
Мы побеседовали с некоторыми специалистами из команды разработ
чиков App Engine и спросили их о том, что в первую очередь может
пригодиться системным администраторам. Они выделили следующие
задачи:
```
1. Выгрузка больших объемов данных: _[http://code.google.com/ap>](http://code.google.com/ap>)_
    _pengine/articles/bulkload.html_.
    Системным администраторам часто приходится перемещать огром
    ные объемы данных, и этот инструмент позволит решать эти про
    блемы в контексте приложений из Google App Engine.
2. Регистрация событий: _[http://code.google.com/appengine/articles/log>](http://code.google.com/appengine/articles/log>)_
    _ging.html_.
3. Интерфейс к электронной почте: функция send_mail_to_admin():
    _[http://code.google.com/appengine/docs/mail/functions.html](http://code.google.com/appengine/docs/mail/functions.html)_.
    C точки зрения системного администратора владение этим интер
    фейсом может оказаться полезным для организации мониторинга.
    В случае появления важных исключений или выполнения опера
    ций вы могли бы автоматически отправлять администраторам при
    ложений сообщения по электронной почте.
4. Выполнение периодических задач с помощью планировщика зада
    ний cron.
    Это не является непосредственной частью Google App Engine, но вы
    могли бы использовать планировщик заданий cron на своих серве
    рах для передачи запросов своим приложениям через определен
    ные интервалы времени. Например, можно было бы оформить зада
    ние для планировщика, согласно которому каждый час будет посы
    латься запрос по адресу _[http://yourapp.com/emailsummary](http://yourapp.com/emailsummary)_ , в ре
    зультате которого системному администратору будет высылаться
    сообщение электронной почты с описанием важных событий, про
    изошедших в течение последнего часа.
5. Управление версиями: _[http://code.google.com/appengine/docs/confi>](http://code.google.com/appengine/docs/confi>)_
    _guringa napp.html#Required_Elements_.
    Одно из обязательных полей, заполняемых для вашего приложе
    ния, – идентификатор версии. Каждый раз, когда выгружается
    приложение с тем же идентификатором версии, оно замещается но
    вым программным кодом. Изменяя идентификатор версии, вы по
    лучаете возможность иметь несколько версий приложения и с по
    мощью консоли администратора выбирать, какая из версий долж
    на быть включена в работу.

```
Создание примера приложения для Google App Engine
Прежде чем приступить к созданию приложения для Google App En
gine, вам потребуется загрузить пакет SDK для Google App Engine:
```

**304** Глава 8. Окрошка из операционных систем

```
http://code.google.com/appengine/downloads.html. Вы также можете
ознакомиться с замечательным учебным руководством по Google App
Engine: http://code.google.com/appengine/docs/gettingstarted/.
В этом разделе мы предлагаем обратное учебное руководство для Goo
gle App Engine, так как замечательное учебное руководство уже суще
ствует. Если вы перейдете по адресу http://greedycoin.appspot.com/ , то
сможете опробовать работающую версию приложения, которое описы
вается ниже, а также познакомиться с последней версией исходных
текстов. Приложение принимает сумму, введенную пользователем, со
храняет ее в базе данных и затем возвращает сумму в виде списка мо
нет определенного достоинства. Приложением также поддерживается
возможность регистрации посредством API аутентификации и возмож
ность получения информации о последних запросах. Исходный текст
приложения приводится в примере 8.13.
```
```
Пример 8.13. Веб>приложение Greedy Coin
#!/usr/bin/env python2.5
#Noah Gift
import decimal
import wsgiref.handlers
import os
```
```
from google.appengine.api import users
from google.appengine.ext import webapp
from google.appengine.ext import db
from google.appengine.ext.webapp import template
```
```
class ChangeModel(db.Model):
user = db.UserProperty()
input = db.IntegerProperty()
date = db.DateTimeProperty(auto_now_add=True)
```
```
class MainPage(webapp.RequestHandler):
"""Главная страница"""
```
```
def get(self):
user = users.get_current_user()
```
```
if users.get_current_user():
url = users.create_logout_url(self.request.uri)
url_linktext = 'Logout'
else:
url = users.create_login_url(self.request.uri)
url_linktext = 'Login'
```
```
template_values = {
'url': url,
'url_linktext': url_linktext,
}
path = os.path.join(os.path.dirname(__file__), 'index.html')
self.response.out.write(template.render(path, template_values))
```

Облачная обработка данных **305**

```
class Recent(webapp.RequestHandler):
"""Получение информации о 10 последних запросах"""
```
```
def get(self):
#коллекция
collection = []
#получить 10 последних записей из хранилища данных
query = ChangeModel.all().order('date')
records = query.fetch(limit=10)
```
```
#отформатировать дробные значения
for change in records:
collection.append(decimal.Decimal(change.input)/100)
template_values = {
'inputs': collection,
'records': records,
}
path = os.path.join(os.path.dirname(__file__), 'query.html')
self.response.out.write(template.render(path,template_values))
class Result(webapp.RequestHandler):
"""Возвращает страницу с результатами"""
def __init__(self):
self.coins = [1,5,10,25]
self.coin_lookup = {25: "quarters", 10: "dimes", 5: "nickels",
1: "pennies"}
def get(self):
#Просто получить последнее число
collection = {}
```
```
#выбрать последний ввод из хранилища данных
change = db.GqlQuery(
"SELECT * FROM ChangeModel ORDER BY date DESC LIMIT 1")
for c in change:
change_input = c.input
#логика размена суммы монетами
coin = self.coins.pop()
num, rem = divmod(change_input, coin)
if num:
collection[self.coin_lookup[coin]] = num
while rem > 0:
coin = self.coins.pop()
num, rem = divmod(rem, coin)
if num:
collection[self.coin_lookup[coin]] = num
template_values = {
'collection': collection,
'input': decimal.Decimal(change_input)/100,
}
```

**306** Глава 8. Окрошка из операционных систем

```
#шаблон отображения
path = os.path.join(os.path.dirname(__file__), 'result.html')
self.response.out.write(template.render(path, template_values))
class Change(webapp.RequestHandler):
```
```
def post(self):
"""метод вывода результатов"""
model = ChangeModel()
try:
change_input = decimal.Decimal(self.request.get('content'))
model.input = int(change_input*100)
model.put()
self.redirect('/result')
except decimal.InvalidOperation:
path = os.path.join(os.path.dirname(__file__),
'submit_error.html')
self.response.out.write(template.render(path,None))
```
```
def main():
application = webapp.WSGIApplication([('/', MainPage),
('/submit_form', Change),
('/result', Result),
('/recent', Recent)],
debug=True)
wsgiref.handlers.CGIHandler().run(application)
if __name__ == "__main__":
main()
```
```
Так как это обратное учебное руководство, начнем с рассмотрения вер
сии приложения, работающей по адресу http://greedycoin.appspot.com/ ,
или с вашей версии по адресу http://localhost:8080/. На главной стра
нице приложения на фоне цвета тыквы находятся две прямоугольные
области: область слева представляет собой форму, где вы можете вве
сти денежную сумму, а область справа содержит элементы навигации.
Эти приятные (или уродливые) цвета и схема размещения являются
комбинацией задействованного механизма шаблонов Django и CSS.
Шаблоны Django можно найти в главном каталоге, а используемые
CSS – в таблицах стилей. Механизм оформления не имеет никакого от
ношения к Google App Engine, поэтому за дополнительной информа
цией о механизме шаблонов Django мы просто отсылаем вас к руково
дству: http://www.djangoproject.com/documentation/templates/.
Теперь, когда мы познакомились с внешним видом приложения, да
вайте перейдем к изучению некоторых особенностей Google App En
gine. Обратите внимание на ссылку «Login» в правой области: она
обеспечивает возможность использовать прикладной интерфейс меха
низма аутентификации. Ниже показано, как это реализовано в про
граммном коде:
```

Облачная обработка данных **307**

```
class MainPage(webapp.RequestHandler):
"""Главная страница"""
```
```
def get(self):
user = users.get_current_user()
```
```
if users.get_current_user():
url = users.create_logout_url(self.request.uri)
url_linktext = 'Logout'
else:
url = users.create_login_url(self.request.uri)
url_linktext = 'Login'
```
```
template_values = {
'url': url,
'url_linktext': url_linktext,
}
path = os.path.join(os.path.dirname(__file__), 'index.html')
self.response.out.write(template.render(path, template_values))
```
```
Здесь представлен класс, наследующий свойства и методы класса
webapp.RequestHandler, и если вы определите метод get(), вы сможете
проверять, зарегистрировался ли пользователь. Если вы посмотрите на
несколько последних строк, то увидите, что информация о пользовате
ле помещается в шаблон, который затем используется механизмом
шаблонов Django для отображения страницы index.html. Это просто за
мечательно, что таким тривиальным способом можно задействовать
мощную базу учетных записей Google для обеспечения возможности
авторизации на страницах. В предыдущем фрагменте это взаимодейст
вие достигается всего двумя строчками:
```
```
user = users.get_current_user()
if users.get_current_user():
```
```
Здесь мы могли бы предложить вам поэкспериментировать с этим
фрагментом и попытаться изменить его так, чтобы приложение было
доступно только для зарегистрировавшихся пользователей. Для этого
вам даже не требуется понимать, как работает весь механизм, – доста
точно будет использовать уже имеющиеся условные инструкции.
Теперь, когда мы получили некоторое представление об аутентифика
ции, перейдем к вещам более сложным. Прикладной интерфейс к хра
нилищу данных позволяет сохранять данные и затем извлекать их в лю
бой части приложения. Для этого необходимо импортировать модуль
db, как показано в предыдущем примере, и определить модель:
```
```
class ChangeModel(db.Model):
user = db.UserProperty()
input = db.IntegerProperty()
date = db.DateTimeProperty(auto_now_add=True)
```

**308** Глава 8. Окрошка из операционных систем

```
С помощью этого простого класса мы можем создавать и использовать
хранимые данные. Ниже приводится класс, в котором используется
Python API для получения данных из хранилища и отображения 10 по
следних результатов:
```
```
class Recent(webapp.RequestHandler):
"""Получение информации о 10 последних запросах"""
```
```
def get(self):
#коллекция
collection = []
#получить 10 последних записей из хранилища данных
query = ChangeModel.all().order('date')
records = query.fetch(limit=10)
```
```
#отформатировать дробные значения
for change in records:
collection.append(decimal.Decimal(change.input)/100)
template_values = {
'inputs': collection,
'records': records,
}
path = os.path.join(os.path.dirname(__file__), 'query.html')
self.response.out.write(template.render(path,template_values))
```
```
Самые важные строки здесь:
```
```
query = ChangeModel.all().order('date')
records = query.fetch(limit=10)
```
```
Они выбирают результаты из хранилища данных и затем «извлекают»
(fetch) 10 последних записей в запросе. Здесь можно остановиться
и поэкспериментировать с этим фрагментов, попытавшись получить
большее число записей или отсортировать их в другом порядке. Это
должно дать вам прочувствовать взаимодействие с приложением.
Наконец, если внимательно посмотреть на фрагмент ниже, можно об
наружить, что каждому URL в списке соответствует свой класс, кото
рый определен в нашем файле change.py. Здесь мы могли бы пореко
мендовать вам поэкспериментировать с URL, изменяя соответствия
между ними и частями приложения – это должно дать представление
о том, как они задействуются.
def main():
application = webapp.WSGIApplication([('/', MainPage),
('/submit_form', Change),
('/result', Result),
('/recent', Recent)],
debug=True)
wsgiref.handlers.CGIHandler().run(application)
```

Использование Zenoss для управления серверами Windows из Linux **309**

```
На этом мы заканчиваем наше обратное учебное руководство по Google
App Engine, которое должно было дать вам некоторое представление
о том, как можно было бы реализовать собственный инструмент для
нужд системного администрирования. Если вам интересно будет озна
комиться с примерами других приложений, можете также познако
миться с исходными текстами приложения Google App Engine, напи
санного самим Гвидо ван Россумом (Guido van Rossum): http://code.
google.com/p/rietveld/source/browse.
```
**Использование Zenoss для управления**

**серверами Windows из Linux**

```
Если вы имеете несчастье заниматься администрированием одного
или нескольких серверов, работающих под управлением Windows, ва
ша работа может стать немного менее неприятной. В этом нам может
помочь такой удивительный инструмент, как Zenoss. Мы говорили
о Zenoss в главе 7 «SNMP». Помимо того, что он является инструмен
том SNMP, он к тому же обеспечивает возможность взаимодействовать
с серверами Windows через WMI (Windows Management Interface – ин
терфейс управления Windows) из Linux! Мы можем только посмеи
ваться и размышлять о практических применениях, полагаясь на эти
технологии. Из разговоров со специалистами проекта Zenoss мы выяс
нили, что они предлагают передавать сообщения WMI серверу Samba
(или CIFS) на машине, работающей под управлением Linux, и посы
лать их серверу Windows. И, пожалуй, самое интересное (по крайней
мере, для читателей этой книги) заключается в том, что имеется воз
можность организовать взаимодействие с соединением WMI из сцена
риев на языке Python.
```
```
Обсуждение синтаксиса и особенностей WMI выходит далеко за
рамки этой книги.
```
```
Существующая документация к Zenoss прекрасно освещает принципы
взаимодействия с WMI из Linux с помощью языка Python. Тем не ме
нее, примеры, которые мы собираемся представить вашему внима
нию, должны послужить хорошей основой для вашего дальнейшего
усовершенствования. Для начала рассмотрим применение инструмен
та wmic (не имеющего отношения к языку Python) для обеспечения
взаимодействия с сервером Windows через WMI из операционной сис
темы Linux. wmic – это простая утилита командной строки, которая
принимает в качестве аргументов командной строки имя пользовате
ля, пароль, адрес сервера и запрос WMI. Она выполняет подключение
к указанному серверу с заданными параметрами аутентификации, пе
редает запрос и отображает результаты на устройстве стандартного
```

**310** Глава 8. Окрошка из операционных систем

```
вывода. Синтаксис использования этой утилиты выглядит следую
щим образом:
```
```
wmicU username%password //SERVER_IP_ADDRESS_OR_HOSTNAME "some WMI query"
```
```
В следующем примере выполняется соединение с сервером, имеющим
IPадрес 192.168.1.3, с именем пользователя Administrator, и произво
дится запрос на получение записей из журнала событий:
```
```
wmicU Administrator%password //192.168.1.3 "SELECT * FROM Win32_NTLogEvent"
```
```
А ниже приводится часть результатов, полученных в ходе выполнения
этой команды:
CLASS: Win32_NTLogEvent
Category|CategoryString|ComputerName|Data|EventCode|EventIdentifier|
EventType|InsertionStrings|Logfile|Message|RecordNumber|SourceName|
TimeGenerated|TimeWritten|Type|User
...
|3|DCOM|20080320034341.000000+000|20080320034341.000000+000|Information|(null)
0|(null)|MACHINENAME|NULL|6005|2147489653|3|(,,,,14,0,0 )|System|The Event log
service was started.
|2|EventLog|20080320034341.000000+000|20080320034341.000000+000|Information|
(null)0|(null)|MACHINENAME|NULL|6009|2147489657|3|(5.02.,3790,Service Pack
2,Uniprocessor Free)|System|Microsoft (R) Windows (R) 5.02. 3790 Service Pack 2
Uniprocessor Free.
|1|EventLog|20080320034341.000000+000|20080320034341.000000+000|Information|
(null)
```
```
Чтобы выполнить аналогичный запрос из сценария на языке Python,
сначала необходимо настроить окружение. Для примеров, следующих
ниже, мы использовали комплекс Zenoss 2.1.3 VMware. В этом ком
плексе часть программного кода Zenoss располагается в домашнем ка
талоге пользователя zenoss. Самое сложное заключается в том, чтобы
добавить путь к каталогу, где находится модуль wmiclient.py, в пере
менную окружения PYTHONPATH. Мы добавили путь к каталогу в начало
уже существующей переменной PYTHONPATH, как показано ниже:
export PYTHONPATH=~/Products/ZenWin:$PYTHONPATH
```
```
Обеспечив возможность доступа к необходимым библиотекам, можно
попробовать запустить сценарий, исходный текст которого приводит
ся ниже:
#!/usr/bin/env python
```
```
from wmiclient import WMI
if __name__ == '__main__':
w = WMI('winserver', '192.168.1.3', 'Administrator', passwd='foo')
w.connect()
q = w.query('SELECT * FROM Win32_NTLogEvent')
for l in q:
```

Использование Zenoss для управления серверами Windows из Linux **311**

```
print "l.timewritten::", l.timewritten
print "l.message::", l.message
```
```
Вместо того чтобы выводить значения всех полей, как это сделано в при
мере с применением wmic, этот сценарий выводит только время и текст
сообщения из журнала. Данный сценарий соединяется с сервером
192.168.1.3 с привилегиями пользователя Administrator и с паролем foo.
Затем он выполняет запрос WMI 'SELECT * FROM Win32_NTLogEvent'. После
этого производится обход полученных результатов и вывод времени
и текста сообщения для каждой записи. Трудно придумать чтолибо
более простое, чем этот пример.
Ниже приводится часть вывода, полученного от этого сценария:
l.timewritten:: 20080320034359.000000+000
l.message:: While validating that \Device\Serial1 was really a serial port,
a fifo was detected. The fifo will be used.
```
```
l.timewritten:: 20080320034359.000000+000
l.message:: While validating that \Device\Serial0 was really a serial port,
a fifo was detected. The fifo will be used.
l.timewritten:: 20080320034341.000000+000
l.message:: The COM sub system is suppressing duplicate event log entries for
a duration of 86400 seconds. The suppression timeout can be controlled by
a REG_DWORD value named SuppressDuplicateDuration under the following registry
key: HKLM\Software\Microsoft\Ole\EventLog.
```
```
l.timewritten:: 20080320034341.000000+000
l.message:: The Event log service was started.
```
```
l.timewritten:: 20080320034341.000000+000
l.message:: Microsoft (R) Windows (R) 5.02. 3790 Service Pack 2 Uniprocessor
Free.
```
```
Но как мы узнали, что необходимо использовать атрибуты timewritten
и message? Чтобы найти эту информацию, потребовалось приложить
совсем немного усилий. Ниже приводится сценарий, который помога
ет отыскивать необходимые атрибуты:
#!/usr/bin/env python
```
```
from wmiclient import WMI
if __name__ == '__main__':
w = WMI('winserver', '192.168.1.3', 'Administrator', passwd='foo')
w.connect()
q = w.query('SELECT * FROM Win32_NTLogEvent')
for l in q:
print "result set fields::>", l.Properties_.set.keys()
break
```
```
Вы могли бы заметить, что этот сценарий очень похож на предыдущий
сценарий WMI. Между этими сценариями имеются два отличия – дан
ный сценарий вместо вывода значений времени и текста сообщения
```

**312** Глава 8. Окрошка из операционных систем

```
выводит результат метода l.Properties_.set.keys() и прерывает цикл
после вывода первого результата. Объект set, метод keys() которого мы
вызываем, в действительности является словарем. (Что сразу приобре
тает определенный смысл, потому что keys() является методом слова
ря.) Каждая запись в результатах, полученных по запросу WMI, долж
на иметь ряд атрибутов, имена которых соответствуют ключам этого
словаря. А теперь приведем результаты работы сценария, который мы
только что обсудили:
```
```
result set fields::> ['category', 'computername', 'categorystring',
'eventidentifier', 'timewritten', 'recordnumber', 'eventtype', 'eventcode',
'timegenerated', 'sourcename', 'insertionstrings', 'user', 'type',
'message',
'logfile', 'data']
```
```
Как видите, оба атрибута, timewritten и message, использованные нами
в первом сценарии WMI, присутствуют в списке ключей.
Мы не считаем себя большими поклонниками работы с операционной
системой Windows, но тем не менее, мы понимаем, что иногда для вы
полнения работы приходится использовать предопределенные техно
логии. Этот инструмент от Zenoss поможет сделать решение такого ро
да задач менее неприятным делом. К тому же этот инструмент облада
ет такими широкими возможностями, что позволяет выполнять за
просы WMI из Linux. Если вам приходится работать с операционной
системой Windows, то Zenoss с успехом может занять видное место
в вашем инструментарии.
```
