### Глава 14. Практические примеры

**Управление DNS с помощью сценариев**

**на языке Python**

Управление сервером DNS является достаточно простой задачей по
сравнению, например, с управлением конфигурационными файлами
вебсервера Apache. Программное внесение крупномасштабных изме
нений в DNS – вот настоящая проблема, способная сокрушать вычис
лительные центры и провайдеров вебхостинга. Оказывается, в соста
ве языка Python имеется модуль dnspython, который может вам приго
диться в решении подобных задач. Следует отметить, что существует
еще один модуль, имеющий отношение к DNS, – PyDNS, но мы будем
рассматривать только dnspython.

Обязательно ознакомьтесь с документацией, которую вы найдете на
сайте _[http://www.dnspython.org/](http://www.dnspython.org/)_. Кроме того, существует замечатель
ная статья об использовании модуля dnspython, которую вы найдете по
адресу _[http://vallista.idyll.org/~grig/articles/](http://vallista.idyll.org/~grig/articles/)_.

Чтобы начать использовать модуль dnspython, вам необходимо лишь
с помощью утилиты easy_install установить одноименный пакет из
каталога пакетов Python:

```
ngift@Macintosh8][H:10048][J:0]# sudo easy_install dnspython
Password:
Searching for dnspython
Reading http://pypi.python.org/simple/dnspython/
[дальнейший вывод обрезан]
```
Теперь попробуем исследовать модуль с помощью оболочки IPython
так же, как проверялись многие другие идеи в этой книге. В следую
щем примере мы извлекаем записи «A» и «MX» для имени _oreilly.com_ :


Управление DNS с помощью сценариев на языке Python **481**

```
In [1]: import dns.resolver
In [2]: ip = dns.resolver.query("oreilly.com","A")
In [3]: mail = dns.resolver.query("oreilly.com","MX")
In [4]: for i,p in ip,mail:
....: print i,p
....:
....:
208.201.239.37 208.201.239.36
20 smtp1.oreilly.com. 20 smtp2.oreilly.com.
```
```
В этом примере мы присваиваем значения записей «A» переменной ip,
а значения записей «MX» – переменной mail. Результаты, полученные
из записей «A», выведены в верхней строке, а результаты, полученные
из записей «MX», – в нижней. Теперь, когда мы получили некоторое
представление о том, как работает этот модуль, напишем сценарий,
который будет получать значения записей «A» для списка хостов.
```
```
Пример 14.1. Запрос информации для группы хостов
import dns.resolver
hosts = ["oreilly.com", "yahoo.com", "google.com", "microsoft.com", "cnn.com"]
```
```
def query(host_list=hosts):
collection = []
for host in host_list:
ip = dns.resolver.query(host,"A")
for i in ip:
collection.append(str(i))
return collection
if __name__ == "__main__":
for arec in query():
print arec
```
```
Если запустить этот сценарий, будут получены значения всех записей
«A» для указанных хостов, как показано ниже:
```
```
[ngift@Macintosh8][H:10046][J:0]# python query_dns.py
208.201.239.37
208.201.239.36
216.109.112.135
66.94.234.13
64.233.167.99
64.233.187.99
72.14.207.99
207.46.197.32
207.46.232.182
64.236.29.120
64.236.16.20
64.236.16.52
64.236.24.12
```

**482** Глава 14. Практические примеры

```
Одна очевидная проблема, которую можно решить подобным обра
зом, – программно проверить наличие корректных записей «A» для
всех хостов, имена которых присутствуют в файле.
Однако модуль dnspython способен на большее: с его помощью можно
управлять зонами DNS и выполнять более сложные запросы, чем опи
сано здесь. Если вам интересно будет рассмотреть дополнительные
примеры использования модуля, обращайтесь по адресу URL, указан
ному выше.
```
**Использование протокола LDAP для работы**

**с OpenLDAP, Active Directory и другими**

**продуктами из сценариев на языке Python**

```
LDAP – это новомодное словечко для большинства корпораций, а один
из авторов книги даже использовал базу данных LDAP для управле
ния своей домашней локальной сетью. Если вы не знакомы с LDAP,
скажем, что эта аббревиатура расшифровывается как Lightweight Di
rectory Access Protocol (облегченный протокол доступа к сетевому ка
талогу). Одно из самых удачных определений, с которыми нам прихо
дилось сталкиваться, приводится в Википедии: «прикладной прото
кол, позволяющий обращаться к службе каталогов, работающий по
верх протокола TCP/IP». В качестве примера одной из служб можно
назвать службу аутентификации, которая, безусловно, является од
ним из самых популярных применений этого протокола. Примерами
программных продуктов, поддерживающих протокол LDAP, могут
служить Open Directory, Open LDAP, Red Hat Directory Server и Active
Directory. Прикладной интерфейс pythonldap поддерживает взаимо
действие с двумя продуктами – OpenLDAP и Active Directory.
Прикладной интерфейс к LDAP в языке Python называется python
ldap и включает в себя поддержку объектноориентированной обертки
вокруг OpenLDAP 2.x. Существует также поддержка и других компо
нентов LDAP, включая средства обработки файлов LDIF и LDAPv3.
Прежде чем начать работу с этим протоколом, вам необходимо загру
зить пакет из проекта pythonldap, который находится на сайте source
forge по адресу: http://pythonldap.sourceforge.net/download.shtml.
После установки пакета pythonldap, возможно, вам потребуется сна
чала ознакомиться с библиотекой в оболочке IPython. Ниже приводит
ся протокол интерактивного сеанса, где сначала выполнена удачная
попытка подключиться к общедоступному серверу LDAP, а затем не
удачная попытка. Изучение особенностей установки и настройки
LDAP выходит далеко за рамки этой книги и, тем не менее, мы можем
начать тестировать прикладной интерфейс пакета pythonldap, ис
пользуя общедоступный сервер LDAP университета штата Мичиган.
```

Использование протокола LDAP **483**

```
In [1]: import ldap
In [2]: l = ldap.open("ldap.itd.umich.edu")
```
```
In [3]: l.simple_bind()
Out[3]: 1
```
```
Метод simple_bind() сообщает нам, что соединение выполнено успеш
но, но давайте попробуем выполнить неудачную попытку и посмот
рим, как это будет выглядеть:
In [5]: try:
....: l = ldap.open("127.0.0.1")
....: except Exception,err:
....: print err
....:
....:
In [6]: l.simple_bind()
```
```
SERVER_DOWN Traceback (most recent call last)
```
```
/root/<ipython console>
/usr/lib/python2.4/sitepackages/ldap/ldapobject.py in simple_bind(self, who,
cred, serverctrls, clientctrls)
167 simple_bind([who='' [,cred='']])> int
168 """
> 169 return self._ldap_call(self._l.simple_bind,who,cred,
EncodeControlTuples(serverctrls),EncodeControlTuples(clientctrls))
170
171 def simple_bind_s(self,who='',cred='',serverctrls=None,
clientctrls=None):
```
```
/usr/lib/python2.4/sitepackages/ldap/ldapobject.py in _ldap_call(self, func,
*args, **kwargs)
92 try:
93 try:
> 94 result = func(*args,**kwargs)
95 finally:
96 self._ldap_object_lock.release()
SERVER_DOWN: {'desc': "Can't contact LDAP server"}
```
```
Как видно из этого примера, наш программный код не нашел запу
щенный сервер LDAP и разразился ругательствами.
```
**Импортирование файла LDIF**

```
Простое подключение к общедоступному серверу LDAP не настолько
полезная операция, чтобы помочь нам в нашей работе. Ниже приво
дится пример выполнения асинхронного импорта LDIF:
```
```
import ldap
import ldap.modlist as modlist
```

**484** Глава 14. Практические примеры

```
ldif = "somefile.ldif"
def create():
l = ldap.initialize("ldaps://localhost:636/")
l.simple_bind_s("cn=manager,dc=example,dc=com","secret")
dn="cn=root,dc=example,dc=com"
rec = {}
rec['objectclass'] = ['top','organizationalRole','simpleSecurityObject']
rec['cn'] = 'root'
rec['userPassword'] = 'SecretHash'
rec['description'] = 'User object for replication using slurpd'
ldif = modlist.addModlist(attrs)
l.add_s(dn,ldif)
l.unbind_s()
```
```
В этом примере мы сначала инициализируем соединение с локальным
сервером LDAP, затем создаем объект, который будет служить проек
цией базы данных LDAP, и потребуется, когда мы будем выполнять
асинхронный импорт файла LDIF. Обратите внимание, что использо
вание метода l.add_s() указывает, что выполняется асинхронное обра
щение к прикладному интерфейсу.
Это лишь самые основы совместного использования LDAP и Python,
а за дополнительной информацией об использовании пакета python
ldap вам следует обращаться к ресурсу, указанному в начале этого раз
дела. Там, в частности, вы найдете примеры использования LDAPv3 –
Create, Read, Update, Delete (CRUD – создание, чтение, изменение
и удаление) и многие другие.
И последнее, о чем хотелось бы упомянуть: для языка Python сущест
вует инструмент с названием web2ldap, который реализует вебинтер
фейс к LDAP и разработан автором пакета pythonldap. Возможно,
у вас появится желание опробовать его наряду с другими альтернатив
ными решениями управления LDAP через вебинтерфейс. Перейдя по
адресу http://www.web2ldap.de/ , вы найдете официальную документа
цию к этому инструменту, которая очень подробно описывает под
держку LDAPv3.
```
### Составление отчета на основе файлов журналов Apache

**журналов Apache**

```
В настоящее время доля вебсервера Apache составляет примерно 50 про
центов от всех вебсерверов в Интернете. Цель следующего примера со
стоит в том, чтобы показать вам способ составления отчетов на основе
файлов журналов вебсервера Apache. В этом примере рассматривает
ся только часть информации, доступной в файлах журналов Apache,
но вы можете использовать описываемый подход для извлечения лю
бых данных, содержащихся в этих файлах журналов. Данный подход
можно легко адаптировать для работы с огромными файлами данных
и для работы с большим числом данных.
```

Составление отчета на основе файлов журналов Apache **485**

```
В главе 3 приводилось несколько примеров анализа файлов журналов
вебсервера Apache, из которых извлекалась некоторая информация.
В этом примере мы повторно воспользуемся модулями, написанными
для главы 3, чтобы продемонстрировать, как создавать удобочитаемые
отчеты из одного или более файлов журналов. Помимо обработки всех
файлов журналов, список которых определяется отдельно, вы можете
указать этому сценарию, что он должен объединить файлы журналов
и создать единый отчет. Исходный текст сценарий приводится в при
мере 14.2.
```
```
Пример 14.2. Объединенный отчет на основе файлов журналов
веб>сервера Apache
#!/usr/bin/env python
```
```
from optparse import OptionParser
def open_files(files):
for f in files:
yield (f, open(f))
```
```
def combine_lines(files):
for f, f_obj in files:
for line in f_obj:
yield line
```
```
def obfuscate_ipaddr(addr):
return ".".join(str((int(n) / 10) * 10) for n in addr.split('.'))
```
```
if __name__ == '__main__':
parser = OptionParser()
parser.add_option("c", "consolidate", dest="consolidate",
default=False,
action='store_true', help="consolidate log files")
parser.add_option("r", "regex", dest="regex", default=False,
action='store_true', help="use regex parser")
(options, args) = parser.parse_args()
logfiles = args
if options.regex:
from apache_log_parser_regex import generate_log_report
else:
from apache_log_parser_split import generate_log_report
opened_files = open_files(logfiles)
```
```
if options.consolidate:
opened_files = (('CONSOLIDATED', combine_lines(opened_files)),)
```
```
for filename, file_obj in opened_files:
print "*" * 60
print filename
print "" * 60
print "%20s%s" % ("IP ADDRESS", "BYTES TRANSFERRED")
```

**486** Глава 14. Практические примеры

```
print "" * 60
report_dict = generate_log_report(file_obj)
for ip_addr, bytes in report_dict.items():
print "%20s%s" % (obfuscate_ipaddr(ip_addr), sum(bytes))
print "=" * 60
```
```
В самом начале сценария определяются две функции: open_files()
иcombine_lines(). Позднее обе эти функции будут использоваться в ге
нераторах для упрощения программного кода. Функция open_files() –
это функциягенератор, которая принимает список (в действительно
сти – любой итерируемый объект) имен файлов. Для каждого имени
файла она создает кортеж из имени файла и соответствующего ему
объекта открытого файла. Функция combine_lines() принимает итери
руемые объекты открытых файлов в виде единственного аргумента.
Она выполняет обход объектов файлов в цикле for. Для каждого файла
выполняется обход строк в этом файле. И на каждой итерации она –
с помощью инструкции yield – возвращает очередную строку. Итери
руемый объект, получаемый от функции combine_lines(), можно срав
нить с файлом: мы можем выполнять обход строк в этом объекте.
Затем с помощью модуля optparse выполняется разбор аргументов ко
мандной строки, полученных от пользователя. Мы будем принимать
только два аргумента, оба – логического типа: признак объединения
файлов журналов и признак необходимости использовать библиотеку
регулярных выражений. Параметр consolidate сообщает сценарию,
что все файлы должны быть объединены при составлении отчета. Если
сценарию передается этот параметр, мы, в некотором смысле, выпол
няем конкатенацию содержимого файлов. Но к этому мы еще вернем
ся. Параметр regex сообщает сценарию, что вместо библиотеки «split»
следует использовать библиотеку регулярных выражений, которая
была написана нами в главе 3. Обе они предлагают идентичные функ
циональные возможности, но библиотека «split» работает быстрее.
Затем проверяется, был ли указан параметр regex. Если параметр был
указан, то импортируется модуль apache_log_parser_regex. В противном
случае используется модуль apache_log_parser_split. В действительно
сти мы включили этот параметр, чтобы сравнить производительность
двух библиотек. О производительности этого сценария мы поговорим
немного позже.
Затем вызывается функция open_files(), которой передается список
имен файлов, полученный от пользователя. Как мы уже упоминали,
функция open_files() – это функциягенератор, которая возвращает
объект файла для каждого имени во входном списке. Это означает, что
каждый файл открывается фактически, только когда функция возвра
щает соответствующий объект. Теперь, когда у нас имеется итерируе
мый объект с открытыми файлами, мы можем выполнять с ним неко
торые операции. Мы можем выполнить обход всех файлов и составить
отчет по каждому из них или объединить их некоторым способом и со
```

Составление отчета на основе файлов журналов Apache **487**

```
ставить объединенный отчет сразу по всем файлам. Это как раз то ме
сто, где на сцену выходит функция combine_lines(). Если пользователь
передал ключ «consolidate», то «список файлов», по которому будут
выполняться итерации, будет содержать единственный объект, подоб
ный файлу: генератор всех строк во всех файлах.
Далее, независимо от того, настоящие файлы содержатся в списке или
комбинированный файл, каждый из них передается соответствующей
функции generate_log_report(), которая возвращает словарь с IPадре
сами и количеством байтов, отправленных по этим адресам. Для каж
дого файла выводятся строкиразделители и отформатированные стро
ки с результатами работы функции generate_log_report(). Ниже приво
дится вывод, полученный в результате обработки одного файла журна
ла размером 28 Кбайт:
************************************************************
access.log
```
```
IP ADDRESS BYTES TRANSFERRED
```
```
190.40.10.0 17479
200.80.230.0 45346
200.40.90.110 8276
130.150.250.0 0
70.0.10.140 2115
70.180.0.220 76992
200.40.90.110 23860
190.20.250.190 499
190.20.250.210 431
60.210.40.20 27681
60.240.70.180 20976
70.0.20.120 1265
190.20.250.210 4268
190.50.200.210 4268
60.100.200.230 0
70.0.20.190 378
190.20.250.250 5936
============================================================
```
```
Вывод, полученный в результате обработки трех файлов журналов
(фактически это три копии одного и того же файла, созданные путем
многократного копирования данных из оригинального файла), выгля
дит, как показано ниже:
```
```
************************************************************
access.log
```
```
IP ADDRESS BYTES TRANSFERRED
```
```
190.40.10.0 17479
200.80.230.0 45346
```

**488** Глава 14. Практические примеры

```
<обрезано>
70.0.20.190 378
190.20.250.250 5936
============================================================
************************************************************
access_big.log
```
```
IP ADDRESS BYTES TRANSFERRED
```
```
190.40.10.0 1747900
200.80.230.0 4534600
<обрезано>
70.0.20.190 37800
190.20.250.250 593600
============================================================
************************************************************
access_bigger.log
```
```
IP ADDRESS BYTES TRANSFERRED
```
```
190.40.10.0 699160000
200.80.230.0 1813840000
<обрезано>
70.0.20.190 15120000
190.20.250.250 237440000
============================================================
```
```
А ниже приводится объединенный отчет для всех трех файлов:
************************************************************
CONSOLIDATED
```
```
IP ADDRESS BYTES TRANSFERRED
```
```
190.40.10.0 700925379
200.80.230.0 1818419946
<обрезано>
190.20.250.250 238039536
============================================================
```
```
Итак, какова же производительность этого сценария? И каково по
требление памяти? Все тесты, которые приводятся в этом разделе, вы
полнялись на сервере Ubuntu Gutsy, с процессором Athlon 64 X2
5400+ 2.8 ГГц, с объемом ОЗУ 2 Гбайта и с жестким диском Seagate
Barracuda 7200 RPM SATA. Размер файла журнала составлял пример
но 1 Гбайт:
jmjones@ezr:/data/logs$ lsl access*log
rwrr 1 jmjones jmjones 1157080000 20080418 12:46 access_bigger.log
```
```
Ниже приводятся результаты тестирования:
```
```
$ time python summarize_logfiles.pyregex access_bigger.log
```

Составление отчета на основе файлов журналов Apache **489**

```
************************************************************
access_bigger.log
```
```
IP ADDRESS BYTES TRANSFERRED
```
```
190.40.10.0 699160000
<обрезано>
190.20.250.250 237440000
============================================================
real 0m46.296s
user 0m45.547s
sys 0m0.744s
```
```
jmjones@ezr:/data/logs$ time python summarize_logfiles.py access_bigger.log
************************************************************
access_bigger.log
```
```
IP ADDRESS BYTES TRANSFERRED
```
```
190.40.10.0 699160000
<обрезано>
190.20.250.250 237440000
============================================================
real 0m34.261s
user 0m33.354s
sys 0m0.896s
```
```
При использовании библиотеки, выполняющей извлечение данных
с помощью регулярных выражений, на создание отчета ушло порядка
46 секунд. При использовании версии, использующей метод string.
split(), на создание отчета ушло 34 секунды. Но показатели потребле
ния памяти оказались плачевными. Объем занятой памяти достиг
130 Мбайт. Причина в том, что функция generate_log_report() сохра
няет список переданных байтов для каждого IPадреса в файле журна
ла. Поэтому, чем больше файл, тем больший объем памяти будет по
треблять этот сценарий. Но мы можем с этим коечто сделать. Ниже
приводится менее «жадная до памяти» версия библиотеки, выполняю
щей анализ файла журнала:
```
```
#!/usr/bin/env python
def dictify_logline(line):
'''возвращает словарь, содержащий информацию, извлеченную
из комбинированного файла журнала
```
```
В настоящее время нас интересуют только адреса удаленных хостов
и количество переданных байтов, но в качестве дополнительной меры
мы добавили выборку кода состояния.
'''
split_line = line.split()
return {'remote_host': split_line[0],
'status': split_line[8],
```

**490** Глава 14. Практические примеры

```
'bytes_sent': split_line[9],
}
```
```
def generate_log_report(logfile):
'''возвращает словарь в формате:
remote_host=>[список числа переданных байтов]
Эта функция принимает объект типа file, выполняет обход всех строк
в файле и создает отчет о количестве байтов, переданных
при каждом обращении удаленного хоста к вебсерверу.
'''
report_dict = {}
for line in logfile:
line_dict = dictify_logline(line)
host = line_dict['remote_host']
#print line_dict
try:
bytes_sent = int(line_dict['bytes_sent'])
except ValueError:
##полностью игнорировать непонятные нам ошибки
continue
report_dict[host] = report_dict.setdefault(host, 0) + bytes_sent
return report_dict
```
```
Теперь подсчет общего числа переданных байтов ведется по мере из
влечения значений, а не в вызывающей функции. Ниже приводится
несколько измененная версия сценария summarize_logfiles с новым па
раметром, позволяющим импортировать библиотеку с пониженным
потреблением памяти:
```
```
#!/usr/bin/env python
from optparse import OptionParser
```
```
def open_files(files):
for f in files:
yield (f, open(f))
def combine_lines(files):
for f, f_obj in files:
for line in f_obj:
yield line
def obfuscate_ipaddr(addr):
return ".".join(str((int(n) / 10) * 10) for n in addr.split('.'))
if __name__ == '__main__':
parser = OptionParser()
parser.add_option("c", "consolidate", dest="consolidate",
default=False,
action='store_true', help="consolidate log files")
parser.add_option("r", "regex", dest="regex", default=False,
action='store_true', help="use regex parser")
parser.add_option("m", "mem", dest="mem", default=False,
```

Составление отчета на основе файлов журналов Apache **491**

```
action='store_true', help="use mem parser")
(options, args) = parser.parse_args()
logfiles = args
if options.regex:
from apache_log_parser_regex import generate_log_report
elif options.mem:
from apache_log_parser_split_mem import generate_log_report
else:
from apache_log_parser_split import generate_log_report
opened_files = open_files(logfiles)
```
```
if options.consolidate:
opened_files = (('CONSOLIDATED', combine_lines(opened_files)),)
```
```
for filename, file_obj in opened_files:
print "*" * 60
print filename
print "" * 60
print "%20s%s" % ("IP ADDRESS", "BYTES TRANSFERRED")
print "" * 60
report_dict = generate_log_report(file_obj)
for ip_addr, bytes in report_dict.items():
if options.mem:
print "%20s%s" % (obfuscate_ipaddr(ip_addr), bytes)
else:
print "%20s%s" % (obfuscate_ipaddr(ip_addr), sum(bytes))
print "=" * 60
```
```
Эти изменения привели к тому, что сценарий стал выполняться не
много быстрее, чем версия с большим потреблением памяти:
jmjones@ezr:/data/logs$ time ./summarize_logfiles_mem.pymem
access_bigger.log
************************************************************
access_bigger.log
```
```
IP ADDRESS BYTES TRANSFERRED
```
```
190.40.10.0 699160000
<snip>
190.20.250.250 237440000
============================================================
real 0m30.508s
user 0m29.866s
sys 0m0.636s
```
```
На протяжении работы этого сценария потребление памяти составило
порядка 4 Мбайт. Этот сценарий способен обрабатывать 2 Гбайтные
файлы журналов за одну минуту. Теоретически размеры файлов могут
быть неопределенно большого размера, и это не будет приводить к су
щественному увеличению объемов потребляемой памяти, как в предыдущей версии. Однако, поскольку для хранения данных используется
словарь, каждый ключ которого – это уникальный IPадрес, потребле
ние памяти будет расти с увеличением числа уникальных IPадресов.
Если объем потребляемой памяти станет слишком велик, вы могли бы
заменить словарь какимнибудь хранилищем данных, или даже реля
ционной базой данных, такой как Berkeley DB.
```
### Зеркало FTP.

```
Следующий пример показывает, как соединяться с сервером FTP и ре
курсивно получать все файлы с этого сервера, начиная с некоторого
каталога, определяемого пользователем. Кроме того, этот сценарий
позволяет удалять файлы после того, как они были получены. Вы мо
жете задаться вопросом: «Зачем нужен такой сценарий? Разве все это
нельзя сделать с помощью rsync?». Ответ на него: «Да, это так». Одна
ко как быть, если утилита rsync отсутствует на сервере, где вы работае
те, и у вас недостаточно прав, чтобы установить ее? (Это необычно для
системного администратора, но такое тоже бывает.) Или как быть, ес
ли у вас нет доступа к серверу, откуда вы пытаетесь получить файлы,
через SSH или rsync? В таких ситуациях данный сценарий будет слу
жить альтернативой. Исходный текст сценария зеркалирования при
водится ниже:
```
```
#!/usr/bin/env python
import ftplib
import os
class FTPSync(object):
def __init__(self, host, username, password, ftp_base_dir,
local_base_dir, delete=False):
```
```
self.host = host
self.username = username
self.password = password
self.ftp_base_dir = ftp_base_dir
self.local_base_dir = local_base_dir
self.delete = delete
```
```
self.conn = ftplib.FTP(host, username, password)
self.conn.cwd(ftp_base_dir)
try:
os.makedirs(local_base_dir)
except OSError:
pass
os.chdir(local_base_dir)
```
```
def get_dirs_files(self):
dir_res = []
self.conn.dir('.', dir_res.append)
files = [f.split(None, 8)[1] for f in dir_res if f.startswith('')]
```

Зеркало FTP **493**

```
dirs = [f.split(None, 8)[1] for f in dir_res if f.startswith('d')]
return (files, dirs)
```
```
def walk(self, next_dir):
print "Walking to", next_dir
self.conn.cwd(next_dir)
try:
os.mkdir(next_dir)
except OSError:
pass
os.chdir(next_dir)
```
```
ftp_curr_dir = self.conn.pwd()
local_curr_dir = os.getcwd()
```
```
files, dirs = self.get_dirs_files()
print "FILES:", files
print "DIRS:", dirs
for f in files:
print next_dir, ':', f
outf = open(f, 'wb')
try:
self.conn.retrbinary('RETR %s' % f, outf.write)
finally:
outf.close()
if self.delete:
print "Deleting", f
self.conn.delete(f)
for d in dirs:
os.chdir(local_curr_dir)
self.conn.cwd(ftp_curr_dir)
self.walk(d)
def run(self):
self.walk('.')
if __name__ == '__main__':
from optparse import OptionParser
parser = OptionParser()
parser.add_option("o", "host", dest="host",
action='store', help="FTP host")
parser.add_option("u", "username", dest="username",
action='store', help="FTP username")
parser.add_option("p", "password", dest="password",
action='store', help="FTP password")
parser.add_option("r", "remote_dir", dest="remote_dir",
action='store', help="FTP remote starting directory")
parser.add_option("l", "local_dir", dest="local_dir",
action='store', help="Local starting directory")
parser.add_option("d", "delete", dest="delete", default=False,
action='store_true', help="use regex parser")
```
```
(options, args) = parser.parse_args()
f = FTPSync(options.host, options.username, options.password,
options.remote_dir, options.local_dir, options.delete)
f.run()
```
```
Этот сценарий выглядит проще с использованием класса. Конструктор
класса принимает несколько параметров. Чтобы соединиться с серве
ром, конструктору необходимо передать имя удаленного хоста (host),
имя пользователя (username) и пароль (password). Параметры ftp_ba
se_dir и local_base_dir передаются, чтобы переместиться в требуемые
каталоги на стороне сервера и на стороне локального компьютера. Па
раметр delete – это обычный флаг, который указывает, требуется ли
удалять файлы на удаленном сервере после их загрузки. В определе
нии конструктора видно, что этому параметру по умолчанию присваи
вается значение False.
После установки этих значений в виде атрибутов объекта выполняется
соединение с указанным сервером FTP и производится регистрация.
Затем осуществляется переход в начальный каталог на стороне серве
ра и в начальный каталог на локальном компьютере. Прежде чем вы
полнить переход в требуемый каталог на локальном компьютере, сце
нарий сначала пытается создать его. Если каталог уже существует, бу
дет получено исключение OSError, которое игнорируется сценарием.
В классе определяются три дополнительных метода: get_dirs_files(),
walk() и run(). Метод get_dirs_files() определяет, какие файлы нахо
дятся в текущем каталоге и какие из них являются обычными файла
ми, а какие каталогами. (К слову сказать, такой способ будет работать
только в случае сервера, работающего под управлением UNIX.) Опре
деление, какие из файлов являются обычными файлами, а какие ката
логами, производится по первому символу в строках полученного спи
ска. Если первый символ d, значит, – это каталог. Если первый символ
‘–’, значит, – это файл. Благодаря этому сценарий не будет следовать
за символическими ссылками или заниматься обработкой блочных
устройств.
Следующий метод, который определен в классе, – это метод walk().
В этом методе выполняется вся основная работа. Метод walk() прини
мает единственный параметр: следующий каталог, который требуется
посетить. Прежде чем двинуться дальше, напомним, что это рекурсив
ная функция. Она будет вызывать саму себя. Если какойлибо каталог
содержит другие каталоги, метод walk() также обойдет их. Метод
walk() сначала переходит в указанный каталог на стороне сервера. За
тем выполняется переход в одноименный каталог на локальном ком
пьютере, при этом, в случае необходимости, каталог создается. Потом
текущая позиция на сервере FTP и на локальном компьютере сохраня
ется в переменных ftp_curr_dir и local_curr_dir для последующего ис
пользования. Далее с помощью метода get_dirs_files(), о котором уже
говорилось выше, производится получение списков файлов и катало
гов. Загрузка каждого файла в каталоге производится с помощью ме
тода FTP retrbinary(). Кроме того, если был установлен флаг delete,
выполняется удаление файла. Затем выполняется переход в текущие
каталоги на стороне сервера FTP и на локальном компьютере и вызы
вается метод walk() для обхода нижележащих каталогов. Переход в те
кущие каталоги выполняется для того, чтобы при возвращении из ре
курсивных вызовов метода walk() мы оказались в том же самом месте,
где и были.
Последний метод, который определен в классе, – это метод run(). Ме
тод run() создан исключительно для удобства. Он просто вызывает ме
тод walk() и передает ему текущий каталог FTP.
В сценарии предусмотрена только самая необходимая обработка оши
бок и исключительных ситуаций. Вопервых, сценарий не проверяет
правильность аргументов командной строки и поэтому пользователь
должен обеспечить передачу, по крайней мере, трех параметров – име
ни удаленного хоста, имени пользователя и пароля. Если какойлибо
из этих параметров будет отсутствовать, сценарий очень быстро завер
шится с сообщением об ошибке. Кроме того, если произошло исключе
ние, сценарий не повторяет попытку загрузить файл. То есть, если
чтото будет препятствовать загрузке файла, мы получим исключение,
и работа программы на этом завершится. Если сценарий завершит ра
боту на полпути, во время загрузки файлов, то при следующем запуске
сценарий повторно загрузит файлы, которые уже были загружены.
В такой реализации есть свой плюс, который состоит в том, что если
файл был загружен только частично, он не будет удален на стороне
сервера.
```

### Приложение

### Приложение. Функции обратного вызова

Концепция функций обратного вызова и передачи функций в виде па
раметров может оказаться вам незнакомой. Если это так, то вам опре
деленно стоит углубиться в ее изучение, чтобы понять ее достаточно
хорошо для применения на практике или, по крайней мере, настоль
ко, чтобы понимать, что происходит в сценарии, когда вы будете
встречать ее. В языке Python функции являются «обычными» объек
тами, то есть вы можете передавать их и обращаться с ними как с объ
ектами, потому что они действительно являются объектами. Рассмот
рим пример 1.

_Пример 1. Функции – типичные объекты_

```
In [1]: def foo():
...: print foo
...:
...:
```
```
In [2]: foo
Out[2]: <function foo at 0x1233270>
```
```
In [3]: type(foo)
Out[3]: <type 'function'>
```
```
In [4]: dir(foo)
Out[4]:
['__call__',
'__class__',
'__delattr__',
'__dict__',
'__doc__',
'__get__',
'__getattribute__',
'__hash__',
'__init__',
'__module__',
'__name__',
'__new__',
'__reduce__',
'__reduce_ex__',
'__repr__',
'__setattr__',
'__str__',
'func_closure',
'func_code',
'func_defaults',
'func_dict',
'func_doc',
'func_globals',
'func_name']
```
```
Простое обращение к функции, такой как foo из предыдущего приме
ра, не приводит к ее вызову. Ссылаясь на имя функции, можно полу
чать значения любых атрибутов функции, которые она имеет, и даже
обращаться к функции по другому имени, как показано в примере 2.
```
```
Пример 2. Обращение к функции по имени
In [1]: def foo():
...: """это строка документирования"""
...: print "IN FUNCTION FOO"
...:
...:
In [2]: foo
Out[2]: <function foo at 0x8319534>
In [3]: foo.__doc__
Out[3]: 'this is a docstring'
```
```
In [4]: bar = foo
In [5]: bar
Out[5]: <function foo at 0x8319534>
```
```
In [6]: bar.__doc__
Out[6]: 'this is a docstring'
In [7]: foo.a = 1
```
```
In [8]: bar.a
Out[8]: 1
In [9]: foo()
IN FUNCTION FOO
```
```
In [10]: bar()
IN FUNCTION FOO
```

Здесь была создана новая функция foo, так чтобы она содержала стро
ку документирования. После этого мы заявили, что переменная bar бу
дет указывать на только что созданную функцию foo. В языке Python
то, что вы привыкли считать переменными, в действительности явля
ется просто именами, указывающими (или ссылающимися) на некото
рые объекты. Процесс присваивания имени объекту называется «свя
зыванием имени». Поэтому, когда мы создали функцию foo, на самом
деле мы создали объект функции, а затем связали его с именем foo.
Воспользовавшись интерактивной оболочкой IPython, чтобы получить
основную информацию об имени foo, мы получили сообщение о том,
что это функция foo. Интересно то, что оболочка сказала то же самое
и об имени bar, а именно, что это функция foo. Мы установили значе
ние атрибута функции foo и сумели обратиться к нему с помощью име
ни bar. А вызов по именам foo и bar дал одинаковые результаты.
Одно из мест в этой книге, где мы используем функции обратного вы
зова, – это глава 5 «Сети». Передача функций в качестве параметров,
как это сделано в указанной главе в примере, демонстрирующем ис
пользование модуля ftplib, обеспечивает высокий динамизм во время
выполнения и гибкость во время разработки и может даже расширять
возможности повторной используемости программного кода. Даже ес
ли вы полагаете, что вам никогда не придется использовать функции
обратного вызова, сама перестройка процесса мышления при добавле
нии этих знаний к вашему мыслительному арсеналу представляет
большую ценность.
```
