## Глава 11. Создание графического интерфейса

```
Когда информированные люди перечисляют обязанности системного
администратора, разработка программ с графическим интерфейсом
пользователя (ГИП) обычно не входит в их число. Тем не менее, быва
ют моменты, когда администратору просто необходимо создать прило
жение с графическим интерфейсом или создание такого приложения
сможет существенно облегчить ему жизнь. Здесь мы рассматриваем
идею графического интерфейса в широком смысле, подразумевая как
традиционные приложения – с графическим интерфейсом на базе та
ких библиотек, как GTK или Qt, так и приложения с вебинтерфейсом.
В этой главе все наше внимание будет сосредоточено на использовании
библиотек PyGTK, curses и вебплатформы Django. Для начала мы
рассмотрим основы создания графического интерфейса, затем перей
дем к исследованию очень простого приложения, использующего биб
лиотеку PyGTK, а потом напишем то же самое приложение с использо
ванием curses и Django. Наконец, разберем, как с помощью Django
и небольшого объема программного кода можно написать приложение
для работы с базой данных, имеющее привлекательный интерфейс.
```
**Теория создания графического интерфейса**

Когда создается консольная утилита, предполагается, что она будет вы
полнять все необходимые действия без вмешательства пользователя.
Такое положение дел имеет место, когда сценарии запускаются с помо
щью таких планировщиков заданий, как cron и at. Но когда создается
утилита с графическим интерфейсом, предполагается, что пользова
тель должен будет чтото вводить, чтобы эта утилита могла выполнить
свою работу. Вспомните свой опыт работы с графическими приложе
ниями, такими как вебброузеры, клиенты электронной почты и тек
стовые процессоры. Вы _запускаете_ приложение некоторым способом.

Приложение выполняет некоторые действия по инициализации, воз
можно, загружает какиенибудь конфигурационные файлы и перево
дит себя в некоторое определенное состояние. Но после этого приложе
ние просто ждет, пока пользователь сделает чтонибудь. Конечно, су
ществуют примеры приложений, выполняющих некоторые действия
самостоятельно, как, например, Firefox автоматически проверяет на
личие обновлений без явного требования или согласия пользователя,
но это уже другая история.
Чего ожидает приложение? Как оно узнает, что делать, когда пользо
ватель предпримет какоелибо действие? Приложение ожидает, пока
произойдет событие. Событие – это то, что происходит в пределах при
ложения с одним из визуальных элементов управления, например на
жатие кнопки или выбор флажка. И приложение «знает», что делать,
когда происходят такие события, потому что программист связывает
определенные события с определенными фрагментами программного
кода. «Фрагменты программного кода», связанные с определенными
событиями, называют обработчиками событий. Одно из предназначе
ний библиотек, на базе которых создается графический интерфейс, за
ключается в том, чтобы вызвать правильный обработчик события, ко
гда происходит некоторое событие. Если быть более точным, библиоте
ка графического интерфейса реализует «цикл событий», в пределах
которого выполняется проверка поступления новых событий, и, когда
события происходят, обрабатывает их соответствующим способом.
Поведение приложения управляется событиями. Когда вы пишете
приложение с графическим интерфейсом, вы сами решаете, как при
ложение должно реагировать на те или иные действия пользователя.
Вы создаете обработчики событий, которые будут вызываться библио
текой графического интерфейса при возбуждении событий пользова
телем.
Это описание соответствует приложениям, а как сформировать сам ин
терфейс? То есть как создавать кнопки, текстовые поля ввода, метки
и флажки в приложении? Ответ на этот вопрос зависит от используе
мого инструментария. Графический интерфейс можно создать с помо
щью специальной программыпостроителя графического интерфейса,
входящей в состав выбранной вами библиотеки. Построитель графиче
ского интерфейса позволяет разместить в форме будущего приложе
ния различные визуальные компоненты, такие как кнопки, метки,
флажки и другие. Например, если вы работаете в операционной систе
ме Mac OS X и выбрали в качестве основы библиотеку Cocoa, то для раз
мещения графических компонентов можно воспользоваться програм
мой Interface Builder. Или, если вы выбрали PyGTK в Linux, можно
воспользоваться программой Glade. Или, если вы выбрали PyQt, мож
но прибегнуть к помощи программы Qt Designer.
Построители графического интерфейса удобны в использовании, но
иногда у вас может появиться желание иметь более полный контроль
```

**392** Глава 11. Создание графического интерфейса

```
над графическим интерфейсом, чем может предложить программапо
строитель. В таких случаях будет совсем несложно создать графический
интерфейс «вручную», написав немного программного кода. В библио
теке PyGTK каждому типу графических элементов соответствует свой
класс на языке Python. Например, окно – это объект класса gtk.Window.
Кнопка – это объект класса gtk.Button. Чтобы создать простое прило
жение с графическим интерфесом, которое имеет окно и кнопку, вы
создаете экземпляры классов gtk.Window и gtk.Button и добавляете
кнопку в окно. Если необходимо, чтобы по щелчку на кнопке выпол
нялись некоторые действия, вы должны определить обработчик собы
тия «щелчка» на кнопке.
```
**Создание простого приложения PyGTK**

```
Мы создадим простой сценарий, использующий уже упоминавшиеся
классы gtk.Window и gtk.Button. Ниже приводится исходный текст про
стого приложения с графическим интерфейсом, которое не делает ни
чего полезного, но демонстрирует некоторые основные принципы соз
дания программ с графическим интерфейсом.
Прежде чем можно будет опробовать этот пример или написать свое
собственное приложение на базе библиотеки PyGTK, вам необходимо
установить ее. В современных дистрибутивах Linux установка выпол
няется достаточно просто. Она выполняется просто даже для Windows.
Если вы пользуетесь дистрибутивом Ubuntu, эта библиотека должна
быть уже установлена. Если для вашей платформы нет готового двоич
ного дистрибутива, то установка может оказаться достаточно слож
ной. Исходный текст приложения приводится в примере 11.1.
```
```
Пример 11.1. Простое приложение PyGTK с одним окном и с одной кнопкой
#!/usr/bin/env python
import pygtk
import gtk
import time
```
```
class SimpleButtonApp(object):
"""Это простое приложение PyGTK с одним окном и с одной кнопкой.
После щелчка на кнопке на ней отображается текущее время.
"""
```
```
def __init__(self):
#Главное окно приложения
self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
#Так "регистрируется" обработчик события. Этот вызов
#предписывает главному циклу gtk вызвать self.quit(),
#когда окно "посылает" сигнал "destroy".
self.window.connect("destroy", self.quit)
```

Создание простого приложения PyGTK **393**

```
#Надпись на кнопке "Click Me"
self.button = gtk.Button("Click Me")
```
```
#Регистрация другого обработчика события. На этот раз, когда
#кнопка "посылает" сигнал "clicked", будет вызываться метод
#'update_button_label'.
self.button.connect("clicked", self.update_button_label, None)
```
```
#Окно – это контейнер. Метод "add" вставляет кнопку в окно.
self.window.add(self.button)
```
```
#Этот вызов делает кнопку видимой, но она не станет видимой,
#пока не станет видимым содержащий ее контейнер.
self.button.show()
#Сделать контейнер видимым
self.window.show()
def update_button_label(self, widget, data=None):
"""Помещает на кнопку надпись с текущим временем
Это обработчик события 'clicked' кнопки
"""
self.button.set_label(time.asctime())
```
```
def quit(self, widget, data=None):
"""Останавливает главный цикл событий gtk
Когда пользователь закрывает окно, оно исчезнет, но,
если не остановить главный цикл событий gtk, приложение
продолжит работу, хотя все будет выглядеть так, как будто
ничего не происходит
"""
gtk.main_quit()
```
```
def main(self):
"""Запуск главного цикла событий gtk"""
gtk.main()
if __name__ == "__main__":
s = SimpleButtonApp()
s.main()
```
```
Самое первое, на что вы наверняка обратили внимание в этом приме
ре, это то, что главный класс приложения наследует класс object, а не
какойнибудь класс GTK. Приложение с графическим интерфейсом на
базе PyGTK не обязательно должно быть реализовано в объектноори
ентированном стиле. Безусловно, вам придется создавать экземпляры
классов, но вы не обязаны создавать собственные классы. Однако для
чегото большего, чем тривиальный пример, такой как этот, мы на
стоятельно рекомендуем создавать собственные классы. Главное пре
имущество такого подхода к созданию приложений с графическим ин
терфейсом заключается в том, что все визуальные компоненты (окна,
кнопки, флажки) будут прикреплены к одному и тому же объекту, что
обеспечит прямой доступ к ним из любой части приложения.
```

**394** Глава 11. Создание графического интерфейса

```
Т. к. мы предпочли создать свой собственный класс, то сразу же нач
нем с того, что происходит в конструкторе (метод __init__()). Фактиче
ски, почти все, что делает это приложение, сосредоточено в конструк
торе. Этот пример содержит подробные комментарии, поэтому мы не
будем дублировать все пояснения здесь, а отметим наиболее важные
моменты. В конструкторе создаются два объекта графического интер
фейса: gtk.Window и gtk.Button. Затем кнопка помещается в окно, так
как окно – это контейнерный объект. Мы также создали обработчики
событий destroy и clicked, порождаемых окном и кнопкой соответст
венно. После запуска приложения на экране появляется окно с кноп
кой, имеющей надпись «Click Me» (щелкни здесь). Каждый раз, когда
производится щелчок на кнопке, надпись на кнопке обновляется и ото
бражает текущее время. На рис. 11.1 и 11.2 приводится внешний вид
приложения до и после щелчка на кнопке.
```
**Создание приложения PyGTK для просмотра**

**файла журнала вебсервера Apache**

```
Теперь, когда мы рассмотрели основы создания графического интер
фейса в общем и с использованием PyGTK, перейдем к примеру, кото
рый с помощью PyGTK реализует нечто более полезное – рассмотрим
создание приложения для просмотра содержимого файла журнала
вебсервера Apache. Это приложение будет обладать следующими
функциональными возможностями:
```
**-** Позволит выбирать и открывать требуемый файл журнала
**-** Будет отображать номер строки, имя удаленного хоста, код состоя
    ния и количество переданных байтов
**-** Позволит сортировать строки по их номерам, по именам удаленных
    хостов, коду состояния или количеству переданных байтов

```
Рис. 11.1. Простое приложение PyGTK – до щелчка на кнопке
```
```
Рис. 11.2. Простое приложение PyGTK – после щелчка на кнопке
```

Создание приложения PyGTK для просмотра файла журнала Apache **395**

```
Этот пример основан на программном коде, выполняющем анализ фай
ла журнала Apache, который мы написали в главе 3. Исходный текст
приложения приводится в примере 11.2.
```
```
Пример 11.2. Приложение PyGTK для просмотра файла журнала
веб>сервера Apache
#!/usr/bin/env python
import gtk
from apache_log_parser_regex import dictify_logline
class ApacheLogViewer(object):
"""Программа просмотра файла журнала вебсервера Apache, которая
позволяет сортировать информацию по разным полям данных"""
def __init__(self):
#Главное окно приложения
self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
self.window.set_size_request(640, 480)
self.window.maximize()
```
```
#Остановить цикл событий при закрытии окна
self.window.connect("destroy", self.quit)
```
```
#VBox – это контейнер, позволяющий добавлять в него визуальные
#компоненты. Используется в первую очередь для обеспечения
#определенного порядка расположения компонентов
self.outer_vbox = gtk.VBox()
```
```
#Панель инструментов с кнопками открытия журнала
#и завершения приложения
self.toolbar = gtk.Toolbar()
#Создать кнопки открытия файла и завершения приложения
#и пиктограммы добавить кнопки на панель инструментов
#связать кнопки с соответствующими обработчиками событий
open_icon = gtk.Image()
quit_icon = gtk.Image()
open_icon.set_from_stock(gtk.STOCK_OPEN, gtk.ICON_SIZE_LARGE_TOOLBAR)
quit_icon.set_from_stock(gtk.STOCK_QUIT, gtk.ICON_SIZE_LARGE_TOOLBAR)
self.open_button = gtk.ToolButton(icon_widget=open_icon)
self.quit_button = gtk.ToolButton(icon_widget=quit_icon)
self.open_button.connect("clicked", self.show_file_chooser)
self.quit_button.connect("clicked", self.quit)
self.toolbar.insert(self.open_button, 0)
self.toolbar.insert(self.quit_button, 1)
```
```
#Элемент управления для выбора открываемого файла
self.file_chooser = gtk.FileChooserWidget()
self.file_chooser.connect("file_activated", self.load_logfile)
#ListStore используется для представления данных, имеющих вид
#списка. Элемент ListStore будет хранить табличные данные в виде:
#номер_строки, имя_хоста, статус, переданные_байты, текст_записи
self.loglines_store = gtk.ListStore(int, str, str, int, str)
```

**396** Глава 11. Создание графического интерфейса

```
#связать дерево с данными...
self.loglines_tree = gtk.TreeView(model=self.loglines_store)
#...и добавить надписи в заголовки колонок
self.add_column(self.loglines_tree, 'Line Number', 0)
self.add_column(self.loglines_tree, 'Remote Host', 1)
self.add_column(self.loglines_tree, 'Status', 2)
self.add_column(self.loglines_tree, 'Bytes Sent', 3)
self.add_column(self.loglines_tree, 'Logline', 4)
#определить прокручиваемую область для отображения файла журнала
self.loglines_window = gtk.ScrolledWindow()
#объединить все вместе
self.window.add(self.outer_vbox)
self.outer_vbox.pack_start(self.toolbar, False, False)
self.outer_vbox.pack_start(self.file_chooser)
self.outer_vbox.pack_start(self.loglines_window)
self.loglines_window.add(self.loglines_tree)
#сделать элементы видимыми
self.window.show_all()
```
```
#при этом элемент выбора файла должен оставаться невидимым
self.file_chooser.hide()
```
```
def add_column(self, tree_view, title, columnId, sortable=True):
column = gtk.TreeViewColumn(title, gtk.CellRendererText() ,
text=columnId)
column.set_resizable(True)
column.set_sort_column_id(columnId)
tree_view.append_column(column)
```
```
def show_file_chooser(self, widget, data=None):
"""делает видимым диалог выбора файла"""
self.file_chooser.show()
def load_logfile(self, widget, data=None):
"""загружает данные в визуальный компонент"""
filename = widget.get_filename()
print "FILE>", filename
self.file_chooser.hide()
self.loglines_store.clear()
logfile = open(filename, 'r')
for i, line in enumerate(logfile):
line_dict = dictify_logline(line)
self.loglines_store.append([i + 1, line_dict['remote_host'],
line_dict['status'], int(line_dict['bytes_sent']), line])
logfile.close()
def quit(self, widget, data=None):
"""останавливает главный цикл событий gtk"""
gtk.main_quit()
```
```
def main(self):
"""запускает главный цикл событий gtk"""
```

Создание приложения PyGTK для просмотра файла журнала Apache **397**

```
gtk.main()
if __name__ == "__main__":
l = ApacheLogViewer()
l.main()
```
```
В примере приложения просмотра файла журнала вебсервера Apache
главный класс приложения называется ApacheLogViewer и наследует
класс object. В нашем главном объекте нет ничего особенного, он про
сто объединяет в себе все части графического интерфейса.
Далее в методе __init__() создается объект окна. В этом примере данная
операция отличается от аналогичной операции в предыдущем, «про
стом», примере тем, что здесь указаны размеры окна. Мы сначала ука
зываем, что окно должно иметь размеры 640×480, а затем предписыва
ем максимизировать его. Такая двойная установка размеров была вы
полнена преднамеренно. 640×480 – это довольно разумные начальные
размеры, поэтому это очень неплохие значения по умолчанию. Хотя
размеры 640×480 достаточно хороши, но чем окно больше, тем лучше,
поэтому мы максимизируем окно. Оказывается, что первоначальная
установка размеров 640×480 (или любых других размеров) считается
хорошей практикой. Согласно документации к PyGTK менеджер окон
может не поддерживать запрос maximize(). Кроме того, пользователю
может понадобиться снова уменьшить размеры окна после его увеличе
ния, поэтому есть смысл задать исходные размеры окна.
После создания окна и определения его размеров мы создаем элемент
VBox. Это область, или ящик, с «вертикальным размещением», пред
ставляющая собой контейнерный объект. В библиотеке GTK использу
ется концепция использования областей с вертикальным (VBox) и гори
зонтальным (HBox) размещением визуальных компонентов (виджетов)
в окне. Основное предназначение этих областей состоит в том, чтобы
вы могли «наполнять» их виджетами, помещая их в начало (сверху
для VBox и слева для HBox) или в конец области. Под термином «вид
жет» подразумеваются обычные элементы графического интерфейса,
такие как кнопки или текстовые поля. При использовании этих облас
тей вы можете расположить виджеты в окне практически любым тре
буемым вам способом. Поскольку области являются контейнерами,
они могут вмещать другие области, поэтому вы спокойно можете встав
лять одни области в другие.
После добавления области VBox в окно мы добавляем панель инстру
ментов и кнопки. Сама по себе панель инструментов – это еще одна
разновидность контейнеров, и она предоставляет методы для добавле
ния в нее компонентов. Далее мы создаем пиктограммы для кнопок,
сами кнопки и подключаем к кнопкам обработчики событий. Нако
нец, мы добавляем кнопки на панель инструментов. Для добавления
виджетов на панель инструментов Toolbar используется метод insert(),
играющий ту же роль, что и метод pack_start() области VBox.
```

**398** Глава 11. Создание графического интерфейса

```
Далее мы создаем виджет выбора файлов, который позволит отыски
вать файлы журналов для просмотра, и связываем его с обработчиком
события. В этой части нет ничего сложного, но мы вскоре еще вернем
ся к ней.
После создания виджета выбора файлов мы создаем компонент спи
ска, который будет содержать строки из файла журнала. Этот компо
нент состоит из двух частей: объект хранения данных (с именем List
Store) и визуальный компонент (TreeView), с которым пользователь бу
дет взаимодействовать. Компонент хранения данных создается пер
вым, путем определения типов данных для каждой колонки. Затем мы
создаем визуальный компонент и связываем с ним компонент хране
ния данных.
Вслед за компонентом списка создается последний контейнер – про
кручиваемая область окна, после чего все виджеты объединяются вме
сте. Мы помещаем в созданную ранее область VBox панель инструмен
тов, виджет выбора файлов и прокручиваемую область. Список, содер
жащий строки из файла журнала, мы добавляем в прокручиваемую
область, благодаря чему при большом количестве строк мы сможем
прокручивать их.
В заключение мы делаем одни виджеты видимыми, а другие – невиди
мыми. Главное окно делается видимым с помощью метода show_all().
Этот метод делает видимыми и все вложенные компоненты. Учиты
вая, что мы создаем приложение с графическим интерфейсом, нам не
обходимо, чтобы виджет выбора файлов оставался невидимым, пока
пользователь не щелкнет на кнопке «open» (открыть). Поэтому этот
виджет после его создания мы делаем невидимым.
Запустив это приложение, вы сможете убедиться, что оно соответству
ет нашим первоначальным требованиям. Мы можем выбирать и от
крывать нужный нам файл журнала. Каждому полю – номер строки,
имя хоста, код состояния и количество переданных байтов – соответ
ствует своя колонка в компоненте списка, поэтому мы легко можем
идентифицировать данные, просто взглянув на строку. Кроме того, мы
можем выполнять сортировку по любому столбцу, просто щелкнув на
соответствующем заголовке.
```
**Создание приложения для просмотра файла**

**журнала вебсервера Apache с помощью curses**

```
curses – это библиотека, облегчающая создание интерактивных прило
жений с текстовым интерфейсом. В отличие от библиотек графическо
го интерфейса curses не поддерживает модель обработки событий
функциями обратного вызова. Вы сами отвечаете за получение ввода
от пользователя и за его обработку, тогда как в GTK задача получения
ввода от пользователя обрабатывается виджетами, и библиотека сама
```

Создание приложения для Apache с использованием curses **399**

```
вызывает функцииобработчики при возникновении событий. Еще од
но различие между curses и библиотеками создания графического ин
терфейса заключается в том, что при использовании библиотек графи
ческого интерфейса вы добавляете виджеты в некоторый контейнер
и позволяете библиотеке самой заниматься отображением и обновле
нием экрана. При использовании библиотеки curses вам обычно самим
придется заниматься выводом текста на экран.
В примере 11.3 приводится еще одна версия программы просмотра фай
ла журнала вебсервера Apache, реализованная с использованием моду
ля curses, входящего в состав стандартной библиотеки языка Python.
```
```
Пример 11.3. Приложение curses для просмотра файла журнала
веб>сервера Apache
#!/usr/bin/env python
"""
```
```
Программа просмотра файла журнала вебсервера Apache, реализованная на основе
библиотеки curses
```
```
Порядок использования:
curses_log_viewer.py logfile
```
```
Этой командой будет запущено интерактивное, управляемое с клавиатуры
приложение просмотра файла журнала. Ниже приводится перечень горячих клавиш
с описанием выполняемых ими функций:
u/d прокрутка вверх/вниз
t перейти в начало файла
q завершить работу
b/h/s – сортировать по количеству байтов/имени хоста/коду состояния
r восстановить первоначальный порядок сортировки
```
```
"""
import curses
from apache_log_parser_regex import dictify_logline
import sys
import operator
class CursesLogViewer(object):
def __init__(self, logfile=None):
self.screen = curses.initscr()
self.curr_topline = 0
self.logfile = logfile
self.loglines = []
def page_up(self):
self.curr_topline = self.curr_topline (2 * curses.LINES)
if self.curr_topline < 0:
self.curr_topline = 0
self.draw_loglines()
```

**400** Глава 11. Создание графического интерфейса

```
def page_down(self):
self.draw_loglines()
```
```
def top(self):
self.curr_topline = 0
self.draw_loglines()
def sortby(self, field):
#self.loglines = sorted(self.loglines, key=operator.itemgetter(field))
self.loglines.sort(key=operator.itemgetter(field))
self.top()
def set_logfile(self, logfile):
self.logfile = logfile
self.load_loglines()
```
```
def load_loglines(self):
self.loglines = []
logfile = open(self.logfile, 'r')
for i, line in enumerate(logfile):
line_dict = dictify_logline(line)
self.loglines.append((i + 1, line_dict['remote_host'],
line_dict['status'], int(line_dict['bytes_sent']), line.rstrip()))
logfile.close()
self.draw_loglines()
def draw_loglines(self):
self.screen.clear()
status_col = 4
bytes_col = 6
remote_host_col = 16
status_start = 0
bytes_start = 4
remote_host_start = 10
line_start = 26
logline_cols = curses.COLSstatus_colbytes_colremote_host_col1
for i in range(curses.LINES):
c = self.curr_topline
try:
curr_line = self.loglines[c]
except IndexError:
break
self.screen.addstr(i, status_start, str(curr_line[2]))
self.screen.addstr(i, bytes_start, str(curr_line[3]))
self.screen.addstr(i, remote_host_start, str(curr_line[1]))
#self.screen.addstr(i, line_start,
str(curr_line[4])[logline_cols])
self.screen.addstr(i, line_start, str(curr_line[4]), logline_cols)
self.curr_topline += 1
self.screen.refresh()
def main_loop(self, stdscr):
stdscr.clear()
self.load_loglines()
```

Создание приложения для Apache с использованием curses **401**

```
while True:
c = self.screen.getch()
try:
c = chr(c)
except ValueError:
continue
if c == 'd':
self.page_down()
elif c == 'u':
self.page_up()
elif c == 't':
self.top()
elif c == 'b':
self.sortby(3)
elif c == 'h':
self.sortby(1)
elif c == 's':
self.sortby(2)
elif c == 'r':
self.sortby(0)
elif c == 'q':
break
```
```
if __name__ == '__main__':
infile = sys.argv[1]
c = CursesLogViewer(infile)
curses.wrapper(c.main_loop)
```
```
В примере 11.3 мы создали единственный класс, CursesLogViewer, с це
лью организации программного кода. В конструкторе создается экран
curses и инициализируется несколько переменных. Экземпляр класса
CursesLogViewer создается в разделе «main» программы, при этом ему
передается имя файла журнала, который требуется просмотреть. Мы
могли бы реализовать в приложении возможность поиска и выбора
файла, но для этого пришлось бы приложить больше усилий, чем
в приложении PyGTK. Кроме того, поскольку приложение будет за
пускаться пользователем из командной оболочки, вполне естествен
ным будет ожидать, что пользователь сначала отыщет требуемый файл
в командной строке, а затем укажет его при запуске приложения. По
сле создания экземпляра класса CursesLogViewer мы передаем метод
main_loop() функции wrapper() из библиотеки curses. Функция wrapper()
переводит терминал в состояние, пригодное для работы приложения
на базе curses, вызывает указанную ей функцию, а затем, перед воз
вратом, возвращает терминал в нормальное состояние.
Метод main_loop() действует как элементарный цикл обработки собы
тий. Он ожидает, пока пользователь нажмет какуюлибо клавишу на
клавиатуре. После этого в соответствии с введенным символом цикл
переходит к соответствующему методу (или, по крайней мере, к реали
зации требуемого поведения). Нажатие клавиш u и d вызывает про
```

**402** Глава 11. Создание графического интерфейса

```
крутку вверх и вниз – за счет вызова методов page_up() и page_down(), со
ответственно. Метод page_down() просто вызывает метод draw_loglines(),
который выводит строки на терминал, начиная с текущей строки
и с верхней позиции на экране. При выводе каждой строки текущей
становится следующая строка. Метод draw_loglines() выводит столько
строк, сколько поместится на экране, а при следующем вызове он
вновь начнет вывод очередной текущей строки с верхней позиции на
экране. Поэтому многократный вызов draw_loglines() создает визуаль
ный эффект прокрутки вниз по содержимому файла журнала. Метод
page_up() сначала назначает текущей строку, расположенную на две
страницы выше, и затем производит вывод строк вызовом метода
draw_loglines(). Это создает визуальный эффект прокрутки вверх по
содержимому файла журнала. Причина, по которой в методе page_up()
текущей назначается строка, расположенная на две страницы выше,
состоит в том, что после вывода строк текущей становится строка, рас
положенная внизу экрана. Такой порядок был выбран для упрежде
ния прокрутки вниз.
Следующий метод нашего класса реализует сортировку. Мы преду
смотрели сортировку по имени хоста, коду состояния и количеству
байтов, отправленных в ответ на запрос. Любая попытка сортировки
приводит к вызову метода sortby(). Метод sortby() сортирует список
строк объекта CursesLogViewer по указанному полю, после чего вызыва
ет метод top(). Метод top() назначает текущей первую строку в списке
и затем выводит очередную страницу строк (которая будет первой
страницей).
Последний обработчик события в нашем приложении выполняет за
вершение работы приложения. В этом случае просто происходит пре
рывание «цикла обработки событий», что позволяет методу main_loop()
вернуть управление функции wrapper(), которая в свою очередь произ
водит восстановление режима работы терминала.
Несмотря на то, что по числу строк программного кода обе версии при
ложения вполне сопоставимы, тем не менее, для реализации приложе
ния на базе библиотеки curses пришлось приложить больше усилий.
Возможно, это обусловлено необходимостью создавать свой собствен
ный цикл обработки событий. Или, может быть, изза необходимости
создавать некоторое подобие графических элементов. Или, возможно,
изза того, что пришлось «рисовать» текст непосредственно на экране
терминала, у нас сложилось ощущение, что пришлось выполнить
больше работы. Как бы то ни было, иногда знание того, как создавать
приложения на базе curses, может оказаться полезным.
На рис. 11.3 показан внешний вид приложения просмотра файла жур
нала, в котором строки отсортированы по количеству отправленных
байтов.
Одно из улучшений, которое можно было бы внести в это приложение, –
это реализовать сортировку в порядке, обратном текущему. Сделать
```

Веб;приложения **403**

```
это достаточно просто, но мы оставим реализацию этой возможности
читателям. Как еще одно улучшение можно было бы организовать
просмотр всей информационной части строки журнала. Это тоже не
очень сложно, но реализацию этой возможности мы также оставим за
читателями в качестве упражнения.
```
**Вебприложения**

```
Сказать, что Сеть огромна, значит преуменьшить ее истинные разме
ры. Сеть изобилует приложениями, которые люди используют еже
дневно. Почему в Сети так много приложений? Вопервых, вебприло
жения отличаются широтой доступности. Это означает, что после раз
вертывания вебприложения любой, кто обладает доступом к нему,
может просто указать адрес URL в своем броузере и пользоваться им.
Пользователям не требуется ничего загружать и устанавливать, разве
только дополнения к броузеру (который сам по себе уже установлен),
такие как Flash. Эта особенность особенно привлекательна для пользо
вателей. Вовторых, вебприложения могут подвергаться модерниза
ции в одностороннем порядке, причем сразу для всех пользователей.
Это означает, что одна сторона (владелец приложения) может выпол
нить модернизацию приложения без какоголибо участия другой сто
роны (пользователя). Хотя в действительности это справедливо, толь
ко если вы не опираетесь на функциональные возможности, которые
могут отсутствовать у пользователя. Например, если ваше модернизи
рованное приложение опирается на новейшую версию Flash, это мо
жет потребовать от пользователей установить новую версию расшире
```
```
Рис. 11.3. Содержимое файла журнала веб>сервера Apache
```

**404** Глава 11. Создание графического интерфейса

```
ния, и все ваши преимущества могут «вылететь в трубу». Если же это
го не требуется, то возможность модернизации вебприложений стано
вится привлекательной для обеих сторон, хотя пользователи, скорее
всего, осознают это не так явно. Втретьих, броузер представляет собой
в значительной степени универсальную платформу. Конечно, имеются
определенные проблемы с обеспечением совместимости между броузе
рами, но в большинстве случаев, если вы не будете использовать спе
циальные расширения, то вебприложение, работающее в одном бро
узере и в одной операционной системе, практически наверняка будет
работать в другом броузере и в другой операционной системе. Эта осо
бенность также является привлекательной для обеих сторон. Просто
со стороны разработчика придется приложить немного больше уси
лий, чтобы обеспечить работоспособность приложения в различных
броузерах. А пользователи любят пользоваться приложениями, остав
ляющими за ними право выбора.
Насколько это важно для вас, как для системного администратора?
Все причины, которые приводились в пользу создания приложений
с графическим интерфейсом, в равной степени относятся и к вебприло
жениям. Одно из преимуществ вебприложений для системных адми
нистраторов состоит в том, что вебприложения имеют доступ к файло
вой системе и таблице процессов на той машине, на которой они вы
полняются. Эта особенность вебприложений делает их прекрасным
решением для осуществления мониторинга системы, приложений
и пользователей, а также отличным механизмом предоставления отче
тов. А этот класс задач находится в области ведения системного адми
нистратора.
Хотелось бы надеяться, что вы сможете воспользоваться этими преиму
ществами, хотя совсем не все вебприложения, которые вы создаете для
себя или для ваших пользователей, могут давать такой эффект. Итак,
какие инструменты вы можете использовать для создания вебприло
жений? Поскольку эта книга о языке Python, мы, конечно же, реко
мендуем использовать решения, основанные на языке Python. Но что
из них выбрать? Одна из проблем состоит в том, что существует столько
же платформ для разработки вебприложений на языке Python, сколь
ко дней в году. В настоящее время доминирующее положение занима
ют четыре из них – TurboGears, Django, Pylons и Zope. У каждой из
этих четырех платформ имеются свои достоинства, но на наш взгляд,
платформа Django лучше других соответствует теме этой книги.
```
**Django**

```
Django – это полнофункциональная платформа для разработки веб
приложений. Она содержит систему управления шаблонами, механиз
мы соединения с базами данных посредством объектнореляционной
проекции и, конечно же, сам язык Python для реализации логики при
ложений. Будучи «полнофункциональной» платформой, Django также
```

Django **405**

```
использует подход MVT (ModelViewTemplate – модельпредставление
шаблон). Подход модельпредставлениешаблон похож, если не иден
тичен, более общему подходу MVC (ModelViewController – модель
представлениеконтроллер). Оба способа позволяют разрабатывать веб
приложения так, чтобы не смешивать части приложений. Программ
ный код взаимодействия с базой данных в обоих случаях представляет
собой отдельную область, которая называется «моделью». Бизнесло
гика выделяется в область, которая называется «представлением»
в MVT и «контроллером» в MVC. А внешний интерфейс выделяется
в область, которая называется «шаблоном» в MVT и «представлени
ем» в MVC.
```
**Приложение для просмотра файла журнала**

**вебсервера Apache**

```
В следующем примере, состоящем из нескольких фрагментов про
граммного кода, мы создадим еще одно приложение для просмотра
файла журнала вебсервера Apache, аналогичное тому, что было реали
зовано на базе библиотеки PyGTK. Так как мы собираемся открывать
файлы журналов, чтобы позволить пользователям просматривать и сор
тировать их, то нам не потребуется обращаться к базе данных и наш
пример будет лишен какихлибо средств подключения к базам дан
ных. Прежде чем приступить к обсуждению примера, мы покажем
вам, как создать проект и приложение в Django.
Загрузить Django можно по адресу: http://www.djangoproject.com/.
К моменту написания этих строк последней была версия 0.96. Однако
мы рекомендуем устанавливать версию из дерева разработки. После
загрузки платформа устанавливается обычной командой python set
up.py install. После установки в каталоге site>packages появятся до
полнительные библиотеки платформы Django и сценарий django–ad
min.py в каталоге для сценариев. Обычно в UNIXподобных системах
сценарии по умолчанию устанавливаются в тот же каталог, где нахо
дится выполняемый файл python.
После установки Django необходимо создать проект и приложение. Про
екты содержат по одному или более приложений. Кроме того, они игра
ют роль центров конфигурации для всего вебприложения (не путайте
с приложением Django), которое вы создаете. Приложения Django –
это небольшие фрагменты, которые могут многократно использовать
ся в разных проектах. Для нашего приложения просмотра файла жу
ранала вебсервера Apache мы создали проект с именем «dj_apache»,
выполнив команду django–admin.py startproject dj_apache. Эта команда
создала каталог и несколько файлов. В примере 11.4 приводится дере
во каталогов нового проекта.
```
```
Пример 11.4. Дерево каталогов проекта Django
jmjones@dinkbuntu:~/code$ tree dj_apache
```

**406** Глава 11. Создание графического интерфейса

```
dj_apache
| __init__.py
| manage.py
| settings.py
` urls.py
0 directories, 4 files
```
```
Теперь, когда у нас имеется проект, мы можем в рамках этого проекта
создать приложение. Для этого сначала следует перейти в каталог
dj_apache , а затем создать приложение, выполнив команду django–ad
min.py startapp logview. В результате в каталоге dj_apache будет создан
каталог logview и несколько файлов. В примере 11.5 показаны все фай
лы и каталоги, которые теперь имеются в нашем распоряжении.
```
```
Пример 11.5. Дерево каталогов приложения Django
jmjones@dinkbuntu:~/tmp$ tree dj_apache/
dj_apache/
| __init__.py
| logview
| | __init__.py
| | models.py
| ` views.py
| manage.py
| settings.py
` urls.py
```
```
Как видите, каталог приложения (logview) содержит файлы models.py
иviews.py. Платформа Django следует соглашениям MVT, поэтому эти
файлы помогут разделить все приложение на компоненты, соответст
вующие именам файлов. Файл models.py содержит схему базы данных,
поэтому он представляет компонент Model (модель) в аббревиатуре
MVT. Файл views.py содержит реализацию логики приложения, по
этому он представляет компонент View (представление) в этой аббре
виатуре.
Здесь отсутствует компонент Template (шаблон). Компонент шаблона
содержит уровень представления всего приложения. Существует не
сколько способов заставить платформу Django увидеть наши шаблоны.
Так, в примере 11.6 показано, что мы создали подкаталог templates
в каталоге logview.
```
```
Пример 11.6. Добавление каталога templates
jmjones@dinkbuntu:~/code$ mkdir dj_apache/logview/templates
jmjones@dinkbuntu:~/code$ tree dj_apache/
dj_apache/
| __init__.py
| logview
| | __init__.py
| | models.py
| | templates
```

Django **407**

```
| ` views.py
| manage.py
| settings.py
` urls.py
```
```
2 directories, 7 files
```
```
Теперь мы готовы к воплощению нашего приложения. В первую оче
редь мы должны решить, как будут работать наши URL. Это очень про
стое приложение, поэтому адреса URL должны быть очень простыми.
Нам потребуется выводить список файлов журналов, доступных для
просмотра. Поскольку приложение обладает простой и ограниченной
функциональностью, мы будем использовать адрес URL «/» для дос
тупа к списку файлов и строку URL вида "/viewlog/some_sort_method/
some_log_file" для указания имени файла и метода сортировки. Чтобы
связать URL с определенным действием, нам необходимо обновить
файл urls.py в корневом каталоге проекта. Содержимое файла urls.py
для нашего проекта приводится в примере 11.7.
```
```
Пример 11.7. Конфигурация URL для проекта Django (urls.py)
from django.conf.urls.defaults import *
```
```
urlpatterns = patterns('',
(r'^$', 'dj_apache.logview.views.list_files'),
(r'^viewlog/(?P<sortmethod>.*?)/(?P<filename>.*?)/$',
'dj_apache.logview.views.view_log'),
)
```
```
Файл с настройками URL достаточно прост и понятен. Этот файл опира
ется на использование регулярных выражений: строки URL, соответст
вующие регулярному выражению, отображаются на функцию пред
ставления, задаваемую явно строкой. Здесь мы отображаем URL «/» на
функцию "dj_apache.logview.views.list_files". Все остальные URL, со
ответствующие регулярному выражению '^viewlog/(?P<sortmethod>.*?)/
(?P<filename>.*?)/$', – на функцию "dj_apache.logview.views.view_log".
Когда броузер соединяется с вебприложением Django и отсылает за
прос на доступ к определенному ресурсу, Django просматривает urls.py
в поисках элемента, регулярное выражение которого соответствует
URL, и затем направляет запрос соответствующей функции.
В примере 11.8 представлен исходный текст функций представления
для данного приложения, а также вспомогательной функции.
```
```
Пример 11.8. Модуль представления Django (views.py)
# Создайте свои представления здесь.
```
```
from django.shortcuts import render_to_response
import os
from apache_log_parser_regex import dictify_logline
import operator
```

**408** Глава 11. Создание графического интерфейса

```
log_dir = '/var/log/apache2'
def get_log_dict(logline):
l = dictify_logline(logline)
try:
l['bytes_sent'] = int(l['bytes_sent'])
except ValueError:
bytes_sent = 0
l['logline'] = logline
return l
def list_files(request):
file_list = [f for f in os.listdir(log_dir) if
os.path.isfile(os.path.join(log_dir, f))]
return render_to_response('list_files.html', {'file_list': file_list})
def view_log(request, sortmethod, filename):
logfile = open(os.path.join(log_dir, filename), 'r')
loglines = [get_log_dict(l) for l in logfile]
logfile.close()
try:
loglines.sort(key=operator.itemgetter(sortmethod))
except KeyError:
pass
return render_to_response('view_logfile.html', {'loglines': loglines,
'filename': filename})
```
```
Функция list_files() получает список всех файлов, находящихся в ка
талоге, заданном переменной log_dir, и передает этот список шаблону
list_files.html. Это все, что происходит в функции list_files(). Дан
ная функция настраивается изменением значения переменной log_dir.
Другой способ влияния на работу этой функции мог бы заключаться
в хранении имени каталога журналов в базе данных. Если бы имя ка
талога хранилось в базе данных, мы могли бы изменять это значение
без необходимости перезапускать приложение.
Функция view_log() принимает в качестве аргументов метод сортиров
ки и имя файла журнала. Значения для обоих этих аргументов извле
каются из URL посредством регулярного выражения, заданного в фай
ле urls.py. Для задания метода сортировки и имени файла мы использо
вали именованные группы в регулярном выражении в файле urls.py,
но это не является обязательным. Аргументы, извлеченные из URL,
передаются функции представления в том же порядке, в каком они
были найдены в соответствующих группах. Это распространенная
практика, когда в регулярном выражении разбора URL используются
именованные группы, потому что благодаря такому подходу вы легко
можете сказать, какие параметры извлекаются из URL, а также – как
должна выглядеть строка URL.
Функция view_log() открывает файл журнала с именем, полученным
из URL. Затем выполняется его анализ с помощью библиотеки анализа
файлов журналов Apache из приведенных ранее примеров, чтобы пре
```

Django **409**

```
образовать каждую строку в кортеж, в формате: статус, удаленный_хост,
количество_байтов и остаток строки журнала. Затем функция view_log()
сортирует список кортежей, который был получен из URL, с учетом
указанного метода сортировки. В заключение функция view_log() пере
дает полученный список шаблону view_logfile.html для отображения.
Единственное, что осталось сделать, это создать шаблоны, которые ис
пользуются функциями представления для отображения информа
ции. Шаблоны в платформе Django могут наследовать другие шабло
ны, благодаря чему повышается уровень многократного использова
ния кода и обеспечивается единообразие внешнего вида страниц. Пер
вым мы создадим шаблон, который является родительским для двух
других шаблонов. Этот шаблон будет определять общий внешний вид
для других двух шаблонов в приложении. Именно поэтому мы и нач
нем с него. Это шаблон base.html, исходный код которого приводится
в примере 11.9.
```
```
Пример 11.9. Базовый шаблон Django (base.html)
<html>
<head>
<title>
{% block title %}Apache Logviewer File Listing{% endblock %}
</title>
</head>
<body>
<div><a href="/">Log Directory</a></div>
{% block content %}Empty Content Block{% endblock %}
</body>
</html>
```
```
Это очень простой базовый шаблон. Возможно, это самая простая стра
ница HTML, которую только можно получить. Единственные элемен
ты, которые представляют здесь интерес, – это два раздела «block»:
«title» и «content». Когда в родительском шаблоне определяется раз
дел «block», дочерний шаблон получает возможность заменить его сво
им собственным содержимым. Это позволяет задавать содержимое по
умолчанию, которое может быть замещено в дочернем шаблоне. Блок
«title» позволяет дочерним страницам определять значение, которое
будет отображаться в теге <title>. Блок «content» – это типичный при
ем обновления «главного» раздела страницы без внесения изменений
в остальную часть страницы.
В примере 11.10 приводится шаблон, с помощью которого выводится
список файлов в указанном каталоге.
```
```
Пример 11.10. Шаблон Django для вывода списка файлов (list_files.html)
{% extends "base.html" %}
```
```
{% block title %}Apache Logviewer File Listing{% endblock %}
```

**410** Глава 11. Создание графического интерфейса

```
{% block content %}
<ul>
{% for f in file_list %}
<li><a href="/viewlog/linesort/{{ f }}/" >{{ f }}</a></li>
{% endfor %}
</ul>
{% endblock %}
```
```
На рис. 11.4 показано, как выглядит страница со списком файлов.
В этом шаблоне мы указываем, что расширяем шаблон «base.html».
Это позволяет использовать все, что определено в базовом шаблоне,
включать свой код в любые блоки, которые были определены, и пере
определять их поведение. Именно это мы и делаем с блоками «title»
и «content». В блоке «content» в цикле выполняется обход содержимо
го переменной file_list, которая была передана шаблону. Для каждо
го элемента в списке file_list создается ссылка, в результате щелчка
на которой будет открыт соответствующий файл журнала.
Шаблон в примере 11.11 отвечает за создание страниц, на которые
указывают ссылки из шаблона в предыдущем примере 11.10. Он ото
бражает содержимое выбранного файла журнала.
```
```
Пример 11.11. Шаблон Django для вывода содержимого файлов
(view_logfile.html)
{% extends "base.html" %}
```
```
{% block title %}Apache Logviewer File Viewer{% endblock %}
{% block content %}
<table border="1">
<tr>
<td><a href="/viewlog/status/{{ filename }}/">Status</a></td>
<td><a href="/viewlog/remote_host/{{ filename }}/">
Remote Host</a></td>
```
```
Рис. 11.4. Список файлов журналов веб>сервера Apache
```

Django **411**

```
<td><a href="/viewlog/bytes_sent/{{ filename }}/">Bytes Sent</a></td>
<td><a href="/viewlog/linesort/{{ filename }}/">Line</a></td>
</tr>
{% for l in loglines %}
<tr>
<td>{{ l.status }}</td>
<td>{{ l.remote_host }}</td>
<td>{{ l.bytes_sent }}</td>
<td><pre>{{ l.logline }}</pre></td>
</tr>
{% endfor %}
</table>
{% endblock %}
```
```
Шаблон в примере 11.11 наследует базовый шаблон, упоминавшийся
выше, и создает таблицу в области «content». Заголовок таблицы опи
сывает содержимое каждого столбца: код состояния, удаленный хост,
количество отправленных байтов и остаток строки из файла журнала.
Помимо описания содержимого, заголовки столбцов дают пользовате
лю возможность выполнять сортировку по тому или иному столбцу.
Например, если пользователь щелкнет на заголовке столбца «Bytes
Sent» (передано байтов) (который является обычной ссылкой), страни
ца будет перезагружена и программный код в сценарии представления
отсортирует строки по столбцу «Bytes Sent». Щелчок на заголовке лю
бого столбца, за исключением «Line», будет приводить к выполнению
сортировки по этому столбцу в порядке возрастания. Щелчок на заго
ловке «Line» приведет к возврату к первоначальному порядку следо
вания строк.
На рис. 11.5 показано, как выглядит страница приложения с ориги
нальным порядком следования строк, а на рис. 11.6 – как выглядит
страница после выполнения сортировки по столбцу «Bytes Sent».
Это было очень простое вебприложение, построенное на базе платфор
мы Django. В действительности это не совсем типичное приложение.
Большинство приложений Django выполняют операции с некоторыми
базами данных. Данное приложение можно было бы усовершенство
вать, добавив сортировку по всем столбцам в обратном порядке,
фильтрацию по некоторому значению кода состояния или удаленному
хосту, фильтрацию на основе критерия сравнения количества отправ
ленных байтов с некоторым числом, возможность комбинировать раз
личные фильтры друг с другом и дополнить их возможностями техно
логии AJAX. Но мы не будем выполнять все эти усовершенствования
и оставим их читателю в качестве самостоятельного упражнения.
```

**412** Глава 11. Создание графического интерфейса

```
Рис. 11.5. Просмотр содержимого файла журнала веб>сервера Apache –
сортировка по номерам строк
```
```
Рис. 11.6. Просмотр содержимого файла журнала веб>сервера Apache –
сортировка по количеству отправленных байтов
```

Django **413**

**Простое приложение базы данных**

```
Выше мы уже говорили, что предыдущее приложение на платформе
Django является не совсем типичным примером ее использования, так
как оно не использует базу данных. Следующий пример больше соот
ветствует типичному использованию Django, поэтому основное внима
ние мы сосредоточим в несколько иной области. При использовании
Django для создания приложения, которое будет подключаться к базе
данных, часто создаются шаблоны для отображения данных, храня
щихся в базе данных, а также формы, выполняющие проверку и обра
ботку данных, введенных пользователем. В этом примере будет пока
зано, как создается модель базы данных с использованием объектно
реляционных проекций платформы Django, а также – как создаются
шаблоны и сценарии для отображения данных, но ввод данных будет
опираться на встроенный административный интерфейс платформы
Django. Цель такого подхода состоит в том, чтобы показать вам, как
легко и быстро можно создать интерфейс для работы с базой данных,
который позволит вводить и администрировать данные.
Приложение, которое мы создадим, представляет собой приложение
инвентаризации компьютерных систем. В частности, это приложение
будет позволять вносить в базу данных компьютеры с их описанием,
присвоенными им IPадресами, с перечислением служб, которые вы
полняются на них, перечень аппаратного обеспечения, составляющего
сервер, и многое другое.
Как и в предыдущем примере, мы выполним те же самые действия,
чтобы создать проект и приложение Django. Ниже приводятся коман
ды обращения к инструменту командной строки django–admin, создаю
щие проект и приложение:
jmjones@dinkbuntu:~/code$ djangoadmin startproject sysmanage
jmjones@dinkbuntu:~/code$ cd sysmanage
jmjones@dinkbuntu:~/code/sysmanage$ djangoadmin startapp inventory
jmjones@dinkbuntu:~/code/sysmanage$
```
```
Эти команды создали аналогичное дерево каталогов, как и в предыду
щем примере приложения для просмотра файла журнала вебсервера
Apache. Ниже приводится дерево каталогов и файлов, которые были
созданы:
jmjones@dinkbuntu:~/code/sysmanage$ cd ../
jmjones@dinkbuntu:~/code$ tree sysmanage/
sysmanage/
| __init__.py
| inventory
| | __init__.py
| | models.py
| ` views.py
| manage.py
```

**414** Глава 11. Создание графического интерфейса

```
| settings.py
` urls.py
```
```
Создав проект и приложение, нам необходимо настроить базу данных,
с которой мы будем работать. База данных SQLite предоставляет пре
красные возможности, особенно для нужд тестирования и разработки,
при условии, что она не будет использоваться в рабочем окружении.
Если приложение предусматривает работу более чем с одним пользова
телем одновременно, мы рекомендуем использовать более надежную
базу данных, такую как PostgreSQL. Для настройки приложения на
использование базы данных SQLite мы изменим пару строк в файле
settings.py , расположенном в корневом каталоге проекта. Ниже пока
заны строки, которые мы изменили:
```
```
DATABASE_ENGINE = 'sqlite3'
DATABASE_NAME = os.path.join(os.path.dirname(__file__), 'dev.db')
```
```
В качестве механизма базы данных мы указали «sqlite3». Строка, опре
деляющая местоположение базы данных (параметр DATABASE_NAME), тре
бует дополнительных пояснений. Вместо того чтобы указать абсолют
ный путь к файлу базы данных, мы определили, что он всегда будет
находиться в том же каталоге, что и файл settings.py. Атрибут __file__
всегда хранит абсолютный путь к файлу settings.py. Вызов метода
os.path.dirname(__file__) возвращает каталог, в котором находится
файл settings.py. Полученное имя каталога и имя файла базы данных,
который мы предполагаем создать, передается методу os.path.join(),
возвращающему абсолютный путь к файлу базы данных, который за
висит от каталога с приложением. Это полезный прием, который вы
можете взять на вооружение при настройке параметров, связанных
с местоположением файлов.
В дополнение к настройкам базы данных нам необходимо включить
административный интерфейс платформы Django и наше приложение
инвентаризации, наряду с другими приложениями в этом проекте.
Ниже приводится соответствующий фрагмент файла settings.py :
INSTALLED_APPS = (
'django.contrib.admin',
'django.contrib.auth',
'django.contrib.contenttypes',
'django.contrib.sessions',
'django.contrib.sites',
'sysmanage.inventory',
)
```
```
Мы добавили в список установленных приложений django.contrib.admin
и sysmanage.inventory. Это означает, что, когда мы потребуем от плат
формы Django создать базу данных, она создаст таблицы для всех уста
новленных приложений.
```

Django **415**

```
Далее нам необходимо настроить отображение URL, так чтобы этот
проект включал административный интерфейс. Ниже приводится со
ответствующая строка из файла настройки URL:
# Раскомментируйте следующую строку для включения административного интерфейса
(r'^admin/', include('django.contrib.admin.urls')),
```
```
Инструмент, создавший файл urls.py , поместил в него строку, которая
подключает административный интерфейс, но эту строку требуется
раскомментировать. Как видите, чтобы подключить административ
ный интерфейс, мы просто убрали символ #, стоявший в начале строки.
Теперь, когда мы настроили базу данных, добавили приложения адми
нистративного интерфейса и инвентаризации и добавили администра
тивный интерфейс в конфигурационный файл urls.py , можно присту
пать к определению схемы базы данных. При использовании платфор
мы Django для каждого приложения определяется своя собственная
схема. В каталоге каждого приложения, в данном случае «inventory»,
присутствует файл с именем models.py , содержащий определения таб
лиц и столбцов, которые будут использоваться приложением. В Django,
как и в других платформах разработки вебприложений, опирающихся
на использование объектнореляционных проекций (ObjectRelation
Mapping, ORM), вполне возможно создавать и использовать базы дан
ных, не написав ни одного SQLвыражения. Механизм ORM платфор
мы Django превращает классы в таблицы, а атрибуты классов в столб
цы этих таблиц. Например, следующий фрагмент программного кода
является определением таблицы настроенной базы данных (этот фраг
мент является частью более крупного сценария, к которому мы вскоре
подойдем):
```
```
class HardwareComponent(models.Model):
manufacturer = models.CharField(max_length=50)
#в число типов входят видеокарта, сетевая карта...
type = models.CharField(max_length=50)
model = models.CharField(max_length=50, blank=True, null=True)
vendor_part_number = models.CharField(max_length=50,
blank=True, null=True)
description = models.TextField(blank=True, null=True)
```
```
Обратите внимание, что класс HardwareComponent наследует класс Model
платформы Django. Это означает, что класс HardwareComponent относит
ся к типу Model и обладает соответствующим поведением. Каждому ап
паратному компоненту мы придали несколько атрибутов: manufacturer
(производитель), type (тип), model (модель), vendor_part_number (серий
ный номер) и description (описание). Реализация этих атрибутов нахо
дится в самой платформе Django. Нет, платформа не предоставляет ка
койлибо перечень производителей, но она реализует тип CharField.
Такое определение класса в приложении inventory создаст таблицу
inventory_hardwarecomponent с шестью столбцами: id, manufacturer, type,
model, vendor_part_number и description. Что практически в точности со
```

**416** Глава 11. Создание графического интерфейса

```
ответствует определению класса для ORM. Фактически такое объяв
ление полностью соответствует определению класса для ORM. Когда
определяется класс модели, платформа Django создает соответствую
щую таблицу с именем, состоящим из имени приложения (все симво
лы в нижнем регистре), за которым следуют символ подчеркивания и
имя класса (все символы также в нижнем регистре). Кроме того, если
не определено иное, платформа создаст в вашей таблице дополнитель
ный столбец id, который будет играть роль первичного ключа. Ниже
приводится код на языке SQL, создающий таблицу, которая полно
стью соответствует модели HardwareComponent:
```
```
CREATE TABLE "inventory_hardwarecomponent" (
"id" integer NOT NULL PRIMARY KEY,
"manufacturer" varchar(50) NOT NULL,
"type" varchar(50) NOT NULL,
"model" varchar(50) NULL,
"vendor_part_number" varchar(50) NULL,
"description" text NULL
)
```
```
Если вам когданибудь потребуется увидеть код на языке SQL, кото
рый платформа использует для создания базы данных, просто запус
тите в каталоге проекта команду python manage.py sql myapp, где аргу
мент myapp соответствует имени приложения.
Теперь, когда вы познакомились с ORM платформы Django, мы прой
дем через создание модели базы данных для нашего приложения
инвентаризации. В примере 11.12 приводится содержимое файла
model.py для приложения inventory.
```
```
Пример 11.12. Схема базы данных (models.py)
from django.db import models
```
```
# Создайте здесь свои модели.
class OperatingSystem(models.Model):
name = models.CharField(max_length=50)
description = models.TextField(blank=True, null=True)
```
```
def __str__(self):
return self.name
```
```
class Admin:
pass
```
```
class Service(models.Model):
name = models.CharField(max_length=50)
description = models.TextField(blank=True, null=True)
def __str__(self):
return self.name
class Admin:
pass
```

Django **417**

```
class HardwareComponent(models.Model):
manufacturer = models.CharField(max_length=50)
#в число типов входят видеокарта, сетевая карта...
type = models.CharField(max_length=50)
model = models.CharField(max_length=50, blank=True, null=True)
vendor_part_number = models.CharField(max_length=50,
blank=True, null=True)
description = models.TextField(blank=True, null=True)
```
```
def __str__(self):
return self.manufacturer
```
```
class Admin:
pass
```
```
class Server(models.Model):
name = models.CharField(max_length=50)
description = models.TextField(blank=True, null=True)
os = models.ForeignKey(OperatingSystem)
services = models.ManyToManyField(Service)
hardware_component = models.ManyToManyField(HardwareComponent)
```
```
def __str__(self):
return self.name
```
```
class Admin:
pass
class IPAddress(models.Model):
address = models.TextField(blank=True, null=True)
server = models.ForeignKey(Server)
def __str__(self):
return self.address
class Admin:
pass
```
```
Для нашей модели мы определили пять классов: OperatingSystem, Ser
vice, HardwareComponent, Server и IPAddress. Класс OperatingSystem позволя
ет нам определять различные операционные системы для серверов, ко
торые будут учитываться приложением инвентаризации. В этом классе
мы определили два атрибута: name и description, которые действительно
будут необходимы нам. Можно было бы создать класс OperatingSystem
Vendor и определить ссылку на него в классе OperatingSystem, но в инте
ресах сохранения простоты и понятности мы опустим упоминание
о производителе операционной системы. Каждому серверу будет соот
ветствовать единственная операционная система. Мы покажем это от
ношение между сервером и операционной системой, когда будем рас
сматривать класс Server.
Класс Service позволяет перечислить все службы, которые могут вы
полняться на сервере. В качестве примеров таких служб можно на
звать вебсервер Apache, сервер электронной почты Postfix, сервер
```

**418** Глава 11. Создание графического интерфейса

```
DNS Bind и сервер OpenSSH. Как и класс OperatingSystem, этот класс
имеет два атрибута: name и description. Каждый сервер может иметь
множество служб. Мы покажем отношения между этими классами,
когда будем рассматривать класс Server.
Класс HerdwareComponent представляет список всех аппаратных компо
нентов, которые могут содержаться в сервере. Этот список будет пред
ставлять интерес, только если вы сами добавляли аппаратные компо
ненты в приобретенную систему и в случае, если вы собирали сервер из
отдельных компонентов. В классе HardwareComponent мы определили пять
атрибутов: manufacturer, type, model, vendor_part_number и description. Как
и в случае с изготовителем операционной системы, можно было бы соз
дать отдельные классы для описания производителей и типов аппарат
ного обеспечения, а затем связать их отношениями. Но опять же, ради
сохранения простоты мы предпочли не создавать такие отношения.
Класс Server – это основа системы инвентаризации. Каждый экземп
ляр класса Server – это отдельный сервер, информацию о котором мы
собираем. Класс Server – это место, где сходятся все связи и устанав
ливаются отношения с тремя предыдущими классами. Прежде всего,
мы дали каждому серверу атрибуты name и description. Они идентичны
одноименным атрибутам в других классах. Чтобы установить отноше
ния с другими классами, нам необходимо указать в классе Server, ка
кого типа будут эти отношения. Каждый сервер будет иметь только од
ну операционную систему, поэтому мы создаем отношение с классом
OperatingSystem по внешнему ключу (foreign key). Поскольку виртуали
зация становится все более распространенным явлением, отношение
такого типа со временем потеряет свой смысл, но пока оно вполне
удовлетворяет нашим потребностям. На сервере может выполняться
множество служб, и служба одного и того же типа может выполняться
на многих серверах, поэтому между классами Server и Service мы созда
ли отношение типа «многие ко многим». Точно так же каждый сервер
может содержать множество аппаратных компонентов, а один и тот же
тип аппаратного компонента может быть установлен на множестве
серверов. Поэтому классы Server и HardwareComponent мы также связали
отношением типа «многие ко многим».
Наконец, класс IPAddress – это список всех IPадресов всех серверов,
которые должны быть учтены. Мы определили эту модель последней,
чтобы подчеркнуть отношения между IPадресами и серверами. Класс
IPAddress имеет один атрибут и одно отношение. Атрибут address содер
жит IPадрес в формате XXX.XXX.XXX.XXX. Между классами IPAdd
ress и Server мы определили отношение по внешнему ключу, потому
что один IPадрес может принадлежать только одному серверу. Да, это
выглядит слишком упрощенно, но это удовлетворяет целям демонстра
ции установления отношений между компонентами данных в Django.
Теперь все готово к созданию файла базы данных sqlite. Если запустить
команду python manage.py syncdb в каталоге проекта, она создаст все от
```

Django **419**

```
сутствующие таблицы для приложений, включенных в файл settings.py.
Она также предложит создать в базе данных учетную запись суперполь
зователя, если предусмотрено создание таблиц аутентификации. Ниже
приводится (усеченный) вывод команды python manage.py syncdb:
```
```
jmjones@dinkbuntu:~/code/sysmanage$ python manage.py syncdb
Creating table django_admin_log
Creating table auth_message
```
...
Creating manytomany tables for Server model
Adding permission 'log entry | Can add log entry'
Adding permission 'log entry | Can change log entry'
Adding permission 'log entry | Can delete log entry'
You just installed Django's auth system, which means you don't have any
superusers defined.
Would you like to create one now? (yes/no): yes
Username (Leave blank to use 'jmjones'): Email address: none@none.com
Password:
Password (again): Superuser created successfully.
Adding permission 'message | Can add message'
...
Adding permission 'service | Can change service'
Adding permission 'service | Can delete service'
Adding permission 'server | Can add server'
Adding permission 'server | Can change server'
Adding permission 'server | Can delete server'

```
Теперь можно запустить сервер разработки Django и заняться исследо
ванием административного интерфейса. Ниже приводится команда
запуска сервера разработки Django и вывод, полученный в ходе ее вы
полнения:
jmjones@dinkbuntu:~/code/sysmanage$ python manage.py runserver 0.0.0.0:8080
Validating models...
0 errors found
```
```
Django version 0.97preSVNunknown, using settings 'sysmanage.settings'
Development server is running at http://0.0.0.0:8080/
Quit the server with CONTROLC.
```
```
На рис. 11.7 показана форма регистрации. Пройдя процедуру аутенти
фикации, мы сможем добавлять серверы, аппаратные компоненты,
операционные системы и прочие данные. На рис. 11.8 показана глав
ная страница административного интерфейса Django, а на рис. 11.9 –
форма добавления нового аппаратного компонента. Полезно иметь ин
струмент, позволяющий сохранять и просматривать данные непроти
воречивым, простым и удобным способом! Платформа Django удиви
тельно легко справляется с реализацией простого и удобного интер
фейса доступа к данным. И если это все, что вам необходимо, такой ин
струмент станет полезным для вас. Но это только самая верхушка
возможностей платформы Django. Придумав вид отображения данных
```

**420** Глава 11. Создание графического интерфейса

```
в броузере, вы наверняка сможете реализовать его с помощью Django.
И, как правило, это будет не очень сложно.
Например, если бы нам потребовалось получить отдельную страницу
для каждого типа операционной системы, аппаратного компонента,
службы и так далее, мы могли бы это реализовать. Если бы нам потре
бовалось иметь возможность щелкнуть на любом из этих элементов
и получить список серверов, обладающих этой характеристикой, мы
также могли бы реализовать это. И если бы нам потребовалось иметь
возможность щелкнуть на любом из серверов и получить подробную
информацию о нем, мы смогли бы реализовать и это. Давайте теперь это
сделаем. Добавим эти «потребности» к первоначальным требованиям.
```
```
Рис. 11.7. Страница регистрации при входе в административный
интерфейс Django
```
```
Рис. 11.8. Главная страница административного интерфейса Django
```

Django **421**

```
Для начала в примере 11.13 приводится дополненный файл urls.py.
```
```
Пример 11.13. Отображение адресов URL (urls.py)
from django.conf.urls.defaults import *
urlpatterns = patterns('',
# Пример:
# (r'^sysmanage/', include('sysmanage.foo.urls')),
```
```
# Раскомментируйте для включения административного интерфейса
(r'^admin/', include('django.contrib.admin.urls')),
(r'^$', 'sysmanage.inventory.views.main'),
(r'^categorized/(?P<category>.*?)/(?P<category_id>.*?)/$',
'sysmanage.inventory.views.categorized'),
(r'^server_detail/(?P<server_id>.*?)/$',
'sysmanage.inventory.views.server_detail'),
)
```
```
Мы добавили три новые строки для отображения трех адресов URL на
функции. Здесь нет ничего необычного по сравнению с приложением
просмотра файла журнала вебсервера Apache. Мы отобразили адреса
URL, соответствующие регулярным выражениям, на функции, при
этом мы использовали в регулярных выражениях именованную груп
пировку.
```
```
Рис. 11.9. Форма добавления аппаратного компонента
в административном интерфейсе Django
```

**422** Глава 11. Создание графического интерфейса

```
Следующее, что мы сделаем, это добавим в модуль views функции, ко
торые были объявлены в файле отображения адресов URL. В приме
ре 11.14 приводится содержимое модуля views.
```
```
Пример 11.14. Функции представления приложения инвентаризации
(views.py)
# Создайте здесь свои представления.
from django.shortcuts import render_to_response
import models
```
```
def main(request):
os_list = models.OperatingSystem.objects.all()
svc_list = models.Service.objects.all()
hardware_list = models.HardwareComponent.objects.all()
return render_to_response('main.html', {'os_list': os_list,
'svc_list': svc_list, 'hardware_list': hardware_list})
def categorized(request, category, category_id):
category_dict = {'os': 'Operating System',
'svc': 'Service', 'hw': 'Hardware'}
if category == 'os':
server_list = models.Server.objects.filter(os__exact=category_id)
category_name = models.OperatingSystem.objects.get(id=category_id)
elif category == 'svc':
server_list = \
models.Server.objects.filter(services__exact=category_id)
category_name = models.Service.objects.get(id=category_id)
elif category == 'hw':
server_list = \
models.Server.objects.filter(hardware_component__exact=category_id)
category_name = models.HardwareComponent.objects.get(id=category_id)
else:
server_list = []
return render_to_response('categorized.html', {'server_list': server_list,
'category': category_dict[category], 'category_name': category_name})
def server_detail(request, server_id):
server = models.Server.objects.get(id=server_id)
return render_to_response('server_detail.html', {'server': server})
```
```
В файл urls.py мы добавили три отображения адресов URL, поэтому
мы добавили три функции в файл views.py. Первая функция – main().
Она просто получает списки всех типов операционных систем, аппа
ратных компонентов и служб и передает их шаблону main.html.
В примере 11.6 мы уже создавали подкаталог templates в каталоге
приложения. Теперь сделаем то же самое и здесь:
jmjones@dinkbuntu:~/code/sysmanage/inventory$ mkdir templates
jmjones@dinkbuntu:~/code/sysmanage/inventory$
```
```
В примере 11.15 приводится содержимое шаблона «main.html», кото
рому функция main() передает данные для отображения.
```

Django **423**

```
Пример 11.15. Главный шаблон (main.html)
{% extends "base.html" %}
{% block title %}Server Inventory Category View{% endblock %}
{% block content %}
<div>
<h2>Operating Systems</h2>
<ul>
{% for o in os_list %}
<li><a href="/categorized/os/{{ o.id }}/" >{{ o.name }}</a></li>
{% endfor %}
</ul>
</div>
<div>
<h2>Services</h2>
<ul>
{% for s in svc_list %}
<li><a href="/categorized/svc/{{ s.id }}/" >{{ s.name }}</a></li>
{% endfor %}
</ul>
</div>
<div>
<h2>Hardware Components</h2>
<ul>
{% for h in hardware_list %}
<li>
<a href="/categorized/hw/{{ h.id }}/" >{{ h.manufacturer }}</a>
</li>
{% endfor %}
</ul>
</div>
{% endblock %}
```
```
Этот шаблон не содержит ничего сложного. Он делит страницу на три
части, по одной для каждой категории, которая должна отображаться.
В каждой категории выводится список элементов со ссылками, щел
кая на которых, можно получить список всех серверов, которые содер
жат указанный элемент.
Когда пользователь щелкает на одной из таких ссылок, вызывается
следующая функция представления categorized().
Главный шаблон передает функции представления categorized() кате
горию (os – в случае операционной системы, hw – в случае аппаратного
компонента и svc – в случае службы) и id категории (то есть конкрет
ный компонент, на котором был выполнен щелчок, например, «3Com
905b Network Card»). Функция categorized() принимает эти аргумен
ты и извлекает из базы данных список всех серверов, содержащих вы
бранный компонент. После запроса на получения информации из базы
данных функция categorized() передает полученные сведения шабло
```

**424** Глава 11. Создание графического интерфейса

```
ну «categorized.html». В примере 11.16 приводится содержимое шаб
лона «categorized.html».
```
```
Пример 11.16. Шаблон категории (categorized.html)
{% extends "base.html" %}
{% block title %}Server List{% endblock %}
{% block content %}
<h1>{{ category }}::{{ category_name }}</h1>
<div>
<ul>
{% for s in server_list %}
<li><a href="/server_detail/{{ s.id }}/" >{{ s.name }}</a></li>
{% endfor %}
</ul>
</div>
{% endblock %}
```
```
Шаблон «categorized.html» отображает список всех серверов, полу
ченный от функции categorized().
После этого пользователь может щелкнуть на выбранном сервере, что
приведет к вызову функции представления server_detail(). Функция
представления server_detail() принимает параметр с идентификато
ром (id) сервера, извлекает информацию о сервере из базы данных
и передает ее шаблону «server_detail.html».
Содержимое шаблона «server_detail.html» приводится в примере 11.17.
Это самый большой шаблон в приложении, но он очень простой. Его
задача заключается в том, чтобы отобразить отдельные элементы дан
ных для сервера, такие как тип операционной системы, под управле
нием которой работает сервер, установленные в нем аппаратные ком
поненты, службы, запущенные на сервере, и IPадреса, присвоенные
серверу.
```
```
Пример 11.17. Шаблон отображения информации о сервере (server_detail.html)
{% extends "base.html" %}
{% block title %}Server Detail{% endblock %}
```
```
{% block content %}
<div>
Name: {{ server.name }}
</div>
<div>
Description: {{ server.description }}
</div>
<div>
OS: {{ server.os.name }}
</div>
<div>
<div>Services:</div>
```

Django **425**

```
<ul>
{% for service in server.services.all %}
<li>{{ service.name }}</li>
{% endfor %}
</ul>
</div>
<div>
<div>Hardware:</div>
<ul>
{% for hw in server.hardware_component.all %}
<li>{{ hw.manufacturer }} {{ hw.type }} {{ hw.model }}</li>
{% endfor %}
</ul>
</div>
<div>
<div>IP Addresses:</div>
<ul>
{% for ip in server.ipaddress_set.all %}
<li>{{ ip.address }}</li>
{% endfor %}
</ul>
</div>
{% endblock %}
```
```
Этот пример показывает, как создать довольно простое приложение
базы данных, используя платформу Django. Административный ин
терфейс обеспечивает возможность наполнения базы данных, а доба
вив совсем немного строк программного кода, мы сумели создать соб
ственные представления, позволяющие сортировать данные и переме
щаться по ним, как показано на рис. 11.10, 11.11 и 11.12.
```
```
Рис. 11.10. Основная страница приложения управления системами
```

**426** Глава 11. Создание графического интерфейса

### В заключение.

```
Несмотря на то, что создание приложений с графическим интерфей
сом, как кажется многим, не соответствует традиционным обязанно
стям системного администратора, тем не менее, этот навык может ока
заться неоценимым. Иногда вам может даже потребоваться создать
какоенибудь простое приложение для одного из ваших пользовате
лей. Иногда вам может потребоваться создать приложение для само
го себя. Иногда вы можете склоняться к мысли, что в этом нет необхо>
димости , но такие приложения могут помочь выполнить ту или иную
задачу более гладко. Как только вы почувствуете, что создание прило
жений с графическим интерфейсом не вызывает у вас затруднений, вы
будете удивлены тем, как часто вы начали их создавать.
```
```
Рис. 11.11. Приложение управления системами – категория CentOS
```
```
Рис. 11.12. Приложение управления системами – информация о сервере
```
