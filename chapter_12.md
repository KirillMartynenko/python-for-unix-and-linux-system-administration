## Глава 12. Сохранность данных

Сохранность данных в простом, универсальном смысле – это сохране
ние данных для последующего использования. Этим подразумевается,
что данные, сохраненные для последующего использования, не пропа
дут, если процесс, сохранивший их, завершит свою работу. Обычно со
хранность данных достигается путем преобразования их в некоторый
формат и запись на диск. Некоторые форматы, такие как XML или
YAML, доступны человеку для чтения. Некоторые форматы, такие
как файлы базы данных Berkeley DB (bdb) или SQLite, не доступны
для непосредственного использования людьми.

Какие данные может потребоваться сохранять для последующего ис
пользования? Возможно, у вас имеется сценарий, который следит за
датой последнего изменения файлов в каталоге, и вам необходимо пе
риодически запускать его, чтобы узнать, какие файлы изменились
с момента последнего запуска. Информация о файлах – это именно те
данные, которые сохраняются для последующего использования, то
есть для следующего запуска сценария. Вы могли бы сохранять эти
данные в некотором файле. Представьте себе другой случай, когда
у вас имеется компьютер с подозрением на проблемы, возникающие
при работе с сетью, и вы решили запускать сценарий каждые 15 ми
нут, чтобы увидеть, насколько быстро он может опросить другие ком
пьютеры в сети. Вы могли бы сохранять время опроса в файле данных
для последующего использования. В этом случае «для последующего
использования» скорее относится ко времени, когда вы решите за
няться исследованием этих данных, а не ко времени, когда програм
ма, выполняющая сбор данных, обращается к ним.

Мы разобьем наше обсуждение сериализации данных на две катего
рии: простую и реляционную.

### Простая сериализация.

```
Существует несколько способов сохранения данных на диск для после
дующего использования. Процесс сохранения данных на диск без со
хранения отношений между частями данных мы называем «простой се
риализацией». Различия между простой и реляционной сериализацией
мы обсудим в разделе, описывающем реляционную сериализацию.
```
**Pickle**

```
Первый и, пожалуй, самый основной механизм «простой сериализа
ции» в языке Python представлен модулем pickle, входящим в состав
стандартной библиотеки языка. Если подумать о консервировании^1
в кулинарном смысле, идея обеспечения сохранности продуктов пита
ния состоит в том, чтобы законсервировать их в банке для последую
щего использования. Кулинарная концепция прекрасно укладывает
ся в образ действия модуля pickle. С помощью этого модуля вы можете
записать объект на диск, завершить работу программы, вернуться
позднее, снова запустить программу, прочитать объект с диска и про
должить взаимодействовать с ним.
Какими возможностями обладает модуль pickle? Ниже приводится
список, взятый из описания модуля pickle в документации к стандарт
ной библиотеке языка Python, где перечислены типы объектов, кото
рые могут сохраняться с его помощью:
```
**-** None, True и False
**-** Целые числа, длинные целые, числа с плавающей точкой, ком
    плексные числа
**-** Обычные строки и строки Юникода
**-** Кортежи, списки, множества и словари, содержащие только те объ
    екты, которые могут сохраняться с помощью модуля pickle
**-** Функции, определенные на верхнем уровне в модуле
**-** Встроенные функции, определенные на верхнем уровне в модуле
**-** Классы, определенные на верхнем уровне в модуле
**-** Экземпляры классов, у которых атрибуты __dict__ и __setstate__()
    могут сохраняться с помощью модуля pickle
Ниже показано, как выполняется сериализация объекта на диск с по
мощью модуля pickle:

```
In [1]: import pickle
In [2]: some_dict = {'a': 1, 'b': 2}
```
```
In [3]: pickle_file = open('some_dict.pkl', 'w')
```
(^1) Pickle – консервировать, мариновать, солить, заквашивать. – _Прим. перев._


Простая сериализация **429**

```
In [4]: pickle.dump(some_dict, pickle_file)
In [5]: pickle_file.close()
```
```
А вот как выглядит файл с сохраненными в нем данными:
jmjones@dinkgutsy:~$ lsl some_dict.pkl
rwrr 1 jmjones jmjones 30 20080120 07:13 some_dict.pkl
jmjones@dinkgutsy:~$ cat some_dict.pkl
(dp0
S'a'
p1
I1
sS'b'
p2
I2
```
```
Вы можете попытаться изучить формат файлов, создаваемых модулем
pickle, и создавать их вручную, но мы не рекомендуем делать это.
Ниже демонстрируется, как восстановить сохраненные ранее данные:
```
```
In [1]: import pickle
In [2]: pickle_file = open('some_dict.pkl', 'r')
```
```
In [3]: another_name_for_some_dict = pickle.load(pickle_file)
In [4]: another_name_for_some_dict
Out[4]: {'a': 1, 'b': 2}
```
```
Обратите внимание, что для восстановления данных мы использовали
объект, имя которого отличается от имени объекта, который сохра
нялся в файле. Не забывайте, что имя – это всего лишь способ сослать
ся на объект.
Интересно отметить, что совершенно необязательно, чтобы между
файлами и сохраняемыми объектами существовало отношение «один
к одному». Вы можете сохранять в одном и том же файле столько объ
ектов, сколько места хватит на жестком диске или в файловой систе
ме. Ниже приводится пример сохранения нескольких словарей в од
ном файле:
In [1]: list_of_dicts = [{str(i): i} for i in range(5)]
```
```
In [2]: list_of_dicts
Out[2]: [{'0': 0}, {'1': 1}, {'2': 2}, {'3': 3}, {'4': 4}]
In [3]: import pickle
In [4]: pickle_file = open('list_of_dicts.pkl', 'w')
In [5]: for d in list_of_dicts:
...: pickle.dump(d, pickle_file)
...:
...:
```
```
In [6]: pickle_file.close()
```

**430** Глава 12. Сохранность данных

```
Мы создали список словарей, объект файла, открытого в режиме для
записи, затем выполнили обход списка словарей и сериализовали ка
ждый из них в один и тот же файл. Обратите внимание, это тот же са
мый метод сохранения, который использовался выше для сохранения
одного объекта в файл, только там мы не выполняли итерации и не вы
зывали метод dump() несколько раз.
Ниже приводится пример восстановления объектов из файла, содер
жащего несколько объектов, и их вывод:
```
```
In [1]: import pickle
In [2]: pickle_file = open('list_of_dicts.pkl', 'r')
```
```
In [3]: while 1:
...: try:
...: print pickle.load(pickle_file)
...: except EOFError:
...: print "EOF Error"
...: break
...:
...:
{'0': 0}
{'1': 1}
{'2': 2}
{'3': 3}
{'4': 4}
EOF Error
```
```
Здесь мы создали объект файла, созданного в предыдущем примере,
открытого в режиме для чтения, и повторяли попытки загружать объ
екты из файла, пока не было возбуждено исключение EOFError. Как ви
дите, словари, полученные из файла, оказались теми же самыми
(и следуют в том же порядке), что и словари, которые мы записали
вфайл.
Но мало того, что мы можем сохранять объекты простых встроенных
типов, мы можем также сохранять объекты созданных нами типов.
Ниже приводится содержимое модуля, который мы будем использо
вать в двух следующих примерах. Этот модуль содержит определение
нашего собственного класса, экземпляры которого мы попробуем со
хранить, а потом восстановить:
```
```
#!/usr/bin/env python
class MyClass(object):
def __init__(self):
self.data = []
def __str__(self):
return "Custom Class MyClass Data:: %s" % str(self.data)
def add_item(self, item):
self.data.append(item)
```

Простая сериализация **431**

```
Следующий модуль импортирует модуль с нашим классом и сохраняет
экземпляр этого класса в файл с помощью модуля pickle:
```
```
#!/usr/bin/env python
import pickle
import custom_class
my_obj = custom_class.MyClass()
my_obj.add_item(1)
my_obj.add_item(2)
my_obj.add_item(3)
pickle_file = open('custom_class.pkl', 'w')
pickle.dump(my_obj, pickle_file)
pickle_file.close()
```
```
В этом примере мы импортировали модуль с нашим классом, создали
экземпляр этого класса, добавили в объект несколько элементов, за
тем сериализовали его. В процессе своей работы этот модуль ничего не
выводит.
Далее приводится модуль, который импортирует модуль с нашим
классом и затем загружает экземпляр этого класса из файла:
```
```
#!/usr/bin/env python
import pickle
import custom_class
pickle_file = open('custom_class.pkl', 'r')
my_obj = pickle.load(pickle_file)
print my_obj
pickle_file.close()
```
```
Ниже приводится вывод, полученный в ходе восстановления данных
из файла:
jmjones@dinkgutsy:~/code$ python custom_class_unpickle.py
Custom Class MyClass Data:: [1, 2, 3]
```
```
Для программного кода, выполняющего восстановление данных, со
вершенно необязательно явно импортировать наш класс. Однако код
должен иметь возможность отыскать модуль, в котором определяется
наш класс. Ниже приводится модуль, который не импортирует модуль
с определением класса:
```
```
#!/usr/bin/env python
import pickle
##import custom_class ##операция импортирования класса закомментирована
pickle_file = open('custom_class.pkl', 'r')
my_obj = pickle.load(pickle_file)
print my_obj
pickle_file.close()
```

**432** Глава 12. Сохранность данных

```
Ниже приводится вывод, полученный в результате запуска модуля,
который не импортирует класс:
```
```
jmjones@dinkgutsy:~/code$ python custom_class_unpickle_noimport.py
Custom Class MyClass Data:: [1, 2, 3]
```
```
А вот что было получено от того же самого модуля, после того как он
и файл с данными были скопированы в другой каталог, где он и был
запущен:
jmjones@dinkgutsy:~/code/cantfind$ python custom_class_unpickle_noimport.py
Traceback (most recent call last):
File "custom_class_unpickle_noimport.py", line 7, in <module>
my_obj = pickle.load(pickle_file)
File "/usr/lib/python2.5/pickle.py", line 1370, in load
return Unpickler(file).load()
File "/usr/lib/python2.5/pickle.py", line 858, in load
dispatch[key](self)
File "/usr/lib/python2.5/pickle.py", line 1090, in load_global
klass = self.find_class(module, name)
File "/usr/lib/python2.5/pickle.py", line 1124, in find_class
__import__(module)
ImportError: No module named custom_class
```
```
Последняя строка сообщает о неудачной попытке выполнить импорт,
потому что модуль pickle не смог загрузить наш модуль с определени
ем класса. Модуль pickle будет пытаться отыскать модуль, содержа
щий ваш класс, и импортировать его, чтобы иметь возможность вер
нуть объект того же типа, что и сохраненный в файле.
Все предыдущие примеры использования модуля pickle прекрасно ра
ботают, но существует еще один момент, о котором мы еще не упоми
нали. По умолчанию модуль pickle использует протокол сохранения
pickle.dump(object_to_pickle, pickle_file). Протокол – это специфика
ция формата записи в файл. Протокол по умолчанию использует фор
мат, практически доступный человеку для восприятия, как было по
казано выше. Другая разновидность протокола – это двоичный фор
мат. Вы можете предпочесть использовать двоичный формат, если за
метите, что операция сохранения ваших объектов начинает занимать
существенное время. Ниже приводится сравнение использования про
токола по умолчанию и двоичного протокола:
```
```
In [1]: import pickle
In [2]: default_pickle_file = open('default.pkl', 'w')
```
```
In [3]: binary_pickle_file = open('binary.pkl', 'wb')
In [4]: d = {'a': 1}
```
```
In [5]: pickle.dump(d, default_pickle_file)
In [6]: pickle.dump(d, binary_pickle_file,1)
```

Простая сериализация **433**

```
In [7]: default_pickle_file.close()
In [8]: binary_pickle_file.close()
```
```
Первый файл с данными, созданный нами (с именем default.pkl ), будет
содержать данные в формате по умолчанию, практически доступном
человеку для восприятия. Второй файл (с именем binary.pkl ) будет со
держать данные в двоичном формате. Обратите внимание, что мы от
крыли файл default.pkl в обычном режиме для записи ('w'), а файл
binary.pkl – в режиме записи двоичных данных ('wb'). Единственное
различие между двумя вызовами метода dump() заключается в том, что
при сохранении в двоичном формате методу передается один дополни
тельный аргумент: число – 1 , означающее, что будет использоваться
«высший» протокол, которым в настоящее время является двоичный
протокол.
Ниже приводится шестнадцатеричный дамп двоичного файла с дан
ными:
jmjones@dinkgutsy:~/code$ hexcat binary.pkl
00000000 80 02 7d 71 00 55 01 61 71 01 4b 01 73 2e ..}q.U.aq.K.s.
```
```
А так выглядит шестнадцатеричный дамп файла с данными, сохра
ненными при использовании протокола по умолчанию:
jmjones@dinkgutsy:~/code$ hexcat default.pkl
00000000 28 64 70 30 0a 53 27 61 27 0a 70 31 0a 49 31 0a (dp0.S'a'.p1.I1.
00000010 73 2e s.
```
```
В этом просмотре дампа нет никакой необходимости, потому что мы
можем воспользоваться простой утилитой cat, чтобы прочитать содер
жимое файла с данными, сохраненными при использовании протоко
ла по умолчанию:
```
```
jmjones@dinkgutsy:~/code$ cat default.pkl
(dp0
S'a'
p1
I1
s.
```
**cPickle**

```
В стандартной библиотеке языка Python присутствует еще одна реали
зация библиотеки Pickle, которая стоит того, чтобы вы обратили на нее
внимание. Она называется cPickle. Как явствует из имени, библиотека
cPickle реализована на языке C. Ранее мы уже предлагали применять
двоичный формат в случаях, когда вы начнете замечать, что на сохра
нение объектов требуется существенное время. В этом же случае можно
попробовать использовать модуль cPickle. Интерфейс модуля cPickle
в точности соответствует интерфейсу «обычного» модуля pickle.
```

**434** Глава 12. Сохранность данных

**shelve**

```
Еще одну возможность сохранения данных предоставляет модуль
shelve. Модуль shelve имеет простой и удобный интерфейс, упрощаю
щий возможность сохранения множества объектов. Под этим подразу
мевается возможность сохранения множества объектов в одном и том
же объектехранилище и простого их восстановления из хранилища.
Сохранение объектов в хранилище shelve напоминает использование
словаря в языке Python. Ниже приводится пример, в котором откры
вается хранилище, в него записываются данные, затем хранилище по
вторно открывается и из него извлекаются сохраненные данные:
```
```
In [1]: import shelve
In [2]: d = shelve.open('example.s')
```
```
In [3]: d
Out[3]: {}
```
```
In [4]: d['key'] = 'some value'
In [5]: d.close()
```
```
In [6]: d2 = shelve.open('example.s')
In [7]: d2
Out[7]: {'key': 'some value'}
```
```
Единственное отличие между использованием shelve и простого слова
ря состоит в том, что объект shelve создается с помощью метода
shelve.open(), а не путем создания экземпляра класса dict или с помо
щью фигурных скобок ({}). Еще одно отличие состоит в том, что при
использовании shelve по завершении работы с данными необходимо
вызывать метод close() объекта shelve.
У объекта shelve имеется пара особенностей. О первой из них мы уже
упоминали: по завершении работы с данными необходимо вызывать
метод close(). Если этого не сделать, то любые изменения, которые бы
ли сделаны в объекте shelve, не будут сохранены. Ниже приводится
пример потери данных изза того, что объект shelve не закрывается.
Для начала нам нужно создать объект shelve, сохранить в нем данные
и выйти из оболочки IPython:
```
```
In [1]: import shelve
In [2]: d = shelve.open('lossy.s')
```
```
In [3]: d['key'] = 'this is a key that will persist'
In [4]: d
Out[4]: {'key': 'this is a key that will persist'}
In [5]: d.close()
```
```
In [6]:
Do you really want to exit ([y]/n)?
```

Простая сериализация **435**

```
Теперь снова запустим IPython, откроем тот же файл хранилища, соз
дадим в нем еще один элемент и выйдем, не закрыв объект shelve:
```
```
In [1]: import shelve
In [2]: d = shelve.open('lossy.s')
In [3]: d
Out[3]: {'key': 'this is a key that will persist'}
In [4]: d['another_key'] = 'this is an entry that will not persist'
In [5]:
Do you really want to exit ([y]/n)?
```
```
Теперь снова запустим оболочку IPython, откроем все тот же файл хра
нилища и посмотрим, что в нем имеется:
In [1]: import shelve
In [2]: d = shelve.open('lossy.s')
In [3]: d
Out[3]: {'key': 'this is a key that will persist'}
```
```
Итак, необходимо вызывать метод close() для всех объектов shelve, со
держимое которых вы меняете, и которые вам хотелось бы сохранить.
Другая особенность касается изменяемых объектов. Запомните, что
изменяемыми объектами называются такие объекты, значение кото
рых можно изменять без повторного присваивания этого значения пе
ременной. Ниже мы создаем объект shelve, добавляем в него элемент,
который представляет собой изменяемый объект (в данном случае –
список), модифицируем изменяемый объект, а затем закрываем объ
ект shelve:
```
```
In [1]: import shelve
In [2]: d = shelve.open('mutable_lossy.s')
In [3]: d['key'] = []
In [4]: d['key'].append(1)
In [5]: d.close()
In [6]:
Do you really want to exit ([y]/n)?
```
```
Поскольку в этом случае вызывается метод close() объекта shelve,
можно было бы ожидать, что значением ключа 'key' будет список [1].
Но это не так. Ниже приводится результат попытки открыть файл хра
нилища, созданного выше, и прочитать из него данные:
In [1]: import shelve
```
```
In [2]: d = shelve.open('mutable_lossy.s')
In [3]: d
Out[3]: {'key': []}
```

**436** Глава 12. Сохранность данных

```
В таком поведении нет ничего странного или неожиданного. В действи
тельности эта особенность shelve описана в документации. Проблема
состоит в том, что модификация сохраняемых изменяемых объектов
не воспринимаются по умолчанию. Однако существует пара способов,
позволяющих обойти этот недостаток. Первый из них специализиро
ванный и узконаправленный, второй – широкий и всеобъемлющий.
Первый, специализированный, подход заключается в том, чтобы про
сто выполнить повторное присваивание по ключу в объекте shelve, как
показано ниже:
In [1]: import shelve
```
```
In [2]: d = shelve.open('mutable_nonlossy.s')
In [3]: d['key'] = []
```
```
In [4]: temp_list = d['key']
In [5]: temp_list.append(1)
```
```
In [6]: d['key'] = temp_list
In [7]: d.close()
```
```
In [8]:
Do you really want to exit ([y]/n)?
```
```
При попытке восстановить сохраненный ранее объект мы получили
следующее:
```
```
In [1]: import shelve
In [2]: d = shelve.open('mutable_nonlossy.s')
In [3]: d
Out[3]: {'key': [1]}
```
```
Список, к которому был добавлен элемент, сохранился.
Второй, широкий и всеобъемлющий подход заключается в изменении
флага writeback объекта shelve. До сих пор мы демонстрировали вызов
метода shelve.open() с единственным параметром – именем файла хра
нилища. Но этот метод может принимать еще и другие параметры, од
ним из которых является флаг writeback. Если во флаге writeback пере
дано значение True, все записи в объекте shelve, к которым выполня
лось обращение, кэшируются в памяти и затем сохраняются при вызо
ве метода close(). Этот прием может оказаться удобным при работе
с изменяемыми объектами, но за это приходится платить. Поскольку
все объекты, к которым производилось обращение, кэшируются и за
тем сохраняются при закрытии объекта (независимо от того, изменя
лись они или нет), объем используемой памяти и время на запись
в файл будут расти пропорционально числу объектов в хранилище,
к которым производился доступ. Поэтому, если у вас имеется большое
число объектов в хранилище, к которым приходится обращаться, то
лучше не устанавливать флаг writeback в значение True.
```

Простая сериализация **437**

```
В следующем примере мы устанавливаем во флаге writeback значение
True и модифицируем содержимое списка, не выполняя повторное его
присваивание ключу в объекте shelve:
In [1]: import shelve
```
```
In [2]: d = shelve.open('mutable_nonlossy.s', writeback=True)
In [3]: d['key'] = []
```
```
In [4]: d['key'].append(1)
In [5]: d.close()
```
```
In [6]:
Do you really want to exit ([y]/n)?
```
```
А теперь проверим, сохранились ли наши изменения:
In [1]: import shelve
```
```
In [2]: d = shelve.open('mutable_nonlossy.s')
In [3]: d
Out[3]: {'key': [1]}
```
```
Как мы и надеялись, изменения были сохранены.
Модуль shelve предлагает простой способ сохранения данных. В нем
имеется пара недостатков, но в целом это очень полезный модуль.
```
**YAML**

```
В зависимости от того, кому задается вопрос, вы можете услышать раз
ные толкования аббревиатуры YAML, например: «YAML ain’t markup
language» (YAML – это не язык разметки) или «yet another markup
language» (еще один язык разметки). В любом случае – это формат
данных, который часто используется для сохранения, восстановления
и обновления данных в виде простого текста. Эти данные часто имеют
иерархическую структуру. Самый простой, пожалуй, способ присту
пить к работе с YAML в языке Python состоит в том, чтобы установить
с помощью утилиты easy_install пакет PyYAML. Но зачем нам использо
вать YAML, который еще требуется устанавливать, когда у нас имеет
ся встроенный модуль pickle? Существуют две основные причины, по
которым YAML оказывается предпочтительнее, чем pickle. Эти две
причины не делают применение YAML наилучшим во всех ситуациях,
но при определенных обстоятельствах они приобретают особую значи
мость. Вопервых, формат YAML пригоден для восприятия человеком.
Его синтаксис напоминает синтаксис конфигурационных файлов. Ес
ли у вас возникают ситуации, когда необходимо предоставить возмож
ность редактирования конфигурационных файлов, YAML будет отлич
ным выбором. Вовторых, синтаксические анализаторы языка YAML
реализованы во многих других языках. Если вам требуется обеспечить
обмен данными между приложением на языке Python и приложением,
```

**438** Глава 12. Сохранность данных

```
написанном на другом языке программирования, YAML может стать
неплохим решением проблемы.
После установки PyYAML вы получаете возможность сохранять и восста
навливать данные в формате YAML. Ниже приводится пример сохра
нения простого словаря:
In [1]: import yaml
```
```
In [2]: yaml_file = open('test.yaml', 'w')
In [3]: d = {'foo': 'a', 'bar': 'b', 'bam': [1, 2,3]}
```
```
In [4]: yaml.dump(d, yaml_file, default_flow_style=False)
In [5]: yaml_file.close()
```
```
Этот пример достаточно прост, чтобы вы могли разобраться в нем са
мостоятельно, и, тем не менее, мы рассмотрим его. Первое, что здесь
делается, – выполняется импортирование модуля YAML (с именем
yaml). Затем открывается файл в режиме для записи, который будет ис
пользоваться для сохранения данных. Далее создается словарь (с име
нем d), содержащий данные, которые требуется сохранить. После это
го мы сохраняем словарь (с именем d) с помощью функции dump() из
модуля yaml. В качестве параметров функции dump() передаются: сло
варь, который требуется сохранить, выходной файл и параметр, сооб
щающий библиотеке YAML, что запись должна производиться в блоч
ном стиле, а не в стиле, заданном по умолчанию, который отчасти на
поминает преобразование сохраняемого объекта данных в строку.
Ниже показано, как выглядит содержимое файла с данными в форма
те YAML:
```
```
jmjones@dinkgutsy:~/code$ cat test.yaml
bam:
1
2
3
bar: b
foo: a
```
```
Когда необходимо восстановить данные, мы выполняем операции, об
ратные тем, что выполнялись в примере с применением функции
dump(). Ниже показано, как получить данные из файла YAML:
```
```
In [1]: import yaml
In [2]: yaml_file = open('test.yaml', 'r')
```
```
In [3]: yaml.load(yaml_file)
Out[3]: {'bam': [1, 2, 3], 'bar': 'b', 'foo': 'a'}
```
```
Как и в примере с функцией dump(), мы сначала импортируем модуль
поддержки языка YAML (yaml). Затем создаем объект файла. На этот
раз мы открываем файл на диске в режиме для чтения. Наконец вызы
```

Простая сериализация **439**

```
вается функция load() из модуля yaml. Функция load() возвращает сло
варь, эквивалентный исходному словарю.
Вы наверняка поймаете себя на том, что при использовании модуля
yaml вы реализуете цикл создания данных, сохранения их на диске, за
тем восстановления с диска и так далее.
Возможно, вам не обязательно сохранять свои данные в формате, дос
тупном для восприятия человеком, поэтому попробуем сохранить сло
варь из предыдущего примера не в блочном режиме. Ниже показано,
как сохранить тот же самый словарь не в блочном режиме:
In [1]: import yaml
```
```
In [2]: yaml_file = open('nonblock.yaml', 'w')
In [3]: d = {'foo': 'a', 'bar': 'b', 'bam': [1, 2,3]}
```
```
In [4]: yaml.dump(d, yaml_file)
In [5]: yaml_file.close()
```
```
Вот как выглядит содержимое файла с данными в формате YAML:
jmjones@dinkgutsy:~/code$ cat nonblock.yaml
bam: [1, 2, 3]
bar: b
foo: a
```
```
Очень похоже на содержимое файла, записанного в блочном режиме,
за исключением списка значений переменной bam. Различия между
этими режимами начинают проявляться с появлением дополнитель
ных уровней вложенности и структур данных, напоминающих масси
вы, таких как списки и словари. Рассмотрим пару примеров, чтобы
увидеть различия. Но прежде заметим, что исследовать примеры будет
проще, если отказаться от просмотра YAMLфайлов с помощью утили
ты cat. Аргумент с файлом в функции dump() из модуля yaml является
необязательным. (Фактически в документации к PyYAML объект типа
«file» называется «stream» (поток), но в действительности большой ро
ли это не играет.) Если функция dump() не получит аргумент с файлом
(или «потоком»), она выведет сериализованный объект в поток стан
дартного вывода. Поэтому в следующем примере мы опустили аргу
мент с объектом типа file и выводим результат работы функции.
Ниже сравниваются некоторые структуры данных, которые сериали
зуются в блочном и в не блочном режимах. В примерах, где присутст
вует аргумент default_flow_style, используется блочный режим форма
тирования, а в примерах, где аргумент default_flow_style отсутствует,
используется не блочный режим форматирования:
```
```
In [1]: import yaml
In [2]: d = {'first': {'second': {'third': {'fourth': 'a'}}}}
```
```
In [3]: print yaml.dump(d, default_flow_style=False)
```

**440** Глава 12. Сохранность данных

```
first:
second:
third:
fourth: a
```
```
In [4]: print yaml.dump(d)
first:
second:
third: {fourth: a}
```
```
In [5]: d2 = [{'a': 'a'}, {'b': 'b'}, {'c': 'c'}]
In [6]: print yaml.dump(d2, default_flow_style=False)
a: a
b: b
c: c
In [7]: print yaml.dump(d2)
{a: a}
{b: b}
{c: c}
In [8]: d3 = [{'a': 'a'}, {'b': 'b'}, {'c': [1, 2, 3, 4, 5]}]
```
```
In [9]: print yaml.dump(d3, default_flow_style=False)
a: a
b: b
c:
1
2
3
4
5
In [10]: print yaml.dump(d3)
{a: a}
{b: b}
c: [1, 2, 3, 4, 5]
```
```
А если нам потребуется сериализовать наш собственный класс? В этом
случае модуль yaml ведет себя практически точно так же, как и модуль
pickle. В следующем примере используется тот же самый модуль
custom_class, который использовался в примере с модулем pickle.
Ниже приводится содержимое модуля, который импортирует модуль
custom_class, создает экземпляр класса MyClass, добавляет несколько
элементов в объект и затем сериализует его:
```
```
#!/usr/bin/env python
import yaml
import custom_class
my_obj = custom_class.MyClass()
my_obj.add_item(1)
my_obj.add_item(2)
```

Простая сериализация **441**

```
my_obj.add_item(3)
yaml_file = open('custom_class.yaml', 'w')
yaml.dump(my_obj, yaml_file)
yaml_file.close()
```
```
Когда мы запустили этот модуль, получили следующий вывод:
jmjones@dinkgutsy:~/code$ python custom_class_yaml.py
jmjones@dinkgutsy:~/code$
```
```
То есть ничего. Это означает, что все идет так, как надо.
Ниже приводится модуль, обратный предыдущему:
#!/usr/bin/env python
```
```
import yaml
import custom_class
```
```
yaml_file = open('custom_class.yaml', 'r')
my_obj = yaml.load(yaml_file)
print my_obj
yaml_file.close()
```
```
Этот сценарий импортирует модули yaml и custom_class, создает объект
файла для чтения данных из файла, созданного предыдущим сценари
ем, загружает объект из файла и выводит его.
Когда мы запустили этот сценарий, то получили следующее:
```
```
jmjones@dinkgutsy:~/code$ python custom_class_unyaml.py
Custom Class MyClass Data:: [1, 2, 3]
```
```
Точно такой же результат мы получили в примере, использующем мо
дуль pickle, демонстрировавшемся ранее в этой главе, откуда следует,
что модуль yaml проявляет именно такое поведение, какое мы и пред
полагали увидеть.
```
**ZODB**

```
Еще один способ сериализации данных основан на применении моду
ля ZODB. ZODB означает «Zope Object Database» (объектная база дан
ных Zope). В простейших случаях использование ZODB напоминает
сериализацию с помощью модуля pickle или yaml, но ZODB обладает
возможностью расти вместе с вашими потребностями. Например,
ZODB предоставляет механизм транзакций – на случай, если вам по
требуется обеспечить атомарность своих операций. А если вам потре
буется легко масштабируемое решение, вы можете использовать ZEO,
систему распределенного хранения объектов.
База данных ZODB имела все шансы попасть не в раздел, описываю
щий «простую сериализацию», а в раздел, где рассказывается о «реля
ционной сериализации». Однако эта объектная база данных не совсем
точно соответствует тому, что мы привыкли называть реляционными
```

**442** Глава 12. Сохранность данных

```
базами данных, хотя вы без труда можете устанавливать отношения
между объектами. Кроме того, мы продемонстрируем лишь некоторые
из наиболее основных возможностей ZODB, поэтому в наших приме
рах она больше напоминает модуль shelve, чем реляционную базу дан
ных. Поэтому мы и решили оставить ZODB в разделе, рассказываю
щем о «простой сериализации».
Установка ZODB выполняется просто – достаточно запустить команду
easy_install ZODB3. Модуль ZODB имеет ряд зависимостей, но утилита
easy_install благополучно разрешит их, и загрузит и установит все,
что необходимо.
Для примера простейшего использования ZODB создадим объектхра
нилище ZODB и добавим в него словарь и список. Ниже приводится
программный код, выполняющий сериализацию словаря и списка:
#!/usr/bin/env python
```
```
import ZODB
import ZODB.FileStorage
import transaction
filestorage = ZODB.FileStorage.FileStorage('zodb_filestorage.db')
db = ZODB.DB(filestorage)
conn = db.open()
```
```
root = conn.root()
root['list'] = ['this', 'is', 'a', 'list']
root['dict'] = {'this': 'is', 'a': 'dictionary'}
transaction.commit()
conn.close()
```
```
По сравнению с pickle или YAML для инициализации работы с ZODB
требуется написать на пару строк программного кода больше, но как
только хранилище будет создано и инициализировано, оно использует
ся ничуть не сложнее других альтернатив. Этот пример достаточно оче
виден, особенно если учесть, что мы уже рассматривали другие приме
ры сохранения данных. И, тем не менее, мы быстро пройдемся по нему.
Вопервых, мы импортируем несколько модулей ZODB, а именно ZODB,
ZODB.FileStorage и transaction. (Мы хотели бы здесь сделать небольшое
замечание. Импортирование модуля, в имени которого отсутствует
идентификационный префикс, выглядит несколько странно. Создается
впечатление, что импортируемый модуль transaction должен иметь пре
фикс ZODB. Но как бы то ни было, имя модуля такое, какое есть, и вам
просто достаточно знать об этом. А теперь можно двигаться дальше.)
Затем создается объект FileStorage, которому указывается имя файла,
который будет использоваться как база данных. Затем создается объ
ект DB и подключается к объекту FileStorage. Затем объект базы дан
ных открывается с помощью метода open() и обретается ссылка на кор
невой узел объекта. С этого момента мы можем добавлять в корень
```

Простая сериализация **443**

```
объекта свои структуры данных, что мы и делаем, используя импрови
зированные список и словарь. После этого мы подтверждаем измене
ния с помощью функции transaction.commit() и затем закрываем соеди
нение с базой данных вызовом метода conn.close().
Как только будет создан контейнер хранилища данных (как объект
файла хранилища в этом примере) и запись данных будет подтвержде
на, у вас может появиться потребность восстановить эти данные.
В следующем примере мы открываем ту же самую базу данных, но на
этот раз мы читаем данные из файла, а не записываем в него:
#!/usr/bin/env python
```
```
import ZODB
import ZODB.FileStorage
```
```
filestorage = ZODB.FileStorage.FileStorage('zodb_filestorage.db')
db = ZODB.DB(filestorage)
conn = db.open()
root = conn.root()
print root.items()
conn.close()
```
```
И если запустить этот сценарий после того, как база данных будет на
полнена, мы могли бы увидеть следующее:
```
```
jmjones@dinkgutsy:~/code$ python zodb_read.py
No handlers could be found for logger "ZODB.FileStorage"
[('list', ['this', 'is', 'a', 'list']), ('dict', {'this': 'is', 'a':
'dictionary'})]
```
```
При описании других механизмов сохранения данных мы рассматри
вали примеры сериализации своих собственных классов, поэтому мы
покажем, как то же самое делается с помощью ZODB. Однако на этот
раз мы не будем использовать тот же самый класс MyClass (позднее объ
ясним, почему). Как и при использовании других механизмов, мы
просто объявим свой класс, создадим экземпляр этого класса и затем
передадим его механизму сериализации для сохранения на диске. Ни
же приводится определение класса, который мы будем использовать
в этот раз:
#!/usr/bin/env python
```
```
import persistent
class OutOfFunds(Exception):
pass
class Account(persistent.Persistent):
def __init__(self, name, starting_balance=0):
self.name = name
self.balance = starting_balance
def __str__(self):
```

**444** Глава 12. Сохранность данных

```
return "Account %s, balance %s" % (self.name, self.balance)
def __repr__(self):
return "Account %s, balance %s" % (self.name, self.balance)
def deposit(self, amount):
self.balance += amount
return self.balance
def withdraw(self, amount):
if amount > self.balance:
raise OutOfFunds
self.balance= amount
return self.balance
```
```
Это очень простой класс, имитирующий банковский счет и предназна
ченный для управления денежными средствами. Мы также определи
ли исключение OutOfFunds, назначение которого объясним позже.
Класс Account наследует класс persistent.Persistent. (Что касается мо
дуля persistent, мы опять могли бы сделать высокопарное отступление
об уместности значимого префикса в имени модуля, который предпо
лагается использовать. Как при беглом знакомстве с этим программ
ным кодом определить, что он использует ZODB? Никак. Но не будем хо
дить по кругу.) Наследование от класса persistent.Persistent позволяет
задействовать скрытые механизмы и облегчает для ZODB сериализа
цию этих данных. В определении класса мы создали собственные реа
лизации методов преобразования класса в строковую форму __str__
и__repr__. Позднее вы увидите их в действии. Мы также создали мето
ды deposit() и withdraw(). Оба метода изменяют атрибут balance объекта
в сторону увеличения или уменьшения, в зависимости от того, какой
метод вызывается. Метод withdraw() проверяет, достаточно ли денег на
балансе (в атрибуте balance), прежде чем списать запрошенную сумму.
Если денег недостаточно, метод withdraw() возбуждает исключение
OutOfFunds, упоминавшееся выше. Оба метода, deposit() и withdraw(),
возвращают остаток средств на счете после выполнения операции.
Ниже приводится программный код, который сохраняет только что
описанный класс:
#!/usr/bin/env python
```
```
import ZODB
import ZODB.FileStorage
import transaction
import custom_class_zodb
```
```
filestorage = ZODB.FileStorage.FileStorage('zodb_filestorage.db')
db = ZODB.DB(filestorage)
conn = db.open()
root = conn.root()
noah = custom_class_zodb.Account('noah', 1000)
print noah
root['noah'] = noah
jeremy = custom_class_zodb.Account('jeremy', 1000)
```

Простая сериализация **445**

```
print jeremy
root['jeremy'] = jeremy
```
```
transaction.commit()
conn.close()
```
```
Этот пример практически идентичен предыдущему примеру использо
вания ZODB, где мы сохраняли словарь и список. Только здесь мы им
портируем свой собственный модуль, создаем два экземпляра нашего
класса и сохраняем эти два объекта в базе данных ZODB. Эти два объ
екта – счет noah и счет jeremy, каждый из которых имеет на балансе
1000 (предположим, $1000.00, но мы не идентифицировали, в какой
валюте исчисляется сумма на счете).
Ниже приводится результат работы этого примера:
```
```
jmjones@dinkgutsy:~/code$ python zodb_custom_class.py
Account noah, balance 1000
Account jeremy, balance 1000
```
```
А если запустить модуль, отображающий содержимое базы данных
ZODB, вот, что мы получим:
jmjones@dinkgutsy:~/code$ python zodb_read.py
No handlers could be found for logger "ZODB.FileStorage"
[('jeremy', Account jeremy, balance 1000), ('noah', Account noah, balance
1000)]
```
```
Наш пример не только создал два объекта, как ожидалось, но и сохра
нил их на диск для последующего использования.
А как нам открыть базу данных и изменить суммы на счетах? Все на
ши усилия были бы бессмысленны, не будь такой возможности. Ниже
приводится фрагмент, открывающий базу данных, созданную ранее,
и выполняющий перевод 300 (повидимому, долларов) со счета noah на
счет jeremy:
```
```
#!/usr/bin/env python
import ZODB
import ZODB.FileStorage
import transaction
import custom_class_zodb
filestorage = ZODB.FileStorage.FileStorage('zodb_filestorage.db')
db = ZODB.DB(filestorage)
conn = db.open()
```
```
root = conn.root()
noah = root['noah']
print "BEFORE WITHDRAWAL"
print "================="
print noah
jeremy = root['jeremy']
print jeremy
```

**446** Глава 12. Сохранность данных

```
print ""
transaction.begin()
noah.withdraw(300)
jeremy.deposit(300)
transaction.commit()
print "AFTER WITHDRAWAL"
print "================"
print noah
print jeremy
print ""
```
```
conn.close()
```
```
Ниже приводятся результаты работы этого сценария:
```
```
jmjones@dinkgutsy:~/code$ python zodb_withdraw_1.py
BEFORE WITHDRAWAL
=================
Account noah, balance 1000
Account jeremy, balance 1000
```
```
AFTER WITHDRAWAL
================
Account noah, balance 700
Account jeremy, balance 1300
```
```
А если запустить наш сценарий, отображающий содержимое базы дан
ных ZODB, то увидим, что данные сохранились:
jmjones@dinkgutsy:~/code$ python zodb_read.py
[('jeremy', Account jeremy, balance 1300), ('noah', Account noah, balance
700)]
```
```
Сумма на счете noah уменьшилась с 1000 до 700, а сумма на счете jeremy
увеличилась с 1000 до 1300.
Причина, по которой мы отказались от использования класса MyClass,
состоит в том, что нам хотелось продемонстрировать работу с транзак
циями. Один из классических способов сделать это – продемонстриро
вать их использование при работе с банковскими счетами. Если вам
требуется гарантировать благополучный перевод средств с одного сче
та на другой без потери средств, то транзакции будут первым инстру
ментом, на который стоит обратить внимание. Ниже приводится при
мер, где используются транзакции в цикле и показано, что деньги ни
куда не пропадают:
#!/usr/bin/env python
```
```
import ZODB
import ZODB.FileStorage
import transaction
import custom_class_zodb
```

Простая сериализация **447**

```
filestorage = ZODB.FileStorage.FileStorage('zodb_filestorage.db')
db = ZODB.DB(filestorage)
conn = db.open()
root = conn.root()
noah = root['noah']
print "BEFORE TRANSFER"
print "==============="
print noah
jeremy = root['jeremy']
print jeremy
print ""
while True:
try:
transaction.begin()
jeremy.deposit(300)
noah.withdraw(300)
transaction.commit()
except custom_class_zodb.OutOfFunds:
print "OutOfFunds Error"
print "Current account information:"
print noah
print jeremy
transaction.abort()
break
```
```
print "AFTER TRANSFER"
print "=============="
print noah
print jeremy
print ""
conn.close()
```
```
Это некоторая модификация предыдущего примера сценария, выпол
няющего перевод средств. Только на этот раз вместо одного перевода он
выполняет переводы по 300 единиц со счета noah на счет jeremy, пока на
счету noah не окажется недостаточно средств для перевода. В момент,
когда на счету оказывается недостаточно средств, сценарий выводит
сообщение о том, что возникло исключение, и информацию о текущем
состоянии счетов. После этого вызывается метод abort() транзакции
и выполнение цикла прерывается. Кроме того, сценарий выводит ин
формацию до и после цикла транзакций. Пока транзакции совершают
ся, и до и после операции общий объем средств на счетах составляет
2000, поскольку изначально на каждом счете имелась сумма 1000.
Ниже приводится результат запуска этого сценария:
```
```
jmjones@dinkgutsy:~/code$ python zodb_withdraw_2.py
BEFORE TRANSFER
===============
Account noah, balance 700
```

**448** Глава 12. Сохранность данных

```
Account jeremy, balance 1300
```
```
OutOfFunds Error
Current account information:
Account noah, balance 100
Account jeremy, balance 2200
AFTER TRANSFER
==============
Account noah, balance 100
Account jeremy, balance 1900
```
```
Перед началом цикла переводов на счете noah имелась сумма 700 еди
ниц и на счете jeremy – 1300 единиц, итого 2000. Когда возникло исклю
чение OutOfFunds, на счете noah имелось 100 единиц и на счете jeremy –
2200, итого 2300. В блоке «AFTER TRANSFER» (после перевода) на
счете noah осталось 100 единиц и на счете jeremy – 1900, итого 2000.
Итак, когда возникло исключение, перед тем как был вызван метод
transaction.abort(), имелись лишние 300 единиц, появление которых
невозможно было бы объяснить. Но прерывание транзакции ликвиди
ровало эту проблему.
База данных ZODB представляет собой решение, занимающее проме
жуточное положение между простыми и реляционными инструмента
ми. Она проста в использовании. Объект, сохраняемый на диске, соот
ветствует объекту в памяти как до сохранения, так и после восстанов
ления. Но у этого инструмента имеются такие дополнительные особен
ности, как транзакции. База данных ZODB стоит того, чтобы на нее
обратили внимание, когда изначально требуется достаточно простой
механизм отображения объектов, расширенные возможности которо
го могут потребоваться позже.
В заключение раздела о простой сериализации: иногда все, что вам
требуется, – это просто сохранять и восстанавливать объекты Python.
Все инструменты, которые мы рассмотрели здесь, прекрасно справля
ются с этой задачей. У каждого из них есть свои сильные и слабые сто
роны. Когда возникнет такая необходимость, вы сможете заняться ис
следованием и выяснить, какой из инструментов лучше подходит для
вас и вашего проекта.
```
### Реляционная сериализация

```
Иногда простой сериализации бывает недостаточно. Иногда возникает
потребность в использовании мощи реляционного анализа. Под реля
ционной сериализацией подразумевается либо сохранение объектов
Python вместе с информацией об их отношениях с другими объектами
Python, либо сохранение реляционных данных (например, в реляци
онной базе данных) и предоставление объектного интерфейса к этим
данным.
```

Реляционная сериализация **449**

**SQLite**

```
Иногда полезно сохранять и работать с данными более структуриро
ванным способом, с учетом отношений между ними. Здесь мы будем
говорить о семействе инструментов хранения информации, которые
называются реляционными базами данных, или СУРБД (системы
управления реляционными базами данных). Мы полагаем, что ранее
вам уже приходилось использовать такие реляционные базы данных,
как MySQL, PostgreSQL или Oracle. Если это так, у вас не должно воз
никать проблем при чтении этого раздела.
Согласно информации, что приводится на вебсайте, SQLite – «это биб
лиотека программного обеспечения, реализующая самодостаточный,
безсерверный, не требующий настройки механизм базы данных SQL
с поддержкой транзакций». Что все это означает? Этот механизм базы
данных работает не в виде отдельного процесса на сервере, а в том же
самом процессе, что и ваш программный код, и вы можете обращаться
к нему как к библиотеке. Данные находятся в файле, а не во множестве
каталогов, разбросанных по нескольким файловым системам. И вме
сто того, чтобы настраивать имя хоста, номер порта, имя пользователя,
пароль и так далее, для организации доступа к данным вы просто ука
зываете в своем программном коде имя файла базы данных, созданно
го библиотекой SQLite. Это предложение также означает, что SQLite
является базой данных с достаточно широкими возможностями. Про
ще говоря, это предложение указывает на два главных преимущества
SQLite: простота в использовании и обладание возможностями, прису
щими «настоящим» базам данных. Еще одно преимущество состоит
в ее распространенности. Поддержка SQLite обеспечивается большин
ством языков программирования в большинстве основных операцион
ных систем.
Теперь, когда вы знаете причины, которые могут побудить к использо
ванию этой базы данных, посмотрим, как ею пользоваться. Мы взяли
следующие определения таблиц из примера, где использовалась плат
форма Django в главе 11. Предположим, что у нас имеется файл с име
нем inventory.sql , содержащий следующий текст:
BEGIN;
CREATE TABLE "inventory_ipaddress" (
"id" integer NOT NULL PRIMARY KEY,
"address" text NULL,
"server_id" integer NOT NULL
)
;
CREATE TABLE "inventory_hardwarecomponent" (
"id" integer NOT NULL PRIMARY KEY,
"manufacturer" varchar(50) NOT NULL,
"type" varchar(50) NOT NULL,
"model" varchar(50) NULL,
"vendor_part_number" varchar(50) NULL,
```

**450** Глава 12. Сохранность данных

```
"description" text NULL
)
;
CREATE TABLE "inventory_operatingsystem" (
"id" integer NOT NULL PRIMARY KEY,
"name" varchar(50) NOT NULL,
"description" text NULL
)
;
CREATE TABLE "inventory_service" (
"id" integer NOT NULL PRIMARY KEY,
"name" varchar(50) NOT NULL,
"description" text NULL
)
;
CREATE TABLE "inventory_server" (
"id" integer NOT NULL PRIMARY KEY,
"name" varchar(50) NOT NULL,
"description" text NULL,
"os_id" integer NOT NULL REFERENCES "inventory_operatingsystem" ("id")
)
;
CREATE TABLE "inventory_server_services" (
"id" integer NOT NULL PRIMARY KEY,
"server_id" integer NOT NULL REFERENCES "inventory_server" ("id"),
"service_id" integer NOT NULL REFERENCES "inventory_service" ("id"),
UNIQUE ("server_id", "service_id")
)
;
CREATE TABLE "inventory_server_hardware_component" (
"id" integer NOT NULL PRIMARY KEY,
"server_id" integer NOT NULL REFERENCES "inventory_server" ("id"),
"hardwarecomponent_id" integer
NOT NULL REFERENCES "inventory_hardwarecomponent" ("id"),
UNIQUE ("server_id", "hardwarecomponent_id")
)
;
COMMIT;
```
```
Тогда мы могли бы создать базу данных SQLite следующей командой:
jmjones@dinkgutsy:~/code$ sqlite3 inventory.db < inventory.sql
```
```
Конечно, здесь мы предполагаем, что вы уже установили SQLite. В сис
темах Ubuntu и Debian установка выполняется простой командой apt–
get install sqlite3. В системах Red Hat следует выполнить команду
yum install sqlite. Для других дистрибутивов Linux, не имеющих ус
тановочных пакетов, других систем UNIX или для Windows вы може
те загрузить исходные тексты и скомпилированные файлы по адресу
http://www.sqlite.org/download.html.
```

Реляционная сериализация **451**

```
Предположим, что библиотека SQLite установлена в системе и база дан
ных была благополучно создана. Мы продолжим нашу работу с ней, на
чав с «подключения» к базе данных и заполнения ее некоторыми дан
ными. Ниже показано все, что необходимо сделать для подключения
к базе данных SQLite:
In [1]: import sqlite3
```
```
In [2]: conn = sqlite3.connect('inventory.db')
```
```
Все, что нам потребовалось, – это импортировать библиотеку SQLite и
затем вызвать функцию connect() в модуле sqlite3. Функция connect()
возвращает объект соединения с базой данных, которому мы присвои
ли имя conn и который мы будем использовать в оставшейся части при
мера. Далее с помощью объекта соединения мы выполняем запрос, до
бавляющий данные в базу:
In [3]: cursor = conn.execute("insert into inventory_operatingsystem (name,
description) values ('Linux', '2.0.34 kernel');")
```
```
Метод execute() возвращает объект курсора базы данных, поэтому мы
решили дать ему имя cursor. Обратите внимание, что мы указали зна
чения только для полей name и description и опустили значение для по
ля id, которое является первичным ключом. Через мгновение вы уви
дите, что это поле получило свое значение. Поскольку это запрос на до
бавление данных в базу, а не запрос на выборку, то мы не ждем от за
проса результирующего набора данных; поэтому мы просто будем
просматривать курсор и извлекать любые результаты, которые он мо
жет хранить:
```
```
In [4]: cursor.fetchall()
Out[4]: []
```
```
Ничего, как мы и ожидали.
In [5]: conn.commit()
```
```
In [6]:
```
```
В действительности мы не должны были подтверждать операцию до
бавления данных. Эти изменения все равно будут сброшены на диск,
когда позднее мы закроем соединение с базой данных. Но никогда не
помешает явно вызвать метод commit(), когда известно, что эти данные
должны быть записаны.
Теперь, когда мы создали и заполнили базу данных SQLite, попробуем
прочитать записанные данные обратно. Для начала запустим оболочку
IPython, импортируем модуль sqlite3 и создадим соединение с файлом
базы данных:
```
```
In [1]: import sqlite3
In [2]: conn = sqlite3.connect('inventory.db')
```

**452** Глава 12. Сохранность данных

```
Теперь мы выполним запрос select и получим курсор с результатами:
In [3]: cursor = conn.execute('select * from inventory_operatingsystem;')
```
```
И, наконец, извлечем данные из курсора:
In [4]: cursor.fetchall()
Out[4]: [(1, u'Linux', u'2.0.34 kernel')]
```
```
Это те самые данные, которые были добавлены выше. Значение полей
name и description хранятся в Юникоде. А поле id заполнено целым чис
лом. Обычно, когда производится вставка данных в базу и при этом не
указывается значение поля первичного ключа, база данных сама за
полнит его, автоматически получая следующее уникальное значение
для этого поля.
Теперь, когда вы познакомились с основными приемами взаимодейст
вия с базой данных SQLite, реализация соединения таблиц, обновле
ния данных и более сложных операций – это, в значительной степени,
вопрос времени. База данных SQLite обеспечивает отличную возмож
ность сохранения данных, особенно когда данные используются един
ственным сценарием или только несколькими пользователями одно
временно. Говоря другими словами, SQLite прекрасно подходит для
решения небольших задач. Однако интерфейс модуля sqlite3 остается
слишком сложным.
```
**Storm ORM**

```
Несмотря на то, что простого SQLинтерфейса к базе данных вполне
достаточно для извлечения, изменения, добавления и удаления дан
ных в базе, тем не менее, часто бывает удобнее не отказываться от про
стоты и удобства языка Python. За последние несколько лет в способах
доступа к базам данных появилось новое направление – объектноори
ентированное представление данных, хранящихся в базе. Это направ
ление называется объектнореляционной проекцией (ObjectRelational
Mapping, ORM). В терминах ORM объект на языке программирования
может соответствовать одной строке в одной таблице базы данных.
Таблицы, связанные отношениями внешнего ключа, могут быть дос
тупны в виде атрибутов такого объекта.
Storm – это инструмент ORM, который недавно был выпущен как про
дукт, распространяемый с открытыми исходными текстами, компани
ей Canonical, которая ведет разработку дистрибутива Linux – Ubuntu.
Storm – это относительно новый продукт среди средств доступа к базам
данных для языка Python, но к нему уже проявляется пристальное
внимание и мы полагаем, что он станет одним из основных средств
ORM в языке Python.
Теперь мы попробуем использовать Storm для доступа к данным в базе,
которая была определена в разделе «SQLite». Первое, что нам следует
сделать, – это создать отображение для интересующих нас таблиц. По
```

Реляционная сериализация **453**

```
скольку мы уже обращались к таблице inventory_operatingsystem и до
бавили в нее одну запись, мы продолжим работу с этой таблицей. Ни
же показано, как выглядит отображение при использовании библиоте
ки Storm:
```
```
import storm.locals
class OperatingSystem(object):
__storm_table__ = 'inventory_operatingsystem'
id = storm.locals.Int(primary=True)
name = storm.locals.Unicode()
description = storm.locals.Unicode()
```
```
Это самое обычное определение класса. Здесь нет ничего сверхъестест
венного. Здесь не наследуется какойто другой класс, кроме встроенного
типа object. Зато имеется несколько атрибутов. Единственное, что вы
глядит немного странно, – это атрибут __storm_table__. С его помощью
библиотека Storm определяет, для доступа к какой таблице будет ис
пользоваться этот объект. Пока все выглядит достаточно просто и впол
не обычно, и, тем не менее, во всем этом всетаки есть капелька магии.
Например, атрибут name отображается на поле name в таблице inventory_
operatingsystem, а атрибут description отображается на поле description
в той же таблице. Как? Магия. Любой атрибут, присутствующий в клас
се проекции Storm, автоматически отображается на одноименное поле
в таблице, имя которой определяется атрибутом __storm_table__.
А что, если нам не нужно, чтобы атрибут description объекта отобра
жался на поле description? Тогда просто передайте методу storm.lo
cals.Type имя требуемого поля в именованном аргументе name. Напри
мер, изменив определение атрибута description на такое: dsc = storm.
locals.Unicode(name='description'), вы тем самым свяжете атрибут dsc
объекта OperatingSystem с тем же самым полем (то есть с полем descrip
tion). Но тогда на описание нужно будет ссылаться не как на атрибут
mapped_object.description, а как на атрибут mapped_object.dsc.
Теперь, когда у нас имеется класс проекции на таблицу в базе данных,
попробуем добавить в нее еще одну строку. В дополнение к нашему древ
нему дистрибутиву Linux на ядре 2.0.34 мы добавим Windows 3.1.1:
import storm.locals
import storm_model
import os
```
```
operating_system = storm_model.OperatingSystem()
operating_system.name = u'Windows'
operating_system.description = u'3.1.1'
db = storm.locals.create_database('sqlite:///%s' % os.path.join(os.getcwd(),
'inventory.db'))
store = storm.locals.Store(db)
store.add(operating_system)
store.commit()
```

**454** Глава 12. Сохранность данных

```
В этом примере мы импортировали модули storm.locals, storm_model и os.
Затем мы создали экземпляр класса OperatingSystem и присвоили значе
ния его атрибутам name и description. (Обратите внимание: в качестве
значений этих атрибутов мы использовали строки Юникода.) Затем
мы создали объект базы данных, вызвав функцию create_database(),
и передали этому методу путь к файлу нашей базы данных SQLite,
inventory.db. Вы могли бы подумать, что объект базы данных будет ис
пользоваться для добавления данных в базу, но это не так, по крайней
мере, не напрямую. Сначала нам нужно создать объект Store, передав
объект базы данных конструктору. После этого мы можем добавить
объект operating_system в объект store. В заключение вызывается ме
тод commit() объекта store, чтобы подтвердить добавление объекта ope
rating_system в базу данных.
Мы также хотели бы убедиться, что вставленные данные действитель
но были записаны в базу данных. Поскольку это база данных SQLite,
можно было бы просто воспользоваться инструментом командной
строки sqlite3. Но если сделать это, то у нас не будет причин написать
программный код, извлекающий данные из базы с помощью Storm.
Итак, ниже приводится простая утилита, которая извлекает и выво
дит все записи из таблицы inventory_operatingsystem (хотя и в довольно
уродливом виде):
import storm.locals
import storm_model
import os
```
```
db = storm.locals.create_database('sqlite:///%s' % os.path.join(os.getcwd(),
'inventory.db'))
```
```
store = storm.locals.Store(db)
for o in store.find(storm_model.OperatingSystem):
print o.id, o.name, o.description
```
```
Первые несколько строк в этом примере поразительно напоминают
первые несколько строк предыдущего примера. Отчасти это сходство
обусловлено тем, что мы просто скопировали программный код из од
ного файла в другой. Впрочем, это не главное. Основная же причина
заключается в том, что в обоих случаях необходимо выполнить одни
и те же подготовительные действия, прежде чем сценарии смогут «об
щаться» с базой данных. Здесь используются те же инструкции им
портирования, что и в предыдущем примере. У нас имеется объект db,
который возвращает функция create_database(). У нас имеется объект
store, созданный конструктором Store(), которому был передан объект
db. Но теперь вместо добавления объекта в хранилище (в объект store)
мы вызываем метод find() объекта store. Этот конкретный вызов метода
find() (то есть store.find(storm_model.OperatingSystem)) возвращает мно
жество всех объектов storm_model.OperatingSystem. Поскольку класс Ope
ratingSystem является проекцией на таблицу inventory_operatingsystem,
```

Реляционная сериализация **455**

```
Storm отыщет все подходящие записи в таблице inventory_operating
system и создаст объект OperatingSystem для каждой из них. Для каждо
го объекта OperatingSystem выводятся значения атрибутов id, name и de
scription. Эти атрибуты являются проекциями на одноименные поля
записей в базе данных.
В нашей базе данных уже имеется одна запись, добавленная в более
раннем примере, приводившемся в разделе «SQLite». Давайте посмот
рим, что получится, если запустить этот сценарий. Мы могли бы ожи
дать, что будет выведена одна запись, хотя она и была добавлена без
использования библиотеки Storm:
```
```
jmjones@dinkgutsy:~/code$ python storm_retrieve_os.py
1 Linux 2.0.34 kernel
```
```
Это в точности соответствует нашим ожиданиям. Теперь сначала по
пробуем запустить сценарий, добавляющий новую запись, а затем сно
ва запустим сценарий, извлекающий данные. На этот раз он должен
вывести старую запись, добавленную ранее (система на базе ядра
Linux 2.0.34), и только что добавленную запись (Windows 3.1.1):
jmjones@dinkgutsy:~/code$ python storm_add_os.py
jmjones@dinkgutsy:~/code$ python storm_retrieve_os.py
1 Linux 2.0.34 kernel
2 Windows 3.1.1
```
```
И снова мы получили именно то, что и ожидали получить.
Но что, если нам потребуется фильтровать данные? Предположим, что
нам потребуется увидеть только те операционные системы, название
которых начинается с последовательности символов «Lin». Ниже при
водится фрагмент программного кода, который делает именно это:
```
```
import storm.locals
import storm_model
import os
db = storm.locals.create_database('sqlite:///%s' % os.path.join(os.getcwd(),
'inventory.db'))
store = storm.locals.Store(db)
for o in store.find(storm_model.OperatingSystem,
storm_model.OperatingSystem.name.like(u'Lin%')):
print o.id, o.name, o.description
```
```
Этот пример идентичен предыдущему примеру, где использовался
метод store.find(), за исключением того, что в этом примере методу
store.find() передается второй параметр: критерий поиска. Вызов
Store.find(storm_model.OperatingSystem,storm_model.OperatingSystem.na
me.like(u'Lin%')) сообщает библиотеке Storm, что требуется отыскать
все объекты OperatingSystem, у которых значение атрибута name начи
нается со строки Юникода Lin. Каждое значение в наборе результа
тов выводится точно так же, как и в предыдущем примере.
```

**456** Глава 12. Сохранность данных

```
И когда мы запустим этот фрагмент, мы увидим следующее:
jmjones@dinkgutsy:~/code$ python storm_retrieve_os_filter.py
1 Linux 2.0.34 kernel
```
```
В базе данных попрежнему присутствует запись с названием операци
онной системы «Windows 3.1.1», но она была отфильтрована, потому
что не начинается со строки «Lin».
```
**SQLAlchemy ORM**

```
В то время как библиотека Storm только начинает обретать сторонни
ков и находится на стадии формирования сообщества, библиотека
SQLAlchemy уже является доминирующим средством ORM для языка
Python. Своим подходом к решению проблемы она напоминает Storm.
Вероятно, лучше было бы сказать, что «библиотека Storm своим под
ходом к решению проблемы напоминает SQLAlchemy», поскольку
библиотека SQLAlchemy появилась раньше. Но, как бы то ни было,
для демонстрации SQLAlchemy мы воспользуемся все той же таблицей
inventory_operatingsystem, для работы с которой только что использова
ли библиотеку Storm.
Ниже приводится определение таблицы и объекта для отображения
таблицы inventory_operatingsystem:
#!/usr/bin/env python
```
```
import os
from sqlalchemy import create_engine
from sqlalchemy import Table, Column, Integer, Text, VARCHAR, MetaData
from sqlalchemy.orm import mapper
from sqlalchemy.orm import sessionmaker
engine = create_engine('sqlite:///%s' % os.path.join(os.getcwd(),
'inventory.db'))
metadata = MetaData()
os_table = Table('inventory_operatingsystem', metadata,
Column('id', Integer, primary_key=True),
Column('name', VARCHAR(50)),
Column('description', Text()),
)
class OperatingSystem(object):
def __init__(self, name, description):
self.name = name
self.description = description
def __repr__(self):
return "<OperatingSystem('%s','%s')>" % (self.name, self.description)
mapper(OperatingSystem, os_table)
Session = sessionmaker(bind=engine, autoflush=True, transactional=True)
session = Session()
```

Реляционная сериализация **457**

```
Самое существенное различие между примерами использования Storm
и SQLAlchemy заключается в определении таблицы, которое использу
ется библиотекой SQLAlchemy для создания проекции вместе с клас
сом таблицы.
Теперь, когда у нас имеется определение таблицы, можно написать
программный код, выполняющий запрос всех записей из таблицы:
```
```
#!/usr/bin/env python
from sqlalchemy_inventory_definition import session, OperatingSystem
```
```
for os in session.query(OperatingSystem):
print os
```
```
Если запустить этот фрагмент теперь, когда в таблице уже имеются не
которые данные, записанные туда в предыдущих примерах, мы уви
дим следующее:
$ python sqlalchemy_inventory_query_all.py <OperatingSystem('Linux','2.0.34
kernel')>
<OperatingSystem('Windows','3.1.1')>
</OperatingSystem></OperatingSystem>
```
```
Если бы нам потребовалось создать еще одну запись, мы легко могли бы
сделать это, просто создав объект OperatingSystem и добавив его в объект
session:
```
```
#!/usr/bin/env python
from sqlalchemy_inventory_definition import session, OperatingSystem
ubuntu_710 = OperatingSystem(name='Linux', description='2.6.2214 kernel')
session.save(ubuntu_710)
session.commit()
```
```
В результате в таблицу будет добавлена другая запись с операционной
системой Linux на другом ядре, более современном. Запустив сцена
рий, запрашивающий все записи, еще раз, мы получим:
```
```
$ python sqlalchemy_inventory_query_all.py
<OperatingSystem('Linux','2.0.34 kernel')>
<OperatingSystem('Windows','3.1.1')>
<OperatingSystem('Linux','2.6.2214 kernel')>
```
```
Фильтрация результатов в SQLAlchemy выполняется также просто.
Например, если бы нам потребовалось выбрать все объекты Operating
System, в которых значение атрибута name начинается с последователь
ности символов «Lin», мы могли бы написать следующий сценарий:
```
```
#!/usr/bin/env python
from sqlalchemy_inventory_definition import session, OperatingSystem
for os in session.query(OperatingSystem).filter(
OperatingSystem.name.like('Lin%')):
print os
```

**458** Глава 12. Сохранность данных

```
И мы могли бы получить следующие результаты:
$ python sqlalchemy_inventory_query_filter.py
<OperatingSystem('Linux','2.0.34 kernel')>
<OperatingSystem('Linux','2.6.2214 kernel')>
```
```
Это был лишь краткий обзор возможностей библиотеки SQLAlchemy.
За дополнительной информацией об использовании SQLAlchemy обра
щайтесь на вебсайт http://www.sqlalchemy.org/. Или приобретите кни
гу Рика Коупленда (Rick Coupland) «Essential SQLAlchemy» (O’Reilly).
```
**В заключение**

```
В этой главе мы рассмотрели несколько различных инструментов, по
зволяющих сохранять данные для последующего использования. Ино
гда вам будет требоваться нечто простое и легковесное, как модуль
pickle. Иногда вам будет требоваться нечто более полнофункциональ
ное, как SQLAlchemy ORM. Как уже было показано, при использова
нии языка Python в вашем распоряжении имеется множество реше
ний, от очень простых до мощных и сложных.
```
```
ПОРТРЕТ ЗНАМЕНИТОСТИ: SQLACLCHEMY
```
**Майк Байер (Mike Bayer)**

```
Майкл Байер – подрядчик на поставку программ
ного обеспечения из НьюЙорка, обладающий де
сятилетним опытом работы с реляционными ба
зами данных всех форм и размеров. После созда
ния множества собственных библиотек абстрак
ции доступа к базам данных на таких языках
программирования, как C, Java и Perl, и после не
скольких лет практической работы с огромными, состоящими
из нескольких серверов, системами Oracle для высшей лиги по
бейсболу он написал SQLAlchemy, как «основной инструмент»
для создания кода SQL и для работы с базами данных. Цель его
состоит в том, чтобы способствовать появлению инструмента ми
рового класса для языка Python, помогающего превратить Py
thon в широко популярную платформу программирования, ка
ковой он достоин быть.
```
