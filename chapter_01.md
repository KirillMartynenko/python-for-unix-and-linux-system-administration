# Глава 1. Введение

## Почему Python?

Если вы системный администратор, вам наверняка пришлось сталки
ваться с Perl, Bash, ksh и некоторыми другими языками сценариев.
Вы могли даже использовать один или несколько языков в своей рабо
те. Языки сценариев часто позволяют выполнять рутинную, утоми
тельную работу со скоростью и надежностью, недостижимой без них.
Любой язык – это всего лишь инструмент, позволяющий выполнить
работу. Ценность языка определяется лишь тем, насколько точно
и быстро с его помощью можно выполнить свою работу. Мы считаем,
что Python представляет собой ценный инструмент именно потому, что
он дает возможность эффективно выполнять нашу работу.
Можно ли сказать, что Python лучше, чем Perl, Bash, Ruby или любой
другой язык? На самом деле очень сложно дать такую качественную
оценку, потому что всякий инструмент очень тесно связан с образом
мышления программиста, использующего его. Программирование –
это субъективный и очень личностный вид деятельности. Язык стано
вится превосходным, только если он полностью соответствует потреб
ностям программиста. Поэтому мы не будем доказывать, что язык Py
thon лучше, но мы объясним причины, по которым мы считаем Python
лучшим выбором. Мы также объясним, почему он так хорошо подхо
дит для решения задач системного администрирования.
Первая причина, по которой мы считаем Python превосходным языком,
состоит в том, что он очень прост в изучении. Если язык не способен бы
стро превратиться для вас в эффективный инструмент, его привлека
тельность резко падает. Неужели вы хотели бы потратить недели или
месяцы на изучение языка, прежде чем вы окажетесь в состоянии на
писать на нем чтолибо стоящее? Это особенно верно для системных ад
министраторов. Если вы – системный администратор, проблемы могут накапливаться быстрее, чем вы можете разрешать их. С помощью
языка Python вы сумеете начать писать полезные сценарии буквально
спустя несколько часов, а не дней или недель. Если язык не позволяет
достаточно быстро приступить к написанию сценариев, это повод заду
маться в целесообразности его изучения.
Однако язык, пусть и простой в изучении, но не позволяющий решать
сложные задачи, также не стоит потраченных на него усилий. Поэто
му вторая причина, по которой мы считаем Python превосходным язы
ком программирования, заключается в том, что он позволяет решать
такие сложные задачи, какие только можно вообразить. Вам требует
ся строку за строкой просматривать файлы журналов, чтобы выудить
из них какуюто важную информацию? Язык Python в состоянии по
мочь решить эту задачу. Или вам требуется просмотреть файл журна
ла, извлечь из него определенные записи и сравнить обращения с каж
дого IPадреса в этом файле с обращениями в каждом из файлов жур
налов (которые хранятся в реляционной базе данных) за последние
три месяца, а затем сохранить результаты в реляционной базе дан
ных? Вне всяких сомнений это можно реализовать на языке Python.
Язык Python используется для решения весьма сложных задач, таких
как анализ генных последовательностей, для обеспечения работоспо
собности многопоточных вебсерверов и сложнейших статистических
вычислений. Возможно, вам никогда не придется решать подобные за
дачи, но будет совсем нелишним знать, что в случае необходимости
язык поможет вам решать их.
Кроме того, если вы в состоянии выполнять сложнейшие операции, но
удобство сопровождения программного кода оставляет желать лучше
го, это плохой знак. Язык Python ликвидирует проблемы, связанные
с сопровождением программного кода, и он действительно позволяет
выражать сложные идеи простыми языковыми конструкциями. Про
стота программного кода – существенный фактор, который облегчает
дальнейшее его сопровождение. Программный код на языке Python на
столько прост, что позволяет возвращаться к нему спустя месяцы.
И достаточно прост, чтобы можно было вносить изменения в программ
ный код, который раньше нам не встречался. Таким образом, синтак
сис и общие идиомы этого языка настолько ясные, краткие и простые,
что позволяют работать с ним в течение длительных периодов времени.
Следующая причина, по которой мы считаем Python превосходным
языком, заключается в высокой удобочитаемости программного кода.
Блоки программного кода определяются по величине отступов. Отсту
пы помогают взгляду следить за ходом выполнения программы. Кро
ме того, язык Python основан на «использовании слов». Под этим под
разумевается, что хотя в языке Python используются свои специальные
символы, основные его особенности в большинстве своем реализованы
в виде ключевых слов или библиотек. Упор на слова, а не на специаль
ные символы упрощает чтение и понимание программного кода.
Теперь, когда мы выявили некоторые преимущества языка Python,
мы проведем сравнение нескольких фрагментов программного кода на
языках Python, Perl и Bash. Попутно мы познакомимся еще с несколь
кими преимуществами языка Python. Ниже приводится простой при
мер на языке Bash, который выводит все возможные парные комбина
ции символов из набора 1 , 2 и символов из набора a, b:

```
#!/bin/bash
for a in 1 2; do
for b in a b; do
echo "$a $b"
done
done
```

```
Вот эквивалентный фрагмент на языке Perl:
#!/usr/bin/perl
```
```
foreach $a ('1', '2') {
foreach $b ('a', 'b') {
print "$a $b\n";
}
}
```
```
Это самый простой вложенный цикл. А теперь сравним эти реализа
ции с циклом for в языке Python:
#!/usr/bin/env python
```
```
for a in [1, 2]:
for b in ['a', 'b']:
print a, b
```
```
Далее продемонстрируем использование условных инструкций в Bash,
Perl и Python. Здесь используется простая условная инструкция if/
else, с помощью которой выясняется – является ли заданный путь
к файлу каталогом:
#!/bin/bash
```
```
if [d "/tmp" ] ; then
echo "/tmp is a directory"
else
echo "/tmp is not a directory"
fi
```
```
Ниже приводится эквивалентный сценарий на языке Perl:
```
```
#!/usr/bin/perl
if (d "/tmp") {
print "/tmp is a directory\n";
}
else {
```



```
print "/tmp is not a directory\n";
}
```
```
А ниже – эквивалентный сценарий на языке Python:
#!/usr/bin/env python
```
```
import os
if os.path.isdir("/tmp"):
print "/tmp is a directory"
else:
print "/tmp is not a directory"
```
```
Еще один фактор, говорящий в пользу превосходства языка Python, –
это простота поддержки объектноориентированного стиля програм
мирования (ООП). А также то обстоятельство, что вас ничто не застав
ляет использовать ООП, если в этом нет необходимости. Но когда по
является потребность в нем, этот стиль оказывается чрезвычайно про
стым в применении. ООП позволяет легко и просто разделить пробле
му на составные функциональные части, объединенные в нечто под
названием «объект». Язык Bash не поддерживает ООП, но Perl и Py
thon поддерживают. Ниже приводится модуль на языке Perl с опреде
лением класса:
package Server;
use strict;
sub new {
my $class = shift;
my $self = {};
$self>{IP} = shift;
$self>{HOSTNAME} = shift;
bless($self);
return $self;
}
sub set_ip {
my $self = shift;
$self>{IP} = shift;
return $self>{IP};
}
```
```
sub set_hostname {
my $self = shift;
$self>{HOSTNAME} = shift;
return $self>{HOSTNAME};
}
sub ping {
my $self = shift;
my $external_ip = shift;
my $self_ip = $self>{IP};
my $self_host = $self>{HOSTNAME};
print "Pinging $external_ip from $self_ip ($self_host)\n";
return 0;
}
```
```
1;
```
```
И далее фрагмент, в котором он используется:
```
```
#!/usr/bin/perl
use Server;
```
```
$server = Server>new('192.168.1.15', 'grumbly');
$server>ping('192.168.1.20');
```

Программный код, в котором используется объектноориентирован
ный модуль, достаточно прост. Однако на анализ самого модуля может
потребоваться некоторое время, особенно если вы не знакомы с ООП
или с особенностями реализации его поддержки в языке Perl.
Эквивалентный класс на языке Python и порядок его использования
выглядят, как показано ниже:

```
#!/usr/bin/env python
class Server(object):
def __init__(self, ip, hostname):
self.ip = ip
self.hostname = hostname
def set_ip(self, ip):
self.ip = ip
def set_hostname(self, hostname):
self.hostname = hostname
def ping(self, ip_addr):
print "Pinging %s from %s (%s)" % (ip_addr, self.ip, self.hostname)
if __name__ == '__main__':
server = Server('192.168.1.20', 'bumbly')
server.ping('192.168.1.15')
```

Примеры на языках Perl и Python демонстрируют некоторые из фундаментальных аспектов ООП, и вместе с тем они наглядно показывают различные особенности, которые используются в этих языках для дос
тижения поставленной цели. Оба фрагмента решают одну и ту же задачу, но они отличаются друг от друга. Таким образом, если вы пожелаете использовать ООП, язык Python предоставит вам такую возмож
ность. И вы достаточно легко и просто сможете включить его в свой арсенал.
Другое преимущество Python проистекает не из самого языка, а из его сообщества. В сообществе пользователей языка Python достигнуто единодушие по поводу способов решения определенных видов задач,
которые вы должны (или не должны) использовать. Несмотря на то, что сам язык обеспечивает множество путей достижения одной и той же цели, соглашения, принятые в сообществе, могут рекомендовать воздерживаться от использования некоторых из них. Например, инструкция from module import * в начале модуля считается вполне допустимой. Однако сообщество осуждает такое ее использование и рекомендует использовать либо инструкцию import module, либо инструкцию from module import resource. Импортирование всего содержимого модуля в пространство имен другого модуля может вызвать существенные осложнения, когда вы попытаетесь выяснить принцип действия модуля и узнать, где находятся вызываемые функции. Это конкретное соглашение поможет вам писать более понятный программный код, что позволит тем, кто будет сопровождать его, выполнять свою работу с большим удобством. Следование общепринятым соглашениям открывает вам путь к использованию наилучших приемов программирования. Мы считаем, что это идет только на пользу.
Стандартная библиотека языка Python – это еще одна замечательная особенность Python. Если применительно к языку Python вы услышите фразу «батарейки входят в комплект поставки», это лишь означает,
что стандартная библиотека позволяет решать все виды задач без необходимости искать другие модули для этого. Например, несмотря на их отсутствие в самом языке, Python обеспечивает поддержку регулярных выражений, сокетов, нескольких потоков выполнения и функции для работы с датой/временем, синтаксического анализа документов XML, разбора конфигурационных файлов, функций для работы с файлами и каталогами, хранения данных, модульного тестирования, а также клиентские библиотеки для работы с протоколами http, ftp, imap, smtp и nntp и многое другое. Сразу после установки Python модули поддержки всех этих функциональных особенностей могут импортироваться вашими сценариями по мере необходимости. В вашем распоряжении имеются все перечисленные здесь функциональные возможности. Весьма впечатляет, что все это поставляется в составе Python и вам не требуется приобретать чтото еще. Все эти возможности будут чрезвычайно полезны вам при создании своих собственных
программ на языке Python.
Простой доступ к огромному количеству пакетов сторонних производителей – еще одно важное преимущество Python. Помимо множества библиотек, входящих в стандартную библиотеку языка Python, существует большое число библиотек и утилит, доступных в Интернете, которые устанавливаются одной командой. В Интернете, по адресу http://pypi.python.org , существует каталог пакетов Python (Python Package
Index, PyPI), где любой желающий может выкладывать свои пакеты в общее пользование. К моменту, когда писались эти строки, для загрузки было доступно более 3800 пакетов. В составе пакетов присутствуют IPython, который будет рассматриваться в следующей главе, Storm (модуль объектнореляционного отображения, который будет рассматриваться в главе 12) и Twisted, сетевая платформа, которая будет рассматриваться в главе 5, – это только 3 названия из более чем 3800 пакетов. Начав пользоваться PyPI, вы обнаружите, что он совершенно необходим вам для поиска и установки полезных пакетов.
Многие из преимуществ языка Python проистекают из его базовой философии. Если в строке приглашения к вводу Python ввести команду `import this`, перед вами появится так называемый «Дзен языка Python» Тима Петерса (Tim Peters):

```
In [1]: import this
The Zen of Python, by Tim Peters
```
```
Beautiful is better than ugly.
Explicit is better than implicit.
Simple is better than complex.
Complex is better than complicated.
Flat is better than nested.
Sparse is better than dense.
Readability counts.
Special cases aren't special enough to break the rules.
Although practicality beats purity.
Errors should never pass silently.
Unless explicitly silenced.
In the face of ambiguity, refuse the temptation to guess.
There should be one and preferably only oneobvious way to do it.
Although that way may not be obvious at first unless you're Dutch.
Now is better than never.
Although never is often better than *right* now.
If the implementation is hard to explain, it's a bad idea.
If the implementation is easy to explain, it may be a good idea.
Namespaces are one honking great idea let's do more of those!
( Перевод:
Красивое лучше уродливого.
Явное лучше неявного.
Простое лучше сложного.
Сложное лучше усложненного.
Плоское лучше вложенного.
Разрежённое лучше плотного.
Удобочитаемость важна.
Частные случаи не настолько существенны, чтобы нарушать правила.
Однако практичность важнее чистоты.
Ошибки никогда не должны замалчиваться.
За исключением замалчивания, которое задано явно.
В случае неоднозначности сопротивляйтесь искушению угадать.
Должен существовать один, и, желательно, только один очевидный
способ сделать это.
Хотя он может быть с первого взгляда не очевиден, если ты не голландец.
Сейчас лучше, чем никогда.
Однако, никогда чаще лучше, чем *прямо* сейчас.
Если реализацию сложно объяснить, — это плохая идея.
Если реализацию легко объяснить, — это может быть хорошая идея.
Пространства имён — великолепная идея, их должно быть много!
)
```

Этот свод правил – не догма, следование которой считается обязатель
ным на всех уровнях разработки языка, но сам дух его, кажется, про
питывает почти все, что происходит в языке и с языком. И мы счита
ем, что это замечательно. Возможно, именно поэтому мы день за днем
стремимся использовать Python. Эта философия совпадает с тем, чего
мы ждем от языка. И если она совпадает с вашими ожиданиями, зна
чит язык Python будет хорошим выбором и для вас.

## Мотивация

Если вы только что взяли эту книгу в свои руки в книжном магазине
или читаете введение гденибудь в Интернете, вы, возможно, задаете
себе вопрос – насколько сложно будет изучить язык Python и стоит ли
это делать. Несмотря на растущую популярность Python, многие сис
темные администраторы до сих пор используют в своей работе только
Bash и Perl. Если вы относитесь к их категории, вас наверняка обраду
ет тот факт, что язык Python очень прост в изучении. Хотя это вопрос
личного мнения, но многие убеждены в том, что это самый простой
язык для изучения и преподавания, и точка!
Если вы уже знакомы с языком Python или считаете себя гуру в про
граммировании на другом языке, вы наверняка сможете прямо сейчас
перейти к любой из следующих глав, не читая это введение, и сумеете
разобраться в наших примерах. Мы старались создавать примеры, ко
торые действительно помогут вам выполнять свою работу. В книге
имеются примеры способов автоматического обнаружения и монито
ринга подсетей с помощью SNMP, преобразования в интерактивную
оболочку Python под названием IPython, организации конвейерной
обработки данных, инструментов управления метаданными с помо
щью средств объектнореляционного отображения, сетевых приложе
ний, инструментов командной строки и многого другого.
Если у вас имеется опыт программирования на языке командной обо
лочки, вам тоже нет причин волноваться. Вы также легко и быстро ос
воите Python. Вам нужно лишь желание учиться, определенная доля
любопытства и решимость – те же факторы, которые побудили вас
взять в руки эту книгу и прочитать введение.
Мы понимаем, что среди вас есть и скептики. Возможно, часть из того,
что вы слышали о программировании, напугала вас. Существует одно
общее, глубоко неверное заблуждение, что программированию могут
научиться не все, а только избранная таинственная элита. На самом
деле любой желающий может научиться программировать. Второе, не
менее ложное заблуждение состоит в том, что только получение про
фессионального образования в области информатики открывает чело
веку путь к званию программиста. Однако у некоторых самых талант
ливых программистов нет диплома об образовании в данной области.
Среди компетентных программистов на языке Python имеются люди с профессиональной подготовкой в области философии, журналистики, диетологии и английского языка. Наличие специального образования не является обязательным требованием для освоения Python, хотя оно и не повредит.
Еще одно забавное и такое же неверное представление заключается
в том, что программированию можно учиться только в подростковом
возрасте. Хотя это позволяет хорошо себя чувствовать людям, кото
рым посчастливилось встретить в юности когото, кто вдохновил их
заняться программированием, тем не менее, это еще один миф. Очень
полезно начинать изучение программирования в юном возрасте, но
возраст не является препятствием к освоению языка Python. Освоение
Python – это не «игрушка для молодежи», как иногда говорят. Среди
разработчиков существует бесчисленное множество людей, которые
осваивали программирование, будучи в возрасте старше 20, 30, 40 лет
и даже больше.
Если вы добрались до этого места, то надо заметить, что у вас, уважае
мый читатель, есть одно преимущество, которое отсутствует у многих.
Если вы решили взять в руки книгу, рассказывающую об использова
нии языка Python в системном администрировании UNIX и Linux,
значит, вы уже представляете себе, как выполнять команды в команд
ной оболочке. Это огромное преимущество для того, кто решил стать
программистом на языке Python. Наличие знаний о способах выполне
ния команд в терминале – это все, что необходимо для этого введения
в Python. Если вы уверены, что научитесь программированию на язы
ке Python, тогда сразу же переходите к следующему разделу. Если
у вас еще есть сомнения, тогда прочитайте этот раздел еще раз и убеди
те себя в том, что вы в силах овладеть программированием на языке
Python. Это действительно просто, и если вы примете такое решение,
оно изменит вашу жизнь.

## Основы

Это введение в язык Python сильно отличается от любого другого, т. к.
мы будем использовать интерактивную оболочку под названием IPython и обычную командную оболочку Bash. Вы должны будете открыть два окна терминалов, одно – с командной оболочкой Bash и другое – с интерактивной оболочкой IPython. В каждом примере мы будем сравнивать, как выполняются одни и те же действия с помощью
Python и с помощью Bash. Для начала загрузите требуемую версию
интерактивной оболочки IPython для своей платформы и установите
ее. Получить ее можно на странице http://ipython.scipy.org/moin/
Download. Если по какимто причинам вы не можете получить и уста
новить IPython, то можно использовать обычную интерактивную обо
лочку интерпретатора Python. Вы можете также загрузить копию вир
туальной машины, включающую в себя все примеры программ из кни
ги, а также предварительно настроенную и готовую к работе интерактивную оболочку IPython. Вам достаточно просто ввести команду
ipython, и вы попадете в строку приглашения к вводу.
Как только оболочка IPython будет установлена и запущена, вы должны увидеть примерно следующее:

```
[ngift@Macintosh7][H:10679][J:0]# ipython
Python 2.5.1 (r251:54863, Jan 17 2008, 19:35:17)
Type "copyright", "credits" or "license" for more information.
IPython 0.8.2 An enhanced Interactive Python.
?> Introduction and overview of IPython's features.
%quickref> Quick reference.
help> Python's own help system.
object?> Details about 'object'. ?object also works, ?? prints more.
```
```
In [1]:
```

Интерактивная оболочка IPython напоминает обычную командную оболочку Bash и может выполнять такие команды, как ls, cd и pwd, а в следующей главе приведены более подробные сведения о IPython.
Эта глава посвящена изучению Python.
В окне терминала с интерактивной оболочкой Python введите следующую команду:
```
In [1]: print "I can program in Python"
I can program in Python
```

В окне терминала с командной оболочкой Bash введите следующую команду:
```
[ngift@Macintosh7][H:10688][J:0]# echo "I can program in Bash"
I can program in Bash
```

В этих двух примерах не ощущается существенных различий между Python и Bash. Мы надеемся, что это поможет лишить Python части его загадочности.

## Выполнение инструкций в языке Python.

Если вам приходится тратить значительную часть времени на ввод команд в окне терминала, значит, вам уже приходилось выполнять инст
рукции и, возможно, перенаправлять вывод в файл или на вход другой
команды UNIX. Рассмотрим порядок выполнения команды в Bash,
а затем сравним его с порядком, принятым в Python. В окне терминала
с командной оболочкой Bash введите следующую команду:
```
[ngift@Macintosh7][H:10701][J:0]# lsl /tmp/
total 0
rwrr 1 ngift wheel 0 Apr 7 00:26 file.txt
```

В окне терминала с интерактивной оболочкой Python введите следующую команду:

```
In [2]: import subprocess
In [3]: subprocess.call(["ls","l ","/tmp/"])
total 0
rwrr 1 ngift wheel 0 Apr 7 00:26 file.txt
Out[3]: 0
```

Пример с командной оболочкой Bash не нуждается в пояснениях, так как это обычная команда ls, но, если ранее вам никогда не приходилось сталкиваться с программным кодом на языке Python, пример
с интерактивной оболочкой Python наверняка покажется вам немного странным. Вы могли бы подумать: «Это еще что за команда import subprocess?». Одна из самых важных особенностей Python заключается
в его возможности импортировать модули или другие файлы, содер
жащие программный код и используемые в новых программах. Если
вам знакома инструкция source в Bash, то вы увидите определенное
сходство с ней. В данном конкретном случае важно понять, что вы им
портировли модуль subprocess и использовали его посредством син
таксической конструкции, показанной выше. Подробнее о том, как
работают subprocess и import, мы расскажем позже, а пока не будем за
думываться о том, почему эта инструкция работает, и обратимся к сле
дующей строке:

```
subprocess.call(["команда", "аргумент", "другой_аргумент_или_путь"])
```

Из Python можно выполнить любую команду оболочки, как если бы она выполнялась командной оболочкой Bash. Учитывая эту информацию, можно сконструировать версию команды ls на языке Python. От
кройте предпочтительный текстовый редактор или новую вкладку в окне терминала, создайте файл с именем pyls.py и сделайте его выполняемым с помощью команды chmod +x pyls.py. Содержимое файла
приводится в примере 1.1.

```
Пример 1.1. Версия команды ls на языке Python
#!/usr/bin/env python
#Версия команды ls на языке Python
import subprocess
```
```
subprocess.call(["ls","l"])
```
```
Если теперь запустить этот сценарий, вы получите тот же самый ре
зультат, что и при запуске команды ls – l из командной строки:
[ngift@Macintosh7][H:10746][J:0]# ./pyls.py
total 8
rwxrxrx 1 ngift staff 115 Apr 7 12:57 pyls.py
```

Этот пример может показаться глупым (да он таким и является), но он наглядно демонстрирует типичное применение Python в системном администрировании. Язык Python часто используется для «обертывания» других сценариев или команд UNIX. Теперь вы уже смогли бы начать писать некоторые несложные сценарии, помещая в файл команды одну за другой. Рассмотрим простые примеры, которые реализованы именно таким способом. Вы можете либо просто скопировать содержимое примера 1.2, либо выполнить сценарии psysinfo.py и bash> sysinfo.py, которые можно найти в примерах к этой главе.

```
Пример 1.2. Сценарий получения информации о системе – Python
#!/usr/bin/env python
#Сценарий сбора информации о системе
import subprocess
#Команда 1
uname = "uname"
uname_arg = "-a"
print "Gathering system information with %s command:\n" % uname
subprocess.call([uname, uname_arg])
```
```
#Команда 2
diskspace = "df"
diskspace_arg = "-h"
print "Gathering diskspace information %s command:\n" % diskspace
subprocess.call([diskspace, diskspace_arg])
```
```
Пример 1.3. Сценарий получения информации о системе – Bash
#!/usr/bin/env bash
#Сценарий сбора информации о системе
```
```
#Команда 1
UNAME="unamea"
printf "Gathering system information with the $UNAME command: \n\n"
$UNAME
```
```
#Команда 2
DISKSPACE="dfh"
printf "Gathering diskspace information with the $DISKSPACE command: \n\n"
$DISKSPACE
```
```
Если внимательно рассмотреть оба сценария, можно заметить, что они
очень похожи. А если запустить их, будут получены идентичные ре
зультаты. Маленькое примечание: передавать в функции subpro
cess.call команду отдельно от аргумента совершенно необязательно.
Можно использовать, например, такую форму записи:
subprocess.call("df -h", shell=True)
```
```
Все замечательно, но мы еще не объяснили, как действует инструкция
import и что из себя представляет модуль subprocess. В версии сценария
на языке Python мы выполнили импортирование модуля subprocess,
т. к. он содержит программный код, позволяющий выполнять вызов
команд системы.
Как уже упоминалось ранее, импортируя модуль subprocess, мы просто
импортируем файл, содержащий необходимый нам программный код.
Вы можете создать свой собственный модуль, или файл, и неоднократ
но использовать написанный вами программный код, импортируя его
точно так же, как мы импортировали программный код из модуля sub
process. В импортировании нет ничего необычного, просто в результа
те этой операции вы получаете в свое распоряжение файл с некоторым
программным кодом в нем. Одна из замечательных особенностей инте
рактивной оболочки IPython состоит в ее способности заглядывать
внутрь модулей и файлов и получать списки доступных атрибутов. Ес
ли говорить терминами UNIX, это напоминает действие команды ls
в каталоге /usr/bin. Например, если вы оказались в новой системе, та
кой как Ubuntu или Solaris, а привыкли работать с Red Hat, то вы мо
жете выполнить команду ls в каталоге /usr/bin , чтобы узнать – имеет
ся ли в наличии такой инструмент, как wget, curl или lynx. Если вы
хотите воспользоваться инструментом, находящимся в каталоге /usr/
bin , можно просто ввести команду /usr/bin/wget , например.
Ситуация с модулями, такими как subprocess, очень похожа на описан
ную выше. В интерактивной оболочке IPython можно использовать
функцию автодополнения, чтобы увидеть, какие инструменты доступ
ны внутри модуля. Воспользуемся возможностью автодополнения и по
смотрим, какие атрибуты имеются внутри модуля subprocess. Не забы
вайте, что модуль – это всего лишь файл с некоторым программным
кодом внутри него. Ниже показано, что возвращает функция автодо
полнения в IPython для модуля subprocess:
In [12]: subprocess.
subprocess.CalledProcessError subprocess.__hash__ subprocess.call
subprocess.MAXFD subprocess.__init__ subprocess.check_call
subprocess.PIPE subprocess.__name__ subprocess.errno
subprocess.Popen subprocess.__new__ subprocess.fcntl
subprocess.STDOUT subprocess.__reduce__ subprocess.list2cmdline
subprocess.__all__ subprocess.__reduce_ex__ subprocess.mswindows
subprocess.__builtins__ subprocess.__repr__ subprocess.os
subprocess.__class__ subprocess.__setattr__ subprocess.pickle
subprocess.__delattr__ subprocess.__str__ subprocess.select
subprocess.__dict__ subprocess._active subprocess.sys
subprocess.__doc__ subprocess._cleanup subprocess.traceback
subprocess.__file__ subprocess._demo_posix subprocess.types
subprocess.__getattribute__ subprocess._demo_windows
```
```
Чтобы воспроизвести этот эффект, вам нужно просто ввести команду:
```
```
import subprocess
```
```
затем ввести:
```
```
subprocess.
```

и нажать клавишу Ta b, чтобы активизировать функцию автодополне
ния, которая выведет список доступных атрибутов. В третьей колонке
нашего примера можно заметить subprocess.call. Теперь, чтобы полу
чить дополнительную информацию об использовании subprocess.call,
введите команду:
```
In [13]: subprocess.call?
Type: function
Base Class: <type 'function'>
String Form: <function call at 0x561370>
Namespace: Interactive
File: /System/Library/Frameworks/Python.framework/Versions/2.5/lib/
python2.5/
subprocess.py
Definition: subprocess.call(*popenargs, **kwargs)
Docstring:
Run command with arguments. Wait for command to complete, then
return the returncode attribute.
(Запускает команду с аргументами. Ожидает ее завершения и возвращает
атрибут returncode)
The arguments are the same as for the Popen constructor. Example:
(Аргументы те же, что и в конструкторе Popen. Например:)
retcode = call(["ls", "l"])
```

Символ вопросительного знака в данном случае трактуется как обра
щение к странице справочного руководства. Когда требуется узнать,
как работает некоторый инструмент в системе UNIX, достаточно вве
сти команду:

```
man имя_инструмента
```

То же и с атрибутом внутри модуля, таким как subprocess.call. Когда
в оболочке IPython после имени атрибута вводится вопросительный
знак, выводится документация, которая была включена в атрибут. Ес
ли подобную операцию выполнить с атрибутами из стандартной биб
лиотеки, вы сможете обнаружить достаточно полезную информацию
по их использованию. Имейте в виду, что существует также возмож
ность обратиться к документации с описанием стандартной библиоте
ки языка Python.
Когда мы смотрим на это описание, в стандартный раздел «Docstring»,
мы видим пример использования атрибута subprocess.call и описание
того, что он делает.
```
**Итог**

```
Теперь вы обладаете объемом знаний, достаточным, чтобы называть
себя программистом на языке Python. Вы знаете, как написать простейший сценарий на языке Python, как перевести сценарий с языка
Bash на язык Python, и наконец, вы знаете, как отыскать описание модулей и атрибутов. В следующем разделе вы узнаете, как организовать
эти простые последовательности команд в функции.
```
## Использование функций в языке Python

```
В предыдущем разделе мы узнали, как выполняются инструкции, что
само по себе весьма полезно, т. к. это означает, что мы в состоянии ав
томатизировать выполнение некоторых операций, которые раньше
выполнялись вручную. Следующим шагом к нашему программному
коду автоматизации будет создание функций. Если вы еще не знакомы
с функциями в языке Bash или в какомлибо другом языке програм
мирования, то просто представляйте их себе как минисценарии.
Функции позволяют создавать блоки инструкций, которые работают
в группе. Это немного похоже на сценарий Bash с двумя командами,
написанный нами ранее. Одно из отличий состоит в том, что вы може
те включить в сценарий множество функций. В конечном счете можно
весь программный код сценария расположить в функциях и затем за
пускать эти минипрограммы в нужное время в своем сценарии.
Теперь настало время поговорить об отступах. В языке Python строки,
принадлежащие одному и тому же блоку программного кода, должны
иметь одинаковые отступы. В других языках, таких как Bash, когда
определяется функция, ее тело заключается в фигурные скобки. В язы
ке Python все строки в скобках должны иметь одинаковые отступы.
Это может сбивать с толку тех, кто только начинает изучать язык, но
через некоторое время это войдет в привычку и вы заметите, что вы
полнение этого требования повышает удобочитаемость программного
кода. Если при работе с какимилибо примерами из книги у вас появ
ляются ошибки, убедитесь для начала, что в исходных текстах пра
вильно соблюдены отступы. Обычно один шаг отступа принимают рав
ным четырем пробелам.
Рассмотрим, как работают функции в языке Python и Bash. Если у вас
попрежнему открыта интерактивная оболочка IPython, вы можете не
создавать файл сценария на языке Python, хотя это и не возбраняется.
Просто введите следующий текст в строке приглашения оболочки IPy
thon:
In [1]: def pyfunc():
...: print "Hello function"
...:
...:
In [2]: pyfunc
Out[2]: <function pyfunc at 0x2d5070>
In [3]: pyfunc()
Hello function
In [4]: for i in range(5):
...: pyfunc()
...:
...:
Hello function
Hello function
Hello function
Hello function
Hello function
```
```
В этом примере инструкция print помещена в функцию. Теперь можно
не только вызвать эту функцию позднее, но и вызвать ее столько раз,
сколько потребуется. В строке [4] была использована идиома (прием)
для выполнения функции пять раз. Если раньше вам такой прием не
встречался, постарайтесь понять, что он вызывает функцию пять раз.
То же самое можно сделать непосредственно в командной оболочке
Bash. Ниже демонстрируется один из способов:

```
bash-3.2$ function shfunc()
> {
> printf "Hello function\n"
> }
bash3.2$ for (( i=0 ; i < 5 ; i++))
> do
> shfunc
> done
Hello function
Hello function
Hello function
Hello function
Hello function
```

В примере на языке Bash была создана простая функции shfunc, кото
рая затем была вызвана пять раз, точно так же, как это было сделано
ранее с функцией в примере на языке Python. Примечательно, что
в примере на языке Bash потребовалось больше «багажа», чтобы реа
лизовать то же самое, что и на языке Python. Обратите внимание на от
личия цикла for в языке Bash от цикла for в языке Python. Если это
ваша первая встреча с функциями в Bash или Python, вам следует по
упражняться в создании какихнибудь других функций в окне IPy
thon, прежде чем двигаться дальше.
В функциях нет ничего таинственного, и попытка написать несколько
функций в интерактивной оболочке поможет ликвидировать налет та
инственности в случае, если это ваш первый опыт работы с функция
ми. Ниже приводится пара примеров простых функций:

```
In [1]: def print_many():
...: print "Hello function"
...: print "Hi again function"
...: print "Sick of me yet"
...:
...:
In [2]: print_many()
Hello function
Hi again function
Sick of me yet
In [3]: def addition():
...: sum = 1+1
...: print "1 + 1 = %s" % sum
...:
...:
```
```
In [4]: addition()
1 + 1 = 2
```

Итак, у нас за плечами имеется несколько простейших примеров кро
ме тех, что вы попробовали выполнить сами, не правда ли? Теперь мы
можем вернуться к сценарию, который собирает информацию о систе
ме и реализовать его с применением функций, как показано в приме
ре 1.4.

_Пример 1.4. Преобразованный сценарий сбора информации о системе
на языке Python: pysysinfo_func.py_

```
#!/usr/bin/env python
#Сценарий сбора информации о системе
import subprocess
#Команда 1
def uname_func():
uname = "uname"
uname_arg = "-a"
print "Gathering system information with %s command:\n" % uname
subprocess.call([uname, uname_arg])
#Команда 2
def disk_func():
diskspace = "df"
diskspace_arg = "h"
print "Gathering diskspace information %s command:\n" % diskspace
subprocess.call([diskspace, diskspace_arg])

#Главная функция, которая вызывает остальные функции
def main():
uname_func()
disk_func()
main()
```

Учитывая наши эксперименты с функциями, можно сказать, что пре
образование предыдущей версии сценария вылилось в то, что мы про
сто поместили инструкции внутрь функций и затем организовали их
вызов с помощью главной функции. Если вы не знакомы с подобным
стилем программирования, тогда, возможно, вы не знаете, что это дос
таточно распространенный прием, когда внутри сценария создается
несколько функций, а затем они вызываются из одной главной функ
ции. Одна из множества причин для такой организации состоит в том,
что, когда вы решите использовать этот сценарий с другой програм
мой, вы сможете выбирать, вызывать ли функции по отдельности или
с помощью главной функции. Суть в том, что решение принимается
после того, как модуль будет импортирован.
Когда нет никакого управления потоком выполнения или главной
функции, весь программный код выполняется немедленно, во время
импортирования модуля. Это может быть и неплохо для одноразовых
сценариев, но если вы предполагаете создавать инструменты много
кратного пользования, тогда лучше будет использовать функции, ко
торые заключают в себе определенные действия, и предусматривать
создание главной функции, которая будет выполнять всю программу
целиком.
Для сравнения также используем функции для предыдущего сцена
рия на языке Bash, выполняющего сбор информации о системе, как
показано в примере 1.5.

```
Пример 1.5. Преобразованный сценарий сбора информации о системе
на языке Bash: bashsysinfo_func.sh
#!/usr/bin/env bash
#Сценарий сбора информации о системе
#Команда 1
function uname_func ()
{
UNAME="uname -a"
printf "Gathering system information with the $UNAME command: \n\n"
$UNAME
}
#Команда 2
function disk_func ()
{
DISKSPACE="df -h"
printf "Gathering diskspace information with the $DISKSPACE command:
\n\n"
$DISKSPACE
}
function main ()
{
uname_func
disk_func
}
main
```

Взглянув на наш пример на языке Bash, можно заметить немало схо
жего с аналогичным ему сценарием на языке Python. Здесь также соз
даны две функции, которые затем вызываются из главной функции.
Если это ваш первый опыт работы с функциями, то мы могли бы поре
комендовать вам закомментировать вызов главной функции в обоих
сценариях, поставив в начале строки символ решетки (#), и попробо
вать запустить их еще раз. На этот раз в результате запуска сценариев
вы не должны получить ровным счетом ничего, потому что программа
хотя и выполняется, но она не вызывает две свои функции.
Теперь вы можете считать себя программистом, способным писать
простые функции на обоих языках, Bash и Python. Программисты
учатся работая, поэтому сейчас мы настоятельно рекомендуем вам из
менить в обеих программах, на языке Bash и Python, вызовы систем
ных команд своими собственными. Прибавьте себе несколько очков,
если вы добавили в сценарии несколько новых функций и предусмот
рели их вызов из главной функции.

### Повторное использование программного кода с помощью инструкции import.

Одна из проблем с освоением чего-либо нового состоит в том, что если
это новое достаточно абстрактная вещь, бывает очень сложно найти ей
применение. Когда в последний раз вам приходилось применять зна
ние математики, полученное в средней школе, в продуктовом магази
не? В предыдущих примерах было показано, как создавать функции,
которые представляют альтернативу простому последовательному вы
полнению команд оболочки. Мы также сообщили, что модуль – это
обычный сценарий или некоторое количество строк программного ко
да в файле. В этом подходе нет ничего сложного, но программный код
должен быть организован определенным способом, чтобы его можно
было повторно использовать в будущих программах. В этом разделе
мы покажем вам, почему это так важно. Давайте импортируем оба
предыдущих сценария сбора информации о системе и выполним их.
Откройте окна с IPython и Bash, если вы закрыли их, чтобы мы могли
быстро продемонстрировать, почему функции играют такую важную
роль с точки зрения повторного использования программного кода.
Один из наших первых сценариев на языке Python представлял собой
простую последовательность команд в файле с именем pysysinfo.py.
В языке Python файл является модулем и наоборот, поэтому мы мо
жем импортировать этот файл сценария в оболочку IPython. Обратите
внимание, вы никогда не должны указывать расширение .py файла
в инструкции импорта. Фактически попытка импорта окончится не
удачей, если расширение будет указано. Итак, мы выполнили импорт
сценария на ноутбуке Ноа Macbook Pro:

```
In [1]: import pysysinfo
Gathering system information with uname command:
Darwin Macintosh8.local 9.2.2 Darwin Kernel Version 9.2.2: /
Tue Mar 4 21:17:34 PST 2008; root:xnu1228.4.31~1/RELEASE_I386 i386
Gathering diskspace information df command:
Filesystem Size Used Avail Capacity Mounted on
/dev/disk0s2 93Gi 88Gi 4.2Gi 96% /
devfs 110Ki 110Ki 0Bi 100% /dev
fdesc 1.0Ki 1.0Ki 0Bi 100% /dev
maphosts 0Bi 0Bi 0Bi 100% /net
map auto_home 0Bi 0Bi 0Bi 100% /home
/dev/disk1s2 298Gi 105Gi 193Gi 36% /Volumes/Backup
/dev/disk2s3 466Gi 240Gi 225Gi 52% /Volumes/EditingDrive
```

Ух ты! Выглядит круто, правда? Когда импортируется файл, содержа
щий программный код на языке Python, он тут же выполняется. Но
в действительности за всем этим кроется несколько проблем. Если вы
планируете запускать такой программный код на языке Python, его
всегда придется запускать из командной строки как часть сценария
или программы, которую вы пишете. Операция импорта должна по
мочь в воплощении идеи «повторного использования программного
кода». Но вот что интересно: как быть, если нам потребуется получить
только информацию о распределении дискового пространства? В дан
ном сценарии это невозможно. Именно для этого используются функ
ции. Они позволяют контролировать, когда и какие части программы
должны выполняться, чтобы она не выполнялась целиком, как в при
мере выше. Если импортировать сценарий, где эти команды оформле
ны в виде функций, можно увидеть, что мы имеем в виду.
Ниже приводится результат импортирования сценария в терминале
IPython:

```
In [3]: import pysysinfo_func
Gathering system information with uname command:
Darwin Macintosh8.local 9.2.2 Darwin Kernel Version 9.2.2: /
Tue Mar 4 21:17:34 PST 2008; root:xnu1228.4.31~1/RELEASE_I386 i386
Gathering diskspace information df command:
Filesystem Size Used Avail Capacity Mounted on
/dev/disk0s2 93Gi 88Gi 4.2Gi 96% /
devfs 110Ki 110Ki 0Bi 100% /dev
fdesc 1.0Ki 1.0Ki 0Bi 100% /dev
maphosts 0Bi 0Bi 0Bi 100% /net
map auto_home 0Bi 0Bi 0Bi 100% /home
/dev/disk1s2 298Gi 105Gi 193Gi 36% /Volumes/Backup
/dev/disk2s3 466Gi 240Gi 225Gi 52% /Volumes/EditingDrive
```

Этот результат ничем не отличается от того, что был получен при использовании сценария без функций. Если вы озадачены, – это хороший знак. Чтобы понять, почему был получен тот же самый результат, достаточно заглянуть в исходный программный код. Откройте сценарий pysysinfo_func.py в другой вкладке или в другом окне терминала и найдите строки:

```
#Главная функция, которая вызывает остальные функции
def main():
uname_func()
disk_func()
main()
```

Проблема в том, что функция main, созданная нами в конце предыдущего раздела, обернулась для нас некоторой неприятностью. С одной
стороны, хотелось бы иметь возможность запускать сценарий из ко
мандной строки, чтобы получать полную информацию о системе, но
с другой стороны, нам совсем не нужно, чтобы модуль выводил чтоли
бо при импортировании. К счастью, потребность использовать модули
как в виде сценариев, выполняемых из командной строки, так и в виде
повторно используемых модулей достаточно часто встречается в языке
Python. Решение этой проблемы состоит в том, чтобы определить, ко
гда следует вызывать главную функцию, изменив последнюю часть
сценария, как показано ниже:

```
#Главная функция, которая вызывает остальные функции
def main():
uname_func()
disk_func()
if __name__ == "__main__":
main()
```

Эта «идиома» представляет прием, который обычно используется для решения данной проблемы. Любой программный код, входящий в состав блока этой условной инструкции, будет выполняться, только ко
гда модуль запускается из командной строки. Чтобы убедиться в этом, измените окончание своего сценария или импортируйте исправленную его версию pysysinfo_func_2.py.
Если теперь вернуться к оболочке IPython и импортировать новый
сценарий, вы должны увидеть следующее:

```
In [1]: import pysysinfo_func_2
```

На этот раз благодаря нашим исправлениям функция main вызвана не была. Итак, вернемся вновь к теме повторного использования программного кода: у нас имеется три функции, которые можно использо
вать в других программах или вызывать в интерактивной оболочке IPython. Вспомните: ранее мы говорили, что было бы неплохо иметь возможность вызвать только функцию, которая выводит информацию
о распределении дискового пространства. Сначала необходимо вновь вернуться к одной из возможностей оболочки IPython, которую мы уже демонстрировали ранее. Вспомните, как мы использовали клавишу Tab
для получения полного списка атрибутов модуля, доступных для использования. Ниже показано, как выглядит этот список для нашего модуля:

```
In [2]: pysysinfo_func_2.
pysysinfo_func_2.__builtins__ pysysinfo_func_2.disk_func
pysysinfo_func_2.__class__ pysysinfo_func_2.main
pysysinfo_func_2.__delattr__ pysysinfo_func_2.py
pysysinfo_func_2.__dict__ pysysinfo_func_2.pyc
pysysinfo_func_2.__doc__ pysysinfo_func_2.subprocess
pysysinfo_func_2.__file__ pysysinfo_func_2.uname_func
pysysinfo_func_2.__getattribute__
pysysinfo_func_2.__hash__
```

В этом примере пока можно проигнорировать все имена, содержащие
двойные символы подчеркивания, потому что они представляют специальные методы, описание которых выходит далеко за рамки этого
введения. Поскольку IPython – это обычная командная оболочка, она обнаружила файл с расширением .pyc , содержащий скомпилированный байт-код Python. Отбросив все эти ненужные имена, можно заметить в списке имя pysysinfo_func_2.disk_func. Попробуем вызвать ее:

```
In [2]: pysysinfo_func_2.disk_func()
Gathering diskspace information df command:
Filesystem Size Used Avail Capacity Mounted on
/dev/disk0s2 93Gi 88Gi 4.2Gi 96% /
devfs 110Ki 110Ki 0Bi 100% /dev
fdesc 1.0Ki 1.0Ki 0Bi 100% /dev
maphosts 0Bi 0Bi 0Bi 100% /net
map auto_home 0Bi 0Bi 0Bi 100% /home
/dev/disk1s2 298Gi 105Gi 193Gi 36% /Volumes/Backup
/dev/disk2s3 466Gi 240Gi 225Gi 52% /Volumes/EditingDrive
```

К настоящему моменту вы вероятно уже заметили, что функция «вызывается», или запускается, за счет указания круглых скобок «()» после ее имени. В данном случае мы использовали одну функцию из файла, содержащего три функции: disk_func, uname_func и, наконец, main.
Ага! Мы всетаки сумели найти способ повторного использования нашего программного кода. Мы импортировали модуль, написанный нами ранее, и в интерактивной оболочке выполнили только ту его часть,
которая была необходима. Безусловно, мы точно так же можем запустить и две другие функции. Давайте посмотрим на это:

```
In [3]: pysysinfo_func_2.uname_func()
Gathering system information with uname command:
Darwin Macintosh8.local 9.2.2 Darwin Kernel Version 9.2.2:
Tue Mar 4 21:17:34 PST 2008; root:xnu1228.4.31~1/RELEASE_I386 i386
```

```
In [4]: pysysinfo_func_2.main()
Gathering system information with uname command:
Darwin Macintosh8.local 9.2.2 Darwin Kernel Version 9.2.2:
Tue Mar 4 21:17:34 PST 2008; root:xnu1228.4.31~1/RELEASE_I386 i386
Gathering diskspace information df command:
Filesystem Size Used Avail Capacity Mounted on
/dev/disk0s2 93Gi 88Gi 4.2Gi 96% /
devfs 110Ki 110Ki 0Bi 100% /dev
fdesc 1.0Ki 1.0Ki 0Bi 100% /dev
maphosts 0Bi 0Bi 0Bi 100% /net
map auto_home 0Bi 0Bi 0Bi 100% /home
/dev/disk1s2 298Gi 105Gi 193Gi 36% /Volumes/Backup
/dev/disk2s3 466Gi 240Gi 225Gi 52% /Volumes/EditingDrive
```

Если вы были внимательны, вы должны были заметить, что были вызваны обе оставшиеся функции. Не забывайте, что функция main запускает две другие функции.
Часто требуется взять из модуля только часть его программного кода и повторно использовать его в другом сценарии. Поэтому попробуем написать еще один сценарий, который использует только одну из функций. Пример такого сценария приводится в примере 1.6.

_Пример 1.6. Повторное использование программного кода посредством импортирования: new_pysysinfo_

```
#Очень короткий сценарий, использующий программный код из pysysinfo_func_2 from pysysinfo_func_2 import disk_func
import subprocess
def tmp_space():
tmp_usage = "du"
tmp_arg = "-h"
path = "/tmp"
print "Space used in /tmp directory"
subprocess.call([tmp_usage, tmp_arg, path])
def main():
disk_func()
tmp_space()
if __name__ == "__main__":
main()
```

В этом примере мы не только повторно использовали программный
код, написанный ранее, но и использовали специальную синтаксиче
скую конструкцию, которая позволяет импортировать только необхо
димые функции. Вся прелесть повторного использования программно
го кода состоит в том, что мы можем создавать совершенно новые про
граммы, просто импортируя функции из других программ. Обратите
внимание, что в функции main вызывается функция disk_func() из дру
гого модуля, созданного нами, и новая, только что созданная, функ
ция tmp_space() из этого файла.
В этом разделе мы узнали, насколько богатой может быть возмож
ность повторного использования программного кода, и насколько про
сто ее использовать. В двух словах: вы помещаете однудве функции
в файл и затем, если вам требуется иметь возможность запускать сце
нарий из командной строки, используете специальную синтаксиче
скую конструкцию if__name__ == "__main__":. После этого можно либо
импортировать эти функции в оболочке IPython, либо просто исполь
зовать их в другом сценарии. Обладая этой информацией, вы станови
тесь понастоящему опасными. Теперь вы можете создавать на языке
Python довольно сложные модули и использовать их снова и снова при
создании новых инструментов.
