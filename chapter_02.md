## Глава 2. IPython

Одной из сильных сторон языка Python является его интерактивный интерпретатор, или оболочка. Оболочка обеспечивает возможность
быстро проверить идею, протестировать функциональные возможности и интерфейсы модулей, с которыми вы работаете, и выполнить какие-либо однократные действия, для которых в другом случае пришлось бы писать сценарии из трех строк. Обычно при программировании на языке Python мы открываем текстовый редактор и интерактивную оболочку Python (в действительности оболочку IPython, но к этому мы вскоре еще вернемся), взаимодействуя с ними обоими, переключаясь взад-вперед между оболочкой и редактором, часто копируя фрагменты программного кода из одного окна в другое. При таком подходе
мы можем быстро проверять работу программного кода в интерпретаторе и вставлять работоспособные и отлаженные фрагменты в текстовом редакторе.
В своей основе IPython представляет собой интерактивную оболочку Python. Эта удивительная оболочка обладает намного более широкими
возможностями по сравнению со стандартной интерактивной оболочкой Python. Она позволяет создавать командные окружения, настраиваемые в весьма широких пределах; дает возможность встраивать интерактивную оболочку Python в любое приложение, написанное на языке Python и, с определенными ограничениями, может даже использоваться в качестве системной командной оболочки. В этой главе мы остановимся на использовании IPython с целью повышения эффективности решения задач, связанных с программированием на языке Python в *nix-оболочках.
За оболочкой IPython стоит весьма сплоченное сообщество. Вы можете подписаться на почтовую рассылку на странице http://lists.ipython.scipy.org/mailman/listinfo/ipython-user. Существует замечательная страница вики (wiki) http://ipython.scipy.org/moin. И как часть этой страницы – сборник рецептов http://ipython.scipy.org/moin/Cookbook. На любом из этих ресурсов вы можете читать информацию или выкладывать свою. Еще одна область, где вы можете попробовать приложить свои знания и умения, – это разработка IPython. Недавно разработка IPython была переведена на использование распределенной системы управления версиями исходных текстов, благодаря которой вы можете получить срез исходных текстов и приступить к их изучению. Если вы сделаете что-то, что может пригодиться другим, вы можете передать им свои изменения.

### Установка IPython

Одной из сильных сторон языка Python является его интерактивный
интерпретатор, или оболочка. Оболочка обеспечивает возможность
быстро проверить идею, протестировать функциональные возможно
сти и интерфейсы модулей, с которыми вы работаете, и выполнить ка
киелибо однократные действия, для которых в другом случае при
шлось бы писать сценарии из трех строк. Обычно при программирова
нии на языке Python мы открываем текстовый редактор и интерактив
ную оболочку Python (в действительности оболочку IPython, но к этому
мы вскоре еще вернемся), взаимодействуя с ними обоими, переключа
ясь взадвперед между оболочкой и редактором, часто копируя фраг
менты программного кода из одного окна в другое. При таком подходе
мы можем быстро проверять работу программного кода в интерпрета
торе и вставлять работоспособные и отлаженные фрагменты в тексто
вом редакторе.
В своей основе IPython представляет собой интерактивную оболочку
Python. Эта удивительная оболочка обладает намного более широкими
возможностями по сравнению со стандартной интерактивной оболоч
кой Python. Она позволяет создавать командные окружения, настраи
ваемые в весьма широких пределах; дает возможность встраивать ин
терактивную оболочку Python в любое приложение, написанное на
языке Python и, с определенными ограничениями, может даже ис
пользоваться в качестве системной командной оболочки. В этой главе
мы остановимся на использовании IPython с целью повышения эффек
тивности решения задач, связанных с программированием на языке
Python в *nixоболочках.
За оболочкой IPython стоит весьма сплоченное сообщество. Вы можете
подписаться на почтовую рассылку на странице _[http://lists.ipython.sci>](http://lists.ipython.sci>)
py.org/mailman/listinfo/ipython>user_. Существует замечательная стра
ница вики (wiki) _[http://ipython.scipy.org/moin](http://ipython.scipy.org/moin)_. И как часть этой страницы – сборник рецептов http://ipython.scipy.org/moin/Cookbook. На
любом из этих ресурсов вы можете читать информацию или выклады
вать свою. Еще одна область, где вы можете попробовать приложить
свои знания и умения, – это разработка IPython. Недавно разработка
IPython была переведена на использование распределенной системы
управления версиями исходных текстов, благодаря которой вы може
те получить срез исходных текстов и приступить к их изучению. Если
вы сделаете чтото, что может пригодиться другим, вы можете пере
дать им свои изменения.

### Установка IPython

Существует несколько вариантов установки IPython. Первый, самый
традиционный, заключается в получении дистрибутива с исходными
текстами. Страница, откуда можно загрузить IPython, находится по
адресу http://ipython.scipy.org/dist/. К моменту написания этих строк
последней была версия IPython 0.8.2 и близилась к завершению работа
над версией 0.8.3. Чтобы установить IPython из исходных текстов, от
кройте страницу http://ipython.scipy.org/dist/ipython>0.8.2.tar.gz и за
грузите файл .tar.gz. Распаковать этот файл можно с помощью коман
ды tar zxvf ipython–0.8.2.tar.gz. В разархивированном каталоге будет

---

**ПОРТРЕТ ЗНАМЕНИТОСТИ: ПРОЕКТ IPYTHON**

**Фернандо Перез (Fernando Perez)**

Фернандо Перез – кандидат физикоматематических наук, занимался разработкой числовых алгоритмов на кафедре прикладной математики
университета в штате Колорадо. В настоящее время занимается научными изысканиями в институте неврологии имени Элен Уиллс (Helen Wills)
в Калифорнийском университете в городе Беркли, сосредоточившись на разработке новых методов анализа для
нужд моделирования мозговой деятельности и высокоуровне
вых инструментальных средств для научных вычислений. К мо
менту окончания обучения в аспирантуре он оказался вовлечен
в разработку инструментальных средств для научных расчетов
на языке Python. Он начал проект IPython в 2001 году, когда пы
тался разработать эффективный интерактивный инструмент для
решения повседневных научных задач. Благодаря расширяю
щемуся кругу разработчиков этот проект продолжал расти и за
эти годы превратился в инструмент, который будет полезен да
же программистам, далеким от научных исследований.

---

содержаться файл setup.py. Вызовите интерпретатор Python, передав
ему имя файла setup.py с параметром install (например, python setup.py
install). Эта команда установит библиотеки IPython в каталог site>pack>
ages и создаст сценарий ipython в каталоге scripts. В UNIX это обычно
тот же каталог, где находится исполняемый файл интерпретатора py
thon. Если вы используете python, установленный менеджером пакетов
вашей системы, то этот файл (а, следовательно, и ipython) скорее всего
будет находиться в каталоге /usr/bin. Мы у себя установили IPython
последней версии, которая еще находилась в разработке, поэтому в не
которых примерах вы будете видеть ее номер 0.8.3.
Второй вариант установки IPython заключается в установке пакета
с помощью вашей системы управления пакетами. Для Debian и Ubuntu
имеются доступные для установки пакеты .deb. Установка выполняет
ся простой командой apt–get install ipython. В Ubuntu библиотеки IPy
thon устанавливаются в соответствующее местоположение ( /usr/share/
python>support/ipython , куда помещается набор файлов .pth и символи
ческих ссылок, обеспечивающих корректную работу пакета). Кроме

---

**ПОРТРЕТ ЗНАМЕНИТОСТИ: ПРОЕКТ IPYTHON**

**Вилле Вайнио (Ville Vainio)**

Вилле Вайнио получил степень бакалавра инфор
матики в 2003 году в Сатакунтском университете
прикладных наук, на технологическом факультете
в городе Пори, Финляндия. К моменту начала ра
боты над этой книгой был нанят в качестве про
граммиста в отдел смартфонов компании Digia Plc,
где разрабатывает программное обеспечение на
языке C++ для платформы Symbian OS, разработанной компа
ниями Nokia и UIQ. Во время учебы работал программистом
в Cimcorp Oy, разрабатывал программное обеспечение на языке
Python для взаимодействия с промышленными роботами.
Вилле – давний приверженец IPython, а с 2006 года стал храни
телем стабильной ветки IPython (серия 0.x). Его работа в проек
те IPython началась с серии исправлений и улучшений IPython
в части системной командной оболочки для Windows, и эксплуа
тация этой системной командной оболочки до сих пор остается
в центре его внимания. Живет вместе со своей невестой в городе
Пори, Финляндия, и пишет дипломный проект на получение
степени магистра в местном филиале технологического универ
ситета г. Тампере, посвященный ILeo, который является про
граммным мостом между IPython и Leo и превращает Leo в ноут
бук с полноценной поддержкой IPython.

---

того в каталог /usr/bin/python устанавливается двоичный выполняемый файл ipython.
Третий вариант установки IPython заключается в использовании пакета Python. Вы могли даже не предполагать, что в Python существует такая вещь, как пакет, и, тем не менее, это так. Пакеты в языке Python – это файлы с расширением .egg , представляющие собой архивы формата ZIP. Пакеты можно устанавливать с помощью утилиты easy_install. Одна из замечательных особенностей утилиты easy_install заключается в том, что она проверяет центральный репозитарий
пакетов и отыскивает необходимый пакет. За кулисами происходит
несколько больше, чем только поиск пакета, однако для пользователя
установка выполняется очень просто. Репозитарий называется ката
логом пакетов Python (Python Package Index), или PyPI для краткости
(хотя некоторые нежно называют его Python CheeseShop (сырная лав
ка Python)). Чтобы воспользоваться утилитой easy_install, необходи
мо зарегистрироваться в системе под учетной записью, которая обла
дает правом записи в каталог site>packages , и запустить команду
easy_install ipython.
Четвертый вариант заключается в использовании IPython вообще без
установки. «Что?», – можете вы спросить. Дело в том, что если загру
зить дистрибутив с исходными текстами и просто запустить сценарий
ipython.py из корневого каталога с набором файлов, то вы получите ра
ботающий экземпляр загруженной версии IPython. Этот способ подой
дет тем, кто не желает загромождать свой каталог site>packages , хотя
вам придется учитывать некоторые ограничения этого варианта. Если
вы запускаете IPython из каталога, куда вы распаковали файл дистри
бутива, и при этом не изменили переменную окружения PYTHONPATH, вы
не сможете использовать этот продукт как библиотеку.

### Базовые понятия.

После того как оболочка IPython будет установлена, и вы в первый раз
запустите команду ipython, вы увидите примерно следующее:

```
jmjones@dink:~$ ipython
**********************************************************************
Welcome to IPython. I will try to create a personal configuration directory
where you can customize many aspects of IPython's functionality in:
(Добро пожаловать в IPython. Я попробую создать персональный каталог
с настройками, где вы сможете настраивать разные аспекты IPython:)
/home/jmjones/.ipython
```

```
Successful installation!
(Установка выполнена благополучно!)
```

```
Please read the sections 'Initial Configuration' and 'Quick Tips' in the
IPython manual (there are both HTML and PDF versions supplied with the distribution) to make sure that your system environment is properly
configured to take advantage of IPython's features.
(Пожалуйста, прочитайте разделы 'Initial Configuration' и 'Quick Tips'
в руководстве к IPython (в состав дистрибутива входит как HTML, так и PDF
версия), чтобы суметь убедиться, что системное окружение настроено должным
образом для использования IPython)
```

```
Important note: the configuration system has changed! The old system is
still in place, but its setting may be partly overridden by the settings in
"~/.ipython/ipy_user_conf.py" config file. Please take a look at the file
if some of the new settings bother you.
(Важное примечание: файл с настройками системы был изменен! Прежняя система
осталась на месте, но ее настройки могут оказаться частично переопределенными
настройками в файле "~/.ipython/ipy_user_conf.py". Пожалуйста, загляните
в этот файл, если новые значения параметров представляют для вас интерес.)
```

```
Please press <RETURN> to start IPython.
(Чтобы запустить IPython, нажмите клавишу <RETURN>)
```

```
После нажатия на клавишу Return IPython выведет следующий текст:
jmjones@dinkgutsy:stabledev$ python ipython.py
Python 2.5.1 (r251:54863, Mar 7 2008, 03:39:23)
Type "copyright", "credits" or "license" for more information.
(Введите "copyright", "credits" или "license", чтобы получить
дополнительную информацию)
```

```
IPython 0.8.3.bzr.r96 An enhanced Interactive Python.
?> Introduction and overview of IPython's features.
(Введение и обзор возможностей IPython)
%quickref> Quick reference.
(Краткий справочник)
help> Python's own help system.
(Собственная справочная система Python)
object?> Details about 'object'. ?object also works, ?? prints more.
(Подробности об 'object'. ?object также допустимо,
?? выведет более подробную информацию)
In [1]:
```

#### Взаимодействие с IPython**

Обычно, когда сталкиваешься с новой командной строкой, в первый
момент чувствуешь некоторую беспомощность. Совершенно непонят
но – что делать дальше. Помните, как вы в первый раз вошли в систе
му UNIX и столкнулись с командной оболочкой (ba|k|c|z)sh? Раз уж вы
читаете эту книгу, мы полагаем, что у вас уже имеется некоторый
опыт работы с командной оболочкой в операционной системе UNIX.
Если это действительно так, тогда обрести навыки работы в IPython
будет совсем просто.
Одна из причин, по которым непонятно, как действовать делать в обо
лочке IPython, состоит в том, что она практически не ограничивает
ваших действий. Поэтому здесь уместнее думать о том, что бы вы хоте
ли сделать. В командной оболочке IPython вам доступны все функцио
нальные возможности языка Python. Плюс несколько «магических»
функций IPython. Вы с легкостью можете запустить любую команду
UNIX в оболочке IPython и сохранить вывод в переменной Python. Сле
дующие примеры демонстрируют, что можно ожидать от IPython с на
стройками по умолчанию.
Ниже приводится пример выполнения некоторых простых операций
присваивания:

```
In [1]: a = 1
In [2]: b = 2
In [3]: c = 3
```

Пока не видно существенных отличий от стандартной командной оболочки интерпретатора Python, если ввести в ней те же инструкции.
Здесь мы просто присвоили значения 1, 2 и 3 переменным a, b и c, соот
ветственно. Самое большое отличие между IPython и стандартной обо
лочкой Python, которое можно наблюдать здесь, состоит в том, что
оболочка IPython выводит порядковый номер строки приглашения
к вводу.
Теперь, когда у нас имеется несколько переменных (a, b и c), которым
были присвоены значения (1, 2 и 3, соответственно), можно посмот
реть, какие именно значения они содержат:

```
In [4]: print a
1
In [5]: print b
2
In [6]: print c
3
```

Конечно, это надуманный пример, потому что мы только что ввели эти
значения, и можно было прокрутить назад окно, чтобы их увидеть.
Вывод значения каждой переменной потребовал ввода с клавиатуры
на шесть символов больше, чем это действительно необходимо. Ниже
приводится более краткий способ отображения значений переменных:

```
In [7]: a
Out[7]: 1
In [8]: b
Out[8]: 2
In [9]: c
Out[9]: 3
```

Несмотря на то, что результаты этих двух способов выглядят практически одинаковыми, тем не менее, здесь имеются некоторые различия. Инструкция print использует «неофициальное» строковое представление, тогда как при использовании одного только имени переменной выводится «официальное» строковое представление. Обычно
разница между этим двумя представлениями более заметна при работе
не со встроенными, а с собственными классами. Ниже приводится
пример различий между этими двумя строковыми представлениями:

```
In [10]: class DoubleRep(object):
....: def __str__(self):
....: return "Hi, I'm a __str__"
....: def __repr__(self):
....: return "Hi, I'm a __repr__"
....:
....:
In [11]: dr = DoubleRep()
In [12]: print dr
Hi, I'm a __str__
In [13]: dr
Out[13]: Hi, I'm a __repr__
```

Здесь с целью демонстрации различий между «официальным» и «не
официальным» строковыми представлениями объекта создается класс
DoubleRep, обладающий двумя методами – __str__ и __repr__. Специаль
ный метод __str__ объекта вызывается, когда требуется получить его
«неофициальное» строковое представление. Специальный метод
__repr__ объекта вызывается, когда требуется получить его «офици
альное» строковое представление. После создания экземпляра класса
DoubleRep и присваивания его в качестве значения переменной dr мы
выводим значение dr с помощью инструкции print. Вызывается метод
__str__. Затем в строке приглашения к вводу мы просто вводим имя пе
ременной, в результате чего вызывается метод __repr__. Таким обра
зом, когда мы просто вводим имя переменной, оболочка IPython выво
дит ее «официальное» строковое представление. Когда мы используем
инструкцию print, то получаем «неофициальное» строковое представ
ление. Вообще в языке Python метод __str__ вызывается, когда проис
ходит обращение к функции str(obj), которой передается желаемый
объект, или когда он используется в строке форматирования, такой
как эта: "%s" % obj. Когда происходит обращение к функции repr(obj)
или используется строка форматирования, такая как "%r" % obj, вызы
вается метод __repr__.
Как бы то ни было, такой характер поведения не является особенно
стью исключительно оболочки IPython. Это особенность поведения ин
терпретатора Python. Ниже приводится тот же самый пример использо
вания класса DoubleRep в стандартной интерактивной оболочке Python:

```
>>> class DoubleRep(object):
... def __str__(self):
... return "Hi, I'm a __str__"
... def __repr__(self):
... return "Hi, I'm a __repr__"
...
>>>
>>> dr = DoubleRep()
>>> print dr
Hi, I'm a __str__
>>> dr
Hi, I'm a __repr__
```

Вероятно, вы обратили внимание, что строки приглашения к вводу
в стандартной оболочке Python и в оболочке IPython отличаются друг
от друга. Строка приглашения в стандартной оболочке Python состоит
из трех символов «больше» (>>>), тогда как в IPython приглашение со
держит слово «In», за которым следует число в квадратных скобках
идвоеточие (In [1]:). Оказывается, оболочка IPython запоминает ко
манды, которые вводились, и сохраняет их в списке с именем In. Так,
после присваивания значений 1, 2 и 3 переменным a, b и c в предыду
щем примере содержимое списка In выглядит следующим образом:

```
In [4]: print In
['\n', u'a = 1\n', u'b = 2\n', u'c = 3\n', u'print In\n']
```

Формат вывода результатов в IPython также отличается от вывода
в стандартной оболочке Python. Создается впечатление, что оболочка
IPython поразному выводит значения в инструкции print и вычислен
ные. В действительности же оболочка IPython не делает никаких раз
личий между этими двумя типами. Просто вызовы инструкций print
являются побочным эффектом вычислений, поэтому оболочка IPython
не видит их и не может их перехватить. Эти побочные проявления ин
струкции print отражаются только на стандартном потоке вывода std
out, куда передаются результаты запроса. Однако в ходе выполнения
программного кода пользователя IPython оболочка контролирует воз
вращаемые значения. Если возвращаемое значение не равно None, оно
выводится в строке с подсказкой Out [число]:.
В стандартной оболочке Python различия между этими двумя способа
ми вывода вообще не видны. Если инструкция, введенная в строке
приглашения IPython, вычисляет некоторое значение, отличное от
None, оболочка выведет его в строке, которая начинается со слова Out, за
которым следует число в квадратных скобках, символ двоеточия и зна
чение, вычисленное инструкцией (например, Out[1]: 1 ). В следующем
примере показано, как в оболочке IPython выполняется присваивание
целочисленного значения переменной, как отображается значение пе
ременной в результате ее оценки и как выводится значение этой же пе
ременной с помощью инструкции print. Сначала в оболочке IPython:

```
In [1]: a = 1
```
```
In [2]: a
Out[2]: 1
In [3]: print a
1
In [4]:
```

```
А теперь в стандартной оболочке Python:
>>> a = 1
>>> a
1
>>> print a
1
>>>
```

В действительности нет никаких различий между тем, как в оболочках IPython и Python выполняется присваивание. Обе оболочки немед
ленно выводят приглашение к вводу. Но «официальное» строковое
представление переменной в оболочке IPython и в стандартной оболоч
ке Python отображается поразному. В оболочке IPython выводится
строкаподсказка Out, тогда как в оболочке Python просто выводится
значение переменной. В случае же использования инструкции print
никаких различий не наблюдается – в обеих оболочках выводится
только значение.
Наличие подсказок In [некоторое число]: и Out [некоторое число]: может
вызвать вопрос: имеются ли какиенибудь более глубокие различия
между IPython и стандартной оболочкой Python, или они носят исклю
чительно косметический характер. Определенно, различия намного
глубже. То есть видимые отличия от стандартной оболочки Python обу
словлены функциональными возможностями оболочки IPython.
В оболочке IPython имеются две встроенные переменные, о существо
вании вам необходимо знать. Это переменные с именами In и Out. Пер
вая из них представляет объект списка, в котором сохраняются вве
денные команды, а вторая – объект словаря. Вот что сообщает встроен
ная функция type о каждой из них:

```
In [1]: type(In)
Out[1]: <class 'IPython.iplib.InputList'>
In [2]: type(Out)
Out[2]: <type 'dict'>
```

Когда вы начнете пользоваться переменными In и Out, эти различия между ними приобретут особое значение.
Итак, что же хранится в этих переменных?

```
In [3]: print In
['\n', u'type(In)\n', u'type(Out)\n', u'print In\n']
```

```
In [4]: print Out
{1: <class 'IPython.iplib.InputList'>, 2: <type 'dict'>}
```

Как и следовало ожидать, переменные In и Out содержат, соответствен
но, отличные от None ввод команд и выражений и результаты выполне
ния инструкций и выражений. Поскольку каждая строка непременно
содержит некоторый ввод, определенно имеет смысл сохранять вве
денные команды в виде такой структуры, как список. Но сохранение
вывода в виде списка может привести к появлению элементов, кото
рые содержат только значение None. Поэтому, т. к. не каждая введен
ная команда возвращает значение, отличное от None, есть смысл сохра
нять вывод в такой структуре данных, как словарь.

#### Дополнение


Другая невероятно полезная особенность IPython – функция дополне
ния, привязанная к клавише табуляции. Стандартная оболочка Py
thon также обладает функцией дополнения – при условии, что интер
претатор скомпилирован с поддержкой библиотеки readline, но для ее
активации необходимо выполнить следующие действия:

```
>>> import rlcompleter, readline
>>> readline.parse_and_bind('tab: complete')
```

Это позволит вам выполнять такие манипуляции, как показано ниже:

```
>>> import os
>>> os.lis<TAB>
>>> os.listdir
>>> os.li<TAB><TAB>
os.linesep os.link os.listdir
```

После импортирования модулей rlcompleter и readline и настройки параметра дополнения в модуле readline мы оказались в состоянии после импортирования модуля os ввести os.lis, нажать клавишу Ta b один раз и получить дополнение до os.listdir. Точно так же, после ввода os.li мы получили список возможных вариантов дополнения, нажав клавишу Tab дважды.
Ту же самую функциональность можно получить в оболочке IPython, причем для этого не требуется выполнять подготовительных операций. То есть данная возможность в стандартной оболочке Python присутствует, а в IPython она активирована по умолчанию. Ниже приводится предыдущий пример, выполненный в оболочке IPython:

```
In [1]: import os
In [2]: os.lis<TAB>
In [2]: os.listdir
In [2]: os.li<TAB>
os.linesep os.link os.listdir
```

Обратите внимание: в последней части примера нам пришлось нажать клавишу табуляции всего один раз.
Этот пример всего лишь демонстрирует возможность поиска и допол
нения атрибутов в оболочке IPython, но IPython, что может оказаться
более привлекательным, может дополнять и имена модулей в инструк
ции импортирования. Откройте новую оболочку IPython, чтобы мож
но было увидеть, как IPython помогает отыскивать импортируемый
модуль:

```
In [1]: import o
opcode operator optparse os os2emxpath ossaudiodev
```
```
In [1]: import xm
xml xmllib xmlrpclib
```

Обратите внимание, что все предлагаемые варианты дополнения являются именами модулей, то есть это уже не случайное совпадение. Это
функциональная особенность.
В оболочке IPython есть два варианта дополнения: «дополнение» и «меню с дополнениями». При использовании первого варианта текущее
«слово» дополняется по мере возможности и затем предлагается пере
чень альтернатив, при втором варианте слово дополняется полностью
до одной из альтернатив, а каждое последующее нажатие клавиши Ta b
предоставляет трансформацию слова до следующей альтернативы. По
умолчанию в оболочке IPython используется вариант «дополнение».
К вопросам настройки IPython мы подойдем очень скоро.

#### Специальная функция редактирования

Последняя тема, касающаяся вводавывода, которую мы затронем, – это специальная функция edit. (Подробнее об специальных функциях
мы поговорим в следующем разделе.) Взаимодействие пользователя
с оболочкой, основанное на вводе строк, имеет огромное, но ограни
ченное значение. Так как это утверждение выглядит неоднозначным,
попробуем развернуть его. Возможность ввода команд по одной строке
за раз очень удобна. Вы вводите команду, а оболочка выполняет ее,
причем иногда приходится ждать некоторое время, пока команда бу
дет выполнена, а после этого вы вводите следующую команду.
В такой цикличности работы нет ничего плохого. В действительности
такой способ взаимодействия достаточно эффективен. Но иногда воз
никает необходимость ввести сразу целый блок строк. Было бы непло
хо иметь возможность использовать для этого предпочитаемый тексто
вый редактор, хотя аналогичную возможность предоставляет поддерж
ка readline в IPython. Мы уже знаем, как использовать текстовый ре
дактор для создания модулей на языке Python, но это не совсем то, что
мы имеем в виду. Мы подразумеваем некоторый компромисс между
строчноориентированным способом ввода и способом ввода в тексто
вом редакторе, который обеспечивает возможность передавать ко
мандной оболочке целые блоки строк с командами. Если можно ска
зать, что добавление поддержки возможности работы с блоками строк совсем нелишне, это значит, что строчноориентированный интерфейс
имеет некоторые ограничения. Т. е. можно сказать, что строчноориен
тированный интерфейс исключительно удобен, и в то же время имеет
некоторые ограничения.
Специальная функция edit как раз и представляет собой упомянутый
выше компромисс между строчноориентированным способом ввода
в оболочке Python и способом ввода с привлечением текстового редак
тора. Преимущества такого компромисса состоят в том, что вы полу
чаете в свои руки мощные возможности обоих способов редактирова
ния. В вашем распоряжении имеются все преимущества вашего люби
мого текстового редактора. Вы легко можете редактировать блоки
программного кода и изменять строки в пределах циклов, методов или
функций. Плюс к этому вы не лишаетесь простоты и гибкости непо
средственного взаимодействия с оболочкой. Комбинирование этих
двух подходов еще больше усиливает их положительные стороны. Вы
получаете возможность управлять своим рабочим окружением непо
средственно из оболочки, вы можете приостанавливать работу, редак
тировать и выполнять программный код из текстового редактора. При
возобновлении работы в оболочке вам будут доступны все изменения,
выполненные в текстовом редакторе.

#### Настройка IPython

Последняя из «основ», о которой вам следует знать, – это порядок на
стройки IPython. Если вы не указывали иное местоположение при пер
вом запуске оболочки IPython, она создаст каталог .ipython в вашем до
машнем каталоге. Внутри каталога .ipython имеется файл с именем
ipy_user_conf.py. Это обычный конфигурационный файл пользовате
ля, в котором хранятся настройки, оформленные в виде синтаксиче
ских конструкций на языке Python. Конфигурационный файл хранит
большое разнообразие элементов, позволяющих настраивать внешний
вид и функциональные возможности IPython под себя. Например,
имеется возможность выбрать цветовую гамму для оболочки, опреде
лить компоненты строки приглашения и выбрать текстовый редактор,
который автоматически будет использоваться функцией %edit для
ввода текста. Мы не будем углубляться в пояснения. Просто знайте,
что такой конфигурационный файл существует и он стоит того, что
бы ознакомиться с его содержимым, – возможно, в нем вы найдете
некоторые параметры, которые потребуется изменить.

### Справка по специальным функциям.


Как мы уже говорили, оболочка IPython обладает весьма широкими
возможностями. Такая широта обусловлена наличием просто огром
ного числа встроенных специальных функций. Так что же такое спе
циальная функция? В документации к IPython говорится:
Оболочка IPython рассматривает любую строку, начинающуюся
ссимвола %, как вызов «специальной» функции. Эти функции по
зволяют управлять поведением самой оболочки IPython и добавля
ют ряд особенностей для работы с системой. Все имена специальных
функций начинаются с символа %, при этом параметры передаются
без использования круглых скобок или кавычек.
Пример: выполнение команды '%cd mydir' (без кавычек) изменит ра
бочий каталог на «mydir», если таковой существует.
Просмотреть и разобраться в этом многообразии дополнительных воз
можностей вам помогут две «специальные» функции. Первая специ
альная справочная функция, которую мы рассмотрим, – это функция
lsmagic. Функция lsmagic выводит список всех «специальных» функ
ций. Ниже приводится результат работы функции lsmagic:

```
In [1]: lsmagic
Available magic functions:
%Exit %Pprint %Quit %alias %autocall %autoindent %automagic %bg
%bookmark %cd %clear %color_info %colors %cpaste %debug %dhist %dirs
%doctest_mode %ed %edit %env %exit %hist %history %logoff %logon
%logstart %logstate %logstop %lsmagic %macro %magic %p %page %pdb
%pdef %pdoc %pfile %pinfo %popd %profile %prun %psearch %psource
%pushd %pwd %pycat %quickref %quit %r %rehash %rehashx %rep %reset
%run %runlog %save %sc %store %sx %system_verbose %time %timeit
%unalias %upgrade %who %who_ls %whos %xmode
Automagic is ON, % prefix NOT needed for magic functions.
(Автоматически ВКЛЮЧЕННЫЕ специальные функции, префикс %
для них НЕ требуется)
```

Как видите, существует огромное число доступных для вас специаль
ных функций. Фактически, к моменту написания этих строк, сущест
вовало 69 специальных функций. Вы могли бы счесть более удобным
получить список специальных функций следующим способом:

```
In [2]: %<TAB>
%Exit %debug %logstop %psearch %save
%Pprint %dhist %lsmagic %psource %sc
%Quit %dirs %macro %pushd %store
%alias %doctest_mode %magic %pwd %sx
%autocall %ed %p %pycat %system_verbose
%autoindent %edit %page %quickref %time
%automagic %env %pdb %quit %timeit
%bg %exit %pdef %r %unalias
%bookmark %hist %pdoc %rehash %upgrade
%cd %history %pfile %rehashx %who
%clear %logoff %pinfo %rep %who_ls
%color_info %logon %popd %reset %whos
%colors %logstart %profile %run %xmode
%cpaste %logstate %prun %runlog
```

Ввод последовательности %–TAB в результате дает отформатированный список 69 специальных функций. Одним словом, функция lsmagic
икомбинация %–TAB позволят вам быстро получить список всех имею
щихся специальных функций, когда вы ищете чтото определенное
или чтобы ознакомиться с тем, что вам доступно. Но список без описа
ния не в состоянии помочь вам понять, для чего предназначена каж
дая функция.
Здесь к вам на помощь придет другая специальная справочная функ
ция. Эта функция называется magic. Функция magic позволяет получить
справочное описание всех специальных функций, встроенных в обо
лочку IPython. В справочную информацию включаются имя функции,
порядок ее использования (область применения) и описание принципа
действия функции. Ниже приводится описание функции page:
%page:
Pretty print the object and display it through a pager.
(Форматирует объект и отображает его с помощью программы
постраничного просмотра)
%page [options] OBJECT

```
If no object is given, use _ (last output).
(Если объект не указан, используется _ (последний введенный))
```

```
Options:
(Параметры)
```

```
r: page str(object), don't prettyprint it.
(r: page str(object), вывод информации в неформатированном виде)
```

В зависимости от используемой программы постраничного просмотра
вы можете выполнять поиск и прокручивать результаты работы функ
ции magic. Это может пригодиться, если вы знаете, что искать, чтобы
перейти сразу к нужной странице вместо того, чтобы прокручивать
описание к нужному месту. Описания функций упорядочены по алфа
виту, что поможет вам быстро отыскать нужную функцию.
Можно также использовать и другой метод получения справочной ин
формации, с которым мы познакомимся ниже в этой главе. Если вве
сти имя специальной функции и знак вопроса после нее (?), вы получи
те практически ту же самую информацию, что и с помощью функции
%magic. Ниже приводится результат выполнения команды %page ?:

```
In [1]: %page?
Type: Magic function
Base Class: <type 'instancemethod'>
String Form: <bound method InteractiveShell.magic_page of
<IPython.iplib.InteractiveShell object at 0x2ac5429b8a10>>
Namespace: IPython internal
File: /home/jmjones/local/python/psa/lib/python2.5/
sitepackages/IPython/Magic.py
Definition: %page(self, parameter_s='')
Docstring:
Pretty print the object and display it through a pager.
```
```
%page [options] OBJECT
If no object is given, use _ (last output).
```
```
Options:
r: page str(object), don't prettyprint it.
```

И, наконец, еще одна справочная функция IPython, которая выводит
сводный отчет об использовании различных возможностей, а также
информацию о самих специальных функциях. Если в строке пригла
шения IPython ввести команду %quickref, вы получите справочник, который начинается со следующих строк:

```
IPython An enhanced Interactive Python Quick Reference Card
(IPython – Расширенная интерактивная оболочка Python – краткий справочник)
================================================================
```
```
obj?, obj?? : Get help, or more help for object (also works as
?obj, ??obj).
(Справка или подробная справка об объекте (допускается также
?obj, ??obj).)
?foo.*abc* : List names in 'foo' containing 'abc' in them.
(список имен в 'foo', содержащих 'abc')
%magic : Information about IPython's 'magic' % functions.
(Информация о специальных функциях % IPython)
```
```
Magic functions are prefixed by %, and typically take their arguments without
parentheses, quotes or even commas for convenience.
(Имена специальных функций начинаются с % и обычно принимают аргументы без
использования скобок, кавычек и даже запятых)
```
```
Example magic function calls:
(Примеры вызова специальных функций)
```
```
%alias d lsF : 'd' is now an alias for 'ls F'
(теперь 'd' – псевдоним для 'ls –F')
alias d lsF : Works if 'alias' not a python name
(Допустимо, если alias не является именем объекта Python)
alist = %alias : Get list of aliases to 'alist'
(Записывает список псевдонимов в переменную 'alist')
cd /usr/share : Obvious. cd<tab> to choose from visited dirs.
(Очевидно. cd<tab> для выбора из посещавшихся каталогов)
%cd?? : See help AND source for magic %cd
(См. справку И исходные тексты для специальной функции %cd)
```
```
System commands:
!cp a.txt b/ : System command escape, calls os.system()
(Экранирование системных команд, вызывается os.system())
cp a.txt b/ : after %rehashx, most system commands work without!
(после %rehashx, большинство системных команд работают без !)
cp ${f}.txt $bar : Variable expansion in magics and system commands
(Подстановка имен переменных в специальных функциях
и в системных командах)
files = !ls /usr : Capture sytem command output
(Захватывает вывод системной команды)
files.s, files.l, files.n: "a b c", ['a','b','c'], 'a\nb\nc'
```

и заканчивается следующими строками:

```
%time:
Time execution of a Python statement or expression.
(Время выполнения инструкции или вычисления выражения)
%timeit:
Time execution of a Python statement or expression
(Время выполнения инструкции или вычисления выражения)
%unalias:
Remove an alias
(Удаляет псевдоним)
%upgrade:
Upgrade your IPython installation
(Обновляет версию IPython)
%who:
Print all interactive variables, with some minimal formatting.
(Выводит все интерактивные переменные с минимальным форматированием)
%who_ls:
Return a sorted list of all interactive variables.
(Возвращает отсортированный список всех интерактивных переменных)
%whos:
Like %who, but gives some extra information about each variable.
(Подобна функции %who, но выводит дополнительные сведения
о каждой переменной)
%xmode:
Switch modes for the exception handlers.
(Переключает режим обработки исключений)
```

В самом начале вывода, получаемого от функции %quickref, приводится справочная информация о различных функциональных возможностях оболочки IPython. Остальная часть справочника %quickref представляет собой краткое описание всех специальных функций. Это краткое описание включает в себя первую строку из полной справки по каждой специальной функции. Например, ниже приводится полное описание функции %who:

```
In [1]: %who?
Type: Magic function
Base Class: <type 'instancemethod'>
String Form: <bound method InteractiveShell.magic_who of
<IPython.iplib.InteractiveShell object at 0x2ac9f449da10>>
Namespace: IPython internal
File: /home/jmjones/local/python/psa/lib/python2.5/
sitepackages/IPython/Magic.py
Definition: who(self, parameter_s='')
Docstring:
Print all interactive variables, with some minimal formatting.
(Выводит все интерактивные переменные с минимальным форматированием)
```

```
If any arguments are given, only variables whose type matches one of
these are printed. For example:
(Если указан какойлибо параметр, будут выведены переменные только
соответствующего типа. Например:)
```

```
%who function str
will only list functions and strings, excluding all other types of
variables. To find the proper type names, simply use type(var) at
a command line to see how python prints type names. For example:
(выведет только имена функций и строковых переменных, исключая переменные
любых других типов. Чтобы отыскать требуемое имя типа, просто используйте
команду type(var), которая вернет имя типа в языке Python. Например:)
In [1]: type('hello')
Out[1]: <type 'str'>
indicates that the type name for strings is 'str'.
(указывает, что строки принадлежат к типу с именем 'str')
%who always excludes executed names loaded through your configuration
file and things which are internal to IPython.
(%who всегда исключает выполняемые имена, загруженные
из конфигурационного файла, и наименования,
являющиеся внутренними сущностями IPython.)
```

```
This is deliberate, as typically you may load many modules and the
purpose of %who is to show you only what you've manually defined.
(Сделано это преднамеренно, так как может быть загружено множество
модулей, а назначение функции %who состоит в том, чтобы показывать
только имена, определенные вручную.)
```

```
Справочная информация о функции %who, присутствующая в выводе
функции %quickref, полностью идентична первой строке в разделе Doc
string в блоке информации, которая возвращается командой %who ?.
```

### Командная оболочка UNIX

У работы в командной оболочке UNIX есть свои преимущества (из кото
рых можно назвать унифицированный подход к решению проблем, бо
гатый набор инструментов, достаточно краткий и простой синтаксис,
стандартные потоки вводавывода, конвейеры и перенаправление), но
для нас было бы просто замечательно добавить этому старому другу еще
и возможности Python. Оболочка IPython обладает рядом особенно
стей, которые повышают ценность соединения этих двух оболочек.


#### alias


Первая особенность объединения оболочки Python/UNIX, которую мы
рассмотрим, – это специальная функция alias. С помощью этой функции можно создавать сокращенные псевдонимы системных команд.
Чтобы определить псевдоним, достаточно просто ввести имя функции
alias и далее указать системную команду (с любыми допустимыми параметрами). Например:

```
In [1]: alias nss netstatlptn
In [2]: nss
(Not all processes could be identified, nonowned process info
will not be shown, you would have to be root to see it all.)
(Не все процессы могут быть опознаны, информация о процессах, которыми
вы не владеете, отображаться не будет, вы должны иметь привилегии
пользователя root, чтобы увидеть все процессы.)
Active Internet connections (only servers)
(Активные соединения с Интернетом (только серверы)))
Proto RecvQ SendQ Local Address Foreign Address State
tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN
tcp 0 0 127.0.0.1:631 0.0.0.0:* LISTEN
```

Существует несколько способов передать дополнительные данные на
вход псевдонима. Один из них – пассивный подход. Если все, что тре
буется передать псевдониму, допустимо смешивать в одну кучу, такой
подход может оказаться полезным. Например, если с помощью утили
ты grep из результатов команды netstat, показанных выше, необходи
мо отобрать только те, где номер порта равен 80, можно выполнить та
кую команду:

```
In [3]: nss | grep 80
(Not all processes could be identified, nonowned process info
will not be shown, you would have to be root to see it all.)
tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN
```
```
Такой подход не годится, когда требуется передать дополнительные
параметры, но для подобных случаев вполне подойдет.
Другой способ – активный подход. Он очень напоминает пассивный
подход за исключением того, что наряду с неявными параметрами вы
явно обрабатываете все последующие аргументы. Ниже приводится
пример, демонстрирующий обработку всех дополнительных парамет
ров как единой группы:
```
```
In [1]: alias achoo echo "|%l|"
In [2]: achoo
||
In [3]: achoo these are args
|these are args|
```

Здесь используется синтаксическая конструкция %l (знак процента, за
которым следует символ «l»), которая вставляет оставшуюся часть ко
мандной строки в псевдоним. В реальной жизни такой прием, скорее всего, использовался бы для вставки остальной части строки кудани
будь в середину команды, для которой создается псевдоним.
И вот вам пример пассивного подхода, переделанный так, чтобы явно
обрабатывать все дополнительные аргументы:

```
In [1]: alias nss netstatlptn %l
In [2]: nss
(Not all processes could be identified, nonowned process info
will not be shown, you would have to be root to see it all.)
Active Internet connections (only servers)
Proto RecvQ SendQ Local Address Foreign Address State
tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN
tcp 0 0 127.0.0.1:631 0.0.0.0:* LISTEN
```

```
In [3]: nss | grep 80
(Not all processes could be identified, nonowned process info
will not be shown, you would have to be root to see it all.)
tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN
```

В действительности, в этом примере не требовалось добавлять конструкцию %l. Если ее опустить, результат не изменится.
Для вставки параметров в середину командной строки можно было бы
использовать параметр подстановки строки %s. Следующий пример демонстрирует, как выполняется обработка параметров:

```
In [1]: alias achoo echo first: "|%s|", second: "|%s|"
```
```
In [2]: achoo foo bar
first: |foo|, second: |bar|
```

Однако здесь может возникнуть проблема. Если псевдониму, который
ожидает получить два параметра, передать только один, можно ждать
появление ошибки:

```
In [3]: achoo foo
ERROR: Alias <achoo> requires 2 arguments, 1 given.
```
```
AttributeError Traceback (most recent call last)
```
```
С другой стороны, вполне безопасно можно передавать большее число
параметров:
In [4]: achoo foo bar bam
first: |foo|, second: |bar| bam
```

Параметры foo и bar были помещены в соответствующие позиции, а параметр bam просто был добавлен в конец, чего и следовало ожидать.
Сохранить псевдоним можно с помощью специальной функции %store, и ниже в этой главе будет показано, как это делается. Продолжая предыдущий пример, мы можем сохранить псевдоним achoo, чтобы при
следующем запуске оболочки IPython его можно было использовать:

```
In [5]: store achoo
Alias stored: achoo (2, 'echo first: "|%s|", second: "|%s|"')
```
```
In [6]:
Do you really want to exit ([y]/n)?
(psa)jmjones@dinkgutsy:code$ ipythonnobanner
In [1]: achoo one two
first: |one|, second: |two|
```

#### Выполнение системных команд


Другой и, пожалуй, более простой способ выполнения системных ко
манд заключается в использовании восклицательного знака (!) перед
ними:

```
In [1]: !netstatlptn
(Not all processes could be identified, nonowned process info
will not be shown, you would have to be root to see it all.)
Active Internet connections (only servers)
Proto RecvQ SendQ Local Address Foreign Address State
tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN
tcp 0 0 127.0.0.1:631 0.0.0.0:* LISTEN
```

Имеется возможность передавать системным командам значения пе
ременных, при этом имена переменных должны начинаться со знака
доллара ($). Например:

```
In [1]: user = 'jmjones'
```
```
In [2]: process = 'bash'
In [3]: !ps aux | grep $user | grep $process
jmjones 5967 0.0 0.4 21368 4344 pts/0 Ss+ Apr11 0:01 bash
jmjones 6008 0.0 0.4 21340 4304 pts/1 Ss Apr11 0:02 bash
jmjones 8298 0.0 0.4 21296 4280 pts/2 Ss+ Apr11 0:04 bash
jmjones 10184 0.0 0.5 22644 5608 pts/3 Ss+ Apr11 0:01 bash
jmjones 12035 0.0 0.4 21260 4168 pts/15 Ss Apr15 0:00 bash
jmjones 12943 0.0 0.4 21288 4268 pts/5 Ss Apr11 0:01 bash
jmjones 15720 0.0 0.4 21360 4268 pts/17 Ss 02:37 0:00 bash
jmjones 18589 0.1 0.4 21356 4260 pts/4 Ss+ 07:04 0:00 bash
jmjones 18661 0.0 0.0 320 16 pts/15 R+ 07:06 0:00 grep bash
jmjones 27705 0.0 0.4 21384 4312 pts/7 Ss+ Apr12 0:01 bash
jmjones 32010 0.0 0.4 21252 4172 pts/6 Ss+ Apr12 0:00 bash
```
Здесь перечислены все сеансы работы с командной оболочкой bash,
принадлежащие пользователю jmjones.
Ниже приводится пример сохранения результатов команды !:

```
In [4]: l = !ps aux | grep $user | grep $process
In [5]: l
```
```
Out[5]: SList (.p, .n, .l, .s, .grep(), .fields() available). Value:
0: jmjones 5967 0.0 0.4 21368 4344 pts/0 Ss+ Apr11 0:01 bash
1: jmjones 6008 0.0 0.4 21340 4304 pts/1 Ss Apr11 0:02 bash
2: jmjones 8298 0.0 0.4 21296 4280 pts/2 Ss+ Apr11 0:04 bash
3: jmjones 10184 0.0 0.5 22644 5608 pts/3 Ss+ Apr11 0:01 bash
4: jmjones 12035 0.0 0.4 21260 4168 pts/15 Ss Apr15 0:00 bash
5: jmjones 12943 0.0 0.4 21288 4268 pts/5 Ss Apr11 0:01 bash
6: jmjones 15720 0.0 0.4 21360 4268 pts/17 Ss 02:37 0:00 bash
7: jmjones 18589 0.1 0.4 21356 4260 pts/4 Ss+ 07:04 0:00 bash
8: jmjones 27705 0.0 0.4 21384 4312 pts/7 Ss+ Apr12 0:01 bash
9: jmjones 32010 0.0 0.4 21252 4172 pts/6 Ss+ Apr12 0:00 bash
```

Обратите внимание, что результат работы команды, сохраненный в пе
ременной l, отличается от результата, полученного в предыдущем
примере. Это потому, что переменная l содержит объект списка, тогда
как в предыдущем примере демонстрировался обычный вывод коман
ды. Подробнее объекты списков мы будем рассматривать в разделе
«Обработка строк».
Альтернативой использованию символа! является использование ком
бинации !!. Эта комбинация обеспечивает возможность выполнять те
же самые действия, что и !, за исключением того, что не позволяет со
хранять результат в переменной. Но при ее использовании открывает
ся возможность использовать конструкции _ и _[0–9]*, которые будут
обсуждаться ниже, в разделе «История результатов».
Использование! или !! перед системными командами определенно со
ставляет меньше труда, чем создание псевдонимов, однако в одних слу
чаях более предпочтительными могут оказаться псевдонимы, а в дру
гих – использование! или !!. Например, если предполагается, что не
которая команда будет использоваться постоянно, лучше создать для
нее псевдоним. Для однократного или очень редкого использования
лучше применять! или !!.

#### rehash


Существует еще один способ создания псевдонимов и/или выполнения
системных команд из оболочки IPython, основанный на применении
специальной функции rehash (выполняющей рехеширование). С тех
нической точки зрения, она создает псевдонимы системных команд,
но не совсем так, как это делали бы вы сами. Специальная функция re
hash дополняет «таблицу псевдонимов» всем, что будет обнаружено
в пути поиска файлов, определяемым переменной окружения PATH. Вы
можете спросить: «Что это за таблица псевдонимов?». Когда создают
ся псевдонимы, оболочка IPython отображает имена псевдонимов на
системные команды, с которыми они должны быть ассоциированы.
Таблица псевдонимов как раз и описывает эти отображения.
Для рехеширования таблицы псевдонимов предпочтительнее
использовать специальную функцию rehashx, а не rehash. Мы
представим обе функции и покажем, как они работают, а затем
опишем имеющиеся между ними отличия.
Во время работы оболочка IPython предоставляет в ваше распоряже
ние ряд переменных, таких как In и Out, с которыми мы уже встреча
лись ранее. Одна из таких переменных называется __IP. Она представ
ляет собой объект интерактивной оболочки. Атрибут этого объекта,
с именем alias_table, ссылается на эту таблицу. Это именно то место,
где хранятся отображения имен псевдонимов на системные команды.
Мы можем просматривать эту таблицу точно так же, как любую другую переменную:

```
In [1]: __IP.alias_table
Out[1]:
{'cat': (0, 'cat'),
'clear': (0, 'clear'),
'cp': (0, 'cpi'),
'lc': (0, 'lsF ocolor'),
'ldir': (0, 'lsF ocolor %l | grep /$'),
'less': (0, 'less'),
'lf': (0, 'lsF ocolor %l | grep ^'),
'lk': (0, 'lsF ocolor %l | grep ^l'),
'll': (0, 'lslF'),
'lrt': (0, 'lslart'),
'ls': (0, 'lsF'),
'lx': (0, 'lsF ocolor %l | grep ^..x'),
'mkdir': (0, 'mkdir'),
'mv': (0, 'mvi'),
'rm': (0, 'rmi'),
'rmdir': (0, 'rmdir')}
```
```
Эта таблица выглядит как словарь:
In [2]: type(__IP.alias_table)
```
```
Out[2]: <type 'dict'>
```
```
Вид может оказаться обманчивым, но это не тот случай.
В настоящий момент в этом словаре имеется 16 элементов:
In [3]: len(__IP.alias_table)
```
```
Out[3]: 16
```
```
После вызова функции rehash объем словаря значительно увеличился:
```
```
In [4]: rehash
In [5]: len(__IP.alias_table)
```
```
Out[5]: 2314
```
```
Попробуем отыскать в нем то, чего не было прежде, но что должно бы
ло появиться, – теперь в словаре должна появиться утилита transcode:
In [6]: __IP.alias_table['transcode']
```
```
Out[6]: (0, 'transcode')
```

Когда вам встречается имя переменной или атрибута, начи
нающееся с двух символов подчеркивания (__), как правило,
это означает, что программист не предполагал, что вы будете
изменять содержимое этой переменной. Мы обратились к пе
ременной __IP, но только для того, чтобы продемонстрировать
вам внутреннее устройство. В случае необходимости мы могли
бы воспользоваться официальным прикладным интерфейсом
(API) IPython и обратиться к объекту _ip, доступному из ко
мандной строки оболочки IPython.

#### rehashx

Специальная функция rehashx по своему действию напоминает специ
альную функцию rehash, за исключением того, что при просмотре ка
талогов, перечисленных в переменной окружения PATH, она добавляет
в таблицу псевдонимов только имена исполняемых файлов. Поэтому
резонно предположить, что сразу после запуска оболочки IPython в ре
зультате работы функции rehashx таблица псевдонимов будет иметь
тот же или меньший объем, как после запуска функции rehash:
```
In [1]: rehashx
```
```
In [2]: len(__IP.alias_table)
Out[2]: 2307
```

Интересно: после запуска функции rehashx размер таблицы псевдони
мов оказался на семь элементов меньше, чем после вызова функции
rehash. Ниже приводятся эти семь отличий:

```
In [3]: from sets import Set
```
```
In [4]: rehashx_set = Set(__IP.alias_table.keys())
In [5]: rehash
```
```
In [6]: rehash_set = Set(__IP.alias_table.keys())
In [7]: rehash_set rehashx_set
```
```
Out[7]: Set(['fusermount', 'rmmod.modutils', 'modprobe.modutils', 'kallsyms',/
'ksyms', 'lsmod.modutils', 'X11'])
```

И если поинтересоваться, почему, например, файл rmmod.modutils был
отобран функцией rehash, но не был отобран функцией rehashx, можно
обнаружить следующее:

```
jmjones@dinkgutsy:Music$ slocate rmmod.modutils
/sbin/rmmod.modutils
jmjones@dinkgutsy:Music$ lsl /sbin/rmmod.modutils
lrwxrwxrwx 1 root root 15 20071207 10:34 /sbin/rmmod.modutils>
insmod.modutils
jmjones@dinkgutsy:Music$ lsl /sbin/insmod.modutils
ls: /sbin/insmod.modutils: No such file or directory
```

Здесь видно, что rmmod.utils – это ссылка на insmod.modutils, но ins
mod.modutils отсутствует на диске.

#### cd

Если вам приходилось работать в стандартной оболочке Python, то,
возможно, вы заметили, что в ней достаточно сложно определить имя
каталога, в котором вы находитесь. Можно использовать функцию
os.chdir(), чтобы перейти в нужный каталог, но это не очень удобно.
Имя текущего каталога можно узнать с помощью функции os.get
cwd(), но это тоже крайне неудобно. Поскольку в стандартной оболочке
Python выполняются команды языка Python, это может выглядеть не
такой большой проблемой, но при работе в оболочке IPython и нали
чии более простого доступа к системным командам достаточно важно
иметь возможность более простого перемещения по каталогам.
Попробуйте воспользоваться специальной функцией cd. Вам кажется,
что мы придаем этому большее значение, чем оно заслуживает: здесь
нет ничего революционного и вполне можно обойтись без этой функ
ции. Но только представьте, что ее нет. Жизнь без нее оказалась бы на
много сложнее.
В оболочке IPython функция cd работает практически так же, как од
ноименная команда Bash. Типичный пример ее использования: cd
directory_name. Этого вполне можно было ожидать из опыта работы
в Bash. При вызове без аргументов функция cd выполняет переход
в домашний каталог пользователя. Если после имени функции доба
вить пробел и дефис, cd – , она выполнит переход в предыдущий ката
лог. Функция cd может принимать три дополнительных аргумента,
которые отсутствуют у одноименной команды в Bash.
Первый аргумент: –q, или quiet. Если этот аргумент не указать, IPy
thon будет выводить имя каталога, куда был выполнен переход. В сле
дующем примере демонстрируются способы изменения текущего ка
талога как с применением аргумента – q, так и без него:
```
```
In [1]: cd /tmp
/tmp
In [2]: pwd
Out[2]: '/tmp'
```
```
In [3]: cd
/home/jmjones
```
```
In [4]: cdq /tmp
In [5]: pwd
```
```
Out[5]: '/tmp'
```

Указание аргумента q запрещает IPython вывод имени каталога /tmp ,
в который был выполнен переход.
Еще одной особенностью функции cd в IPython является возможность
перехода по определенным ранее закладкам. (Вскоре мы объясним,
как они создаются.) В следующем примере показано, как выполнить
переход в каталог по созданной ранее закладке:

```
In [1]: cdb t
(bookmark:t)> /tmp
/tmp
```
```
В этом примере предполагается, что ранее для каталога /tmp была соз
дана закладка с именем t. Формально синтаксис перехода в каталог по
закладке имеет следующий вид: cd – b bookmark_name, но если закладка
bookmark_name определена и в текущем каталоге отсутствует подкаталог
bookmark_name , то ключ –b можно опустить – в этом случае оболочка
IPython предполагает, что вы собираетесь выполнить переход по за
кладке.
Последняя дополнительная особенность, которую предлагает функ
ция cd в оболочке IPython, заключается в возможности перейти в опре
деленный каталог, присутствующий в списке ранее посещавшихся ка
талогов. Ниже приводится пример использования этого списка:

```
0: /home/jmjones
1: /home/jmjones/local/Videos
2: /home/jmjones/local/Music
3: /home/jmjones/local/downloads
4: /home/jmjones/local/Pictures
5: /home/jmjones/local/Projects
6: /home/jmjones/local/tmp
7: /tmp
8: /home/jmjones
In [2]: cd6
/home/jmjones/local/tmp
```

В первой части примера приводится список ранее посещавшихся ката
логов. Как его получить, мы совсем скоро расскажем. Затем следует
вызов функции cd, которой передается числовой аргумент – 6. Он сооб
щает оболочке IPython, что нам требуется перейти в каталог, который
находится в списке под номером «6», то есть в каталог /home/jmjones/
local/tmp. И в последней строке оболочка сообщает, что теперь вы на
ходитесь в каталоге /home/jmjones/local/tmp.

#### bookmark

Мы только что продемонстрировали, как использовать закладки
в функции cd для перехода в требуемый каталог. А теперь мы пока
жем, как создавать эти закладки и как ими управлять. Следует упомя
нуть, что закладки сохраняются между сеансами работы с оболочкой
IPython. Если завершить работу с оболочкой, а затем вновь запустить ее, закладки будут восстановлены. Создать закладку можно двумя
способами. Ниже демонстрируется первый из них:

```
In [1]: cd /tmp
/tmp
```
```
In [2]: bookmark t
```
```
Выполнив команду bookmark t после перехода в каталог /tmp , мы созда
ли закладку с именем t, указывающую на каталог /tmp. Второй способ
создания закладки требует ввести более чем одно слово:
```
```
In [3]: bookmark muzak /home/jmjones/local/Music
```
```
Здесь была создана закладка с именем muzak, которая указывает на ло
кальный каталог с музыкой. Первый аргумент – это имя закладки,
а второй – имя каталога, на который ссылается закладка.
Получить список закладок, которых у нас к настоящему моменту все
го две, можно с помощью параметра –l. Посмотрим, как выглядит спи
сок всех наших закладок:
In [4]: bookmarkl
Current bookmarks:
muzak> /home/jmjones/local/Music
t> /tmp
```
```
Удалять закладки можно двумя способами: удалить сразу все заклад
ки или только выбранную. В следующем примере создается новая за
кладка, затем она удаляется, а после этого удаляются все остальные
закладки:
In [5]: bookmark ulb /usr/local/bin
```
```
In [6]: bookmarkl
Current bookmarks:
muzak> /home/jmjones/local/Music
t> /tmp
ulb> /usr/local/bin
In [7]: bookmarkd ulb
```
```
In [8]: bookmarkl
Current bookmarks:
muzak> /home/jmjones/local/Music
t> /tmp
```
```
Вместо команды bookmark – l можно использовать команду cd – b:
In [9]: cdb<TAB>
muzak t
```
```
Нажав несколько раз клавишу Backspace, продолжим с того места, где
остановились:
In [9]: bookmarkr
In [10]: bookmarkl
Current bookmarks:
```

В этом примере сначала была создана закладка с именем ulb, указы
вающая на каталог /usr/local/bin. Затем она была удалена с помощью
аргумента –d bookmark_name команды bookmark. В конце были удалены
все закладки с помощью аргумента –r.

#### dhist

В примере использования функции cd был продемонстрирован список
посещавшихся ранее каталогов. Этот список сохраняется не только
в течение сеанса, но и между сеансами работы с оболочкой IPython.
Ниже демонстрируется пример вызова функции dhist без аргументов:

```
In [1]: dhist
Directory history (kept in _dh)
0: /home/jmjones
1: /home/jmjones/local/Videos
2: /home/jmjones/local/Music
3: /home/jmjones/local/downloads
4: /home/jmjones/local/Pictures
5: /home/jmjones/local/Projects
6: /home/jmjones/local/tmp
7: /tmp
8: /home/jmjones
9: /home/jmjones/local/tmp
10: /tmp
```
```
Быстро получить доступ к этому списку можно с помощью команды
cd – <TAB>, как показано ниже:
In [1]: cd<TAB>
00 [/home/jmjones]06 [/home/jmjones/local/tmp]
01 [/home/jmjones/local/Videos]07 [/tmp]
02 [/home/jmjones/local/Music]08 [/home/jmjones]
03 [/home/jmjones/local/downloads]09 [/home/jmjones/local/tmp]
04 [/home/jmjones/local/Pictures]10 [/tmp]
05 [/home/jmjones/local/Projects]
Две дополнительных возможности функции dhist делают ее более гиб
кой, чем команда cd – <TAB>. В первом случае имеется возможность ука
зать, сколько каталогов должно быть отображено. Например, чтобы
указать, что требуется отобразить только пять последних посещав
шихся каталогов, можно воспользоваться такой командой:
In [2]: dhist 5
Directory history (kept in _dh)
6: /home/jmjones/local/tmp
7: /tmp
8: /home/jmjones
9: /home/jmjones/local/tmp
10: /tmp
```

Во втором – определить диапазон элементов списка посещавшихся
ранее каталогов. Например, чтобы просмотреть каталоги в списке
с третьего по шестой, можно выполнить следующую команду:
In [3]: dhist 3 7
Directory history (kept in _dh)
3: /home/jmjones/local/downloads
4: /home/jmjones/local/Pictures
5: /home/jmjones/local/Projects
6: /home/jmjones/local/tmp
```
```
Обратите внимание: элемент списка с номером, соответствующим вто
рому аргументу, не включается в вывод, поэтому второе число должно
соответствовать порядковому номеру элемента списка, следующему
непосредственно за последним каталогом, который требуется вывести.

#### pwd


Это простая функция, но она часто бывает необходима при навигации
в дереве каталогов. Функция pwd выводит имя текущего каталога. На
пример:

```
In [1]: cd /tmp
/tmp
In [2]: pwd
```
```
Out[2]: '/tmp'
```
**Подстановка переменных**

```
Предыдущие особенности оболочки IPython определенно удобны и не
обходимы, но следующие три особенности доставят массу удоволь
ствия искушенным пользователям. Первая из них – подстановка имен
переменных. До настоящего момента мы использовали в командной
оболочке только то, что имеет отношение к командной оболочке,
а в Python – только то, что принадлежит языку Python. Но теперь мы
попробуем соединить это вместе. То есть мы попробуем взять значе
ние, которое было получено интерпретатором Python, и передать его
командной оболочке:
In [1]: for i in range(10):
...: !date > ${i}.txt
...:
...:
In [2]: ls
0.txt 1.txt 2.txt 3.txt 4.txt 5.txt 6.txt 7.txt 8.txt 9.txt
In [3]: !cat 0.txt
Sat Mar 8 07:40:05 EST 2008
```

```
Это достаточно надуманный пример. Едва ли вам потребуется создать
10 текстовых файлов, каждый из которых содержит дату. Но этот при
мер наглядно демонстрирует, как смешивать программный код на
языке Python с программным кодом на языке командной оболочки.
В этом примере выполняются итерации по списку, созданному функ
цией range(), каждый элемент которого поочередно сохраняется в пе
ременной i. В каждой итерации с использованием нотации! вызыва
ется системная утилита date. Обратите внимание, что синтаксис вы
зова date идентичен способу, который использовался бы, если бы мы
определили переменную окружения i. При таком подходе производит
ся вызов утилиты date, а ее вывод перенаправляется в файл с именем
{текущий элемент списка}.txt. После этого в примере выводится спи
сок созданных файлов и даже содержимое одного из них, чтобы убе
диться, что он содержит нечто, напоминающее дату.
В системную оболочку можно передавать любые значения, получен
ные в Python. Независимо от того, получены эти значения из базы дан
ных, созданы в ходе вычислений, получены в результате обращения
к службе XMLRPC или извлечены из текстового файла, вы можете по
лучить их средствами языка Python и передать системной команде,
применяя прием с использованием !.
```
**Обработка строк**

```
Другой невероятно мощной особенностью, которую предлагает обо
лочка IPython, является возможность обрабатывать строки, получен
ные от системных команд. Предположим, что нам необходимо полу
чить идентификаторы всех процессов (PID), принадлежащих пользо
вателю jmjones. Для этого можно было бы использовать следующую ко
манду:
ps aux | awk '{if ($1 == "jmjones") print $2}'
```
```
Эта команда выглядит достаточно компактной и понятной. Но попро
буем решить ту же самую задачу средствами IPython. Для начала по
лучим вывод от команды ps aux:
In [1]: ps = !ps aux
```
```
In [2]:
```

Результат работы команды ps aux сохраняется в переменной ps в виде
списка, элементами которого являются строки, полученные от систем
ной команды. Под словами «в виде списка» в данном случае подразу
мевается, что переменная принадлежит к встроенному типу list, по
этому она поддерживает все методы, принадлежащие этому типу. Бла
годаря этому, если у вас имеется функция, которая ожидает получить
список, вы можете передать ей полученный объект с результатами.
Кроме того, помимо стандартных методов списка она поддерживает еще пару весьма интересных методов и один атрибут, которые могут
вам пригодиться. Только ради того, чтобы продемонстрировать эти
«интересные методы», мы пока отложим задачу получения всех про
цессов, принадлежащих пользователю jmjones. Первый «интересный
метод» – это метод grep(). Фактически он представляет собой обычный
фильтр, который определяет, какие строки оставить, а какие отбро
сить. Чтобы узнать, имеются ли какиенибудь строки, содержащие
слово lighthttp, мы могли бы воспользоваться следующей командой:

```
In [2]: ps.grep('lighttpd')
Out[2]: SList (.p, .n, .l, .s, .grep(), .fields() available). Value:
0: wwwdata 4905 0.0 0.1........0:00 /usr/sbin/lighttpdf /etc/lighttpd/l
```

Здесь мы вызвали метод grep() и передали ему регулярное выражение
'lighthttp'. Запомните: регулярные выражения, которые передаются
методу grep(), не чувствительны к регистру символов. В результате это
го вызова метода grep() была получена строка, где было найдено соот
ветствие регулярному выражению 'lighthttp'. Чтобы получить все за
писи, за исключением тех, что соответствуют указанному регулярному
выражению, мы могли бы использовать примерно такую команду:

```
In [3]: ps.grep('Mar07', prune=True)
Out[3]: SList (.p, .n, .l, .s, .grep(), .fields() available). Value:
0: USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
1: jmjones 19301 0.0 0.4 21364 4272 pts/2 Ss+ 03:58 0:00 bash
2: jmjones 21340 0.0 0.9 202484 10184 pts/3 Sl+ 07:00 0:06 vim ipytho
3: jmjones 23024 0.0 1.1 81480 11600 pts/4 S+ 08:58 0:00 /home/jmjo
4: jmjones 23025 0.0 0.0 0 0 pts/4 Z+ 08:59 0:00 [sh] <defu
5: jmjones 23373 5.4 1.0 81160 11196 pts/0 R+ 09:20 0:00 /home/jmjo
6: jmjones 23374 0.0 0.0 3908 532 pts/0 R+ 09:20 0:00 /bin/shc
7: jmjones 23375 0.0 0.1 15024 1056 pts/0 R+ 09:20 0:00 ps aux
```

Мы передали методу grep() регулярное выражение 'Mar07' и обнару
жили, что большинство процессов было запущено 7 марта, поэтому мы
решили получить все процессы, которые были запущены не 7 марта.
Чтобы исключить все записи, соответствующие регулярному выраже
нию 'Mar07', мы добавили еще один аргумент: prune=True. Этот имено
ванный аргумент сообщает оболочке IPython, что «любые записи, со
ответствующие указанному регулярному выражению, должны быть
отброшены». И, как видите, в полученном списке нет ни одной запи
си, соответствующей регулярному выражению 'Mar07'.
С методом grep() можно также использовать функции обратного вызо
ва. Это означает, что метод grep() может принимать в виде аргумента
функцию и вызывать ее. Он передает функции текущий элемент спи
ска. Если функция возвращает True для этого элемента, он включается
в итоговый набор. Например, мы могли бы получить содержимое ката
лога и оставить в нем только файлы или только каталоги:

```
In [1]: import os
In [2]: file_list = !ls
```
```
In [3]: file_list
Out[3]: SList (.p, .n, .l, .s, .grep(), .fields() available). Value:
0: ch01.xml
1: code
2: ipython.pdf
3: ipython.xml
```

Этот каталог содержит «файлы». Мы не можем сказать, какие из них
действительно являются файлами, а какие каталогами, но если вос
пользоваться фильтром os.path.isfile(), мы сможем отобрать только
те, которые являются файлами:

```
In [4]: file_list.grep(os.path.isfile)
Out[4]: SList (.p, .n, .l, .s, .grep(), .fields() available). Value:
0: ch01.xml
1: ipython.pdf
2: ipython.xml
```

В этом списке отсутствует «файл» code , следовательно, он вообще не
является файлом. Попробуем отобрать каталоги:

```
In [5]: file_list.grep(os.path.isdir)
```
```
Out[5]: SList (.p, .n, .l, .s, .grep(), .fields() available). Value:
0: code
```

Теперь видно, что code действительно является каталогом. Другой ин
тересный метод – это метод fields(). После (или даже до) того, как бу
дет выполнена фильтрация набора результатов в соответствии с опре
деленными требованиями, вы можете отобразить те поля, которые же
лательно было бы вывести. Вернемся к нашему предыдущему примеру,
где выводились записи о процессах, запущенных не 7 марта, и выведем
только информацию в полях USER, PID и START:
In [4]: ps.grep('Mar07', prune=True).fields(0, 1, 8)
```
```
Out[4]: SList (.p, .n, .l, .s, .grep(), .fields() available). Value:
0: USER PID START
1: jmjones 19301 03:58
2: jmjones 21340 07:00
3: jmjones 23024 08:58
4: jmjones 23025 08:59
5: jmjones 23373 09:20
6: jmjones 23374 09:20
7: jmjones 23375 09:20
```
```
Вопервых, обратите внимание, что метод fields() применяется к ре
зультатам, возвращаемым методом grep(). Это возможно потому, что
метод grep() возвращает объект того же типа, что и объект ps. Метод fields() так же возвращает объект того же типа, что и метод grep().
Благодаря этому мы смогли объединить в цепочку методы grep()
иfields(). Теперь подробнее о том, что здесь происходит. Метод fields()
принимает неопределенное число аргументов, которые, как предпола
гается, обозначают номера «колонок» в выводе, при этом предполага
ется, что колонки отделяются пробелами. Это очень похоже на то, как
awk разбивает строки текста. В данном случае методу fields() предпи
сывается вывести колонки с порядковыми номерами 0, 1 и 8. Эти но
мера соответствуют колонкам USER, PID и START.
Теперь вернемся к задаче отображения идентификаторов всех процес
сов (PID), принадлежащих пользователю jmjones:
In [5]: ps.fields(0, 1).grep('jmjones').fields(1)
```
```
Out[5]: SList (.p, .n, .l, .s, .grep(), .fields() available). Value:
0: 5385
1: 5388
2: 5423
3: 5425
4: 5429
5: 5431
6: 5437
7: 5440
8: 5444
<продолжение списка...>
```
```
В этом примере сначала отбираются только первые два столбца, 0 и 1,
которые соответствуют колонкам USER и PID, соответственно. Затем из
полученного списка, с помощью метода grep(), отбираются только те
записи, которые соответствуют регулярному выражению 'jmjones'.
И в заключение, из полученного набора выводится только второе поле
с помощью вызова метода fields(1). (Не забывайте, что нумерация по
лей начинается с нуля.)
Последний элемент, имеющий отношение к обработке строк, из тех,
которые нам хотелось бы продемонстрировать, – это атрибут s объек
та, который позволяет получить непосредственный доступ к списку.
Возможно, что результаты, которые дает сам объект, – не совсем то,
что вам хотелось бы получить. Поэтому для передачи ваших данных
системной командной оболочке используйте атрибут s списка:
```
```
In [6]: ps.fields(0, 1).grep('jmjones').fields(1).s
Out[6]: '5385 5388 5423 5425 5429 5431 5437 5440 5444 5452 5454 5457
5458 5468 5470 5478 5480 5483 5489 5562 5568 5593 5595 5597 5598 5618
5621 5623 5628 5632 5640 5740 5742 5808 5838 12707 12913 14391 14785
19301 21340 23024 23025 23373 23374 23375'
```
```
При обращении к атрибуту s возвращается обычная строка, содержа
щая идентификаторы процессов, разделенные пробелами, с которой
можно работать средствами командной оболочки. При желании этот список в виде строки можно было сохранить в переменной с именем
pids и затем в оболочке IPython выполнить, например, такую команду:
kill $pids. Но такая команда послала бы сигнал SIGTERM всем процес
сам, принадлежащим пользователю jmjones, что привело бы к завер
шению работы текстового редактора и сеанса IPython.
Ранее уже демонстрировалось, что та же самая задача может быть ре
шена с помощью однострочного сценария на языке awk:
ps aux | awk '{if ($1 == "jmjones") print $2}'
```
```
Мы будем готовы добиться тех же результатов после того, как рассмот
рим еще одну концепцию. Метод grep() принимает еще один необяза
тельный параметр с именем field. Если параметр field определен, во
время принятия решения о включении очередного элемента в резуль
тат критерий поиска будет применяться к указанному полю:
In [1]: ps = !ps aux
```
```
In [2]: ps.grep('jmjones', field=0)
Out[2]: SList (.p, .n, .l, .s, .grep(), .fields() available). Value:
0: jmjones 5361 0.0 0.1 46412 1828? SL Apr11
0:00 /usr/bin/gnomekeyringdaemond
1: jmjones 5364 0.0 1.4 214948 14552? Ssl Apr11
0:03 xsessionmanager
....
53: jmjones 32425 0.0 0.0 3908 584? S Apr15
0:00 /bin/sh /usr/lib/firefox/runmozilla.
54: jmjones 32429 0.1 8.6 603780 88656? Sl Apr15
2:38 /usr/lib/firefox/firefoxbin
```
```
В этом случае были отобраны требуемые строки, но они были получе
ны целиком. Чтобы отобрать только идентификаторы процессов, мож
но предусмотреть следующее действие:
```
```
In [3]: ps.grep('jmjones', field=0).fields(1)
Out[3]: SList (.p, .n, .l, .s, .grep(), .fields() available). Value:
0: 5361
1: 5364
....
53: 32425
54: 32429
```
```
Теперь мы имеем средства достичь той же цели, что и фильтр на языке
awk.
```
**Профиль sh**

```
Одно из понятий IPython, которое еще не было описано, – это про
филь. Профиль – это набор конфигурационных данных, которые за
гружаются при запуске оболочки IPython. Имеется возможность создавать произвольное число профилей для настройки IPython в зависи
мости от потребностей. Для вызова определенной конфигурации сле
дует использовать ключ командной строки –p и указать имя желаемого
профиля.
Профиль sh (или shell) – это один из встроенных профилей IPython.
Профиль sh определяет значения некоторых конфигурационных пара
метров, в результате чего оболочка IPython становится более дружест
венной по отношению к системной командной оболочке. Приведем два
примера параметров конфигурации, имеющих значения, отличные от
значений в стандартном профиле IPython: параметр, задающий ото
бражение текущего каталога в строке приглашения к вводу, и пара
метр, задающий рехеширование каталогов, перечисленных в перемен
ной окружения PATH, что обеспечивает моментальный доступ ко всем
исполняемым файлам, к которым он имеется, например, в оболочке
Bash.
Помимо установки некоторых конфигурационных значений профиль
sh активирует некоторые полезные расширения. Например, он акти
вирует расширение envpersist. Расширение envpersist позволяет изме
нять различные переменные окружения и запоминать их значения
впрофиле sh, благодаря чему ликвидируется необходимость обнов
лять содержимое файла .bash_profile или .bashrc.
Ниже показано, как выглядит значение переменной PATH:
```
```
jmjones@dinkgutsy:tmp$ ipythonp sh
IPython 0.8.3.bzr.r96 [on Py 2.5.1]
[~/tmp]|2> import os
[~/tmp]|3> os.environ['PATH']
<3> '/home/jmjones/local/python/psa/bin:
/home/jmjones/apps/lb/bin:/home/jmjones/bin:
/usr/local/sbin:/usr/local/bin:/usr/sbin:
/usr/bin:/sbin:/bin:/usr/games'
```
```
Теперь добавим :/appended в конец значения переменной PATH:
[~/tmp]|4> env PATH+=:/appended
PATH after append = /home/jmjones/local/python/psa/bin:
/home/jmjones/apps/lb/bin:/home/jmjones/bin:
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:
/sbin:/bin:/usr/games:/appended
```
```
а /prepended: в начало:
[~/tmp]|5> env PATH=/prepended:
PATH after prepend = /prepended:/home/jmjones/local/python/psa/bin:
/home/jmjones/apps/lb/bin:/home/jmjones/bin:/usr/local/sbin:
/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/appended
```
```
Теперь посмотрим содержимое переменной PATH с помощью os.environ:
```
```
[~/tmp]|6> os.environ['PATH']
<6> '/prepended:/home/jmjones/local/python/psa/bin:
/home/jmjones/apps/lb/bin:/home/jmjones/bin:
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:
/bin:/usr/games:/appended'
```
```
Закроем оболочку IPython:
[~/tmp]|7>
Do you really want to exit ([y]/n)?
jmjones@dinkgutsy:tmp$
```
```
Теперь откроем снова оболочку IPython, чтобы взглянуть на содержи
мое переменной PATH:
```
```
jmjones@dinkgutsy:tmp$ ipythonp sh
IPython 0.8.3.bzr.r96 [on Py 2.5.1]
[~/tmp]|2> import os
[~/tmp]|3> os.environ['PATH']
<3> '/prepended:/home/jmjones/local/python/psa/bin:
/home/jmjones/apps/lb/bin:/home/jmjones/bin:/usr/local/sbin:
/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/appended'
```
```
Как видите, добавленные значения остались на своих местах, и при
этом нам не потребовалось изменять какиелибо конфигурационные
сценарии. Значение переменной PATH было сохранено без нашего вме
шательства. Теперь посмотрим, какие наши изменения переменных
окружения сохраняются:
```
```
[~/tmp]|4> envp
<4> {'add': [('PATH', ':/appended')], 'pre': [('PATH', '/
prepended:')],
'set': {}}
```
```
Мы можем удалить сохраняемые изменения значения переменной PATH:
[~/tmp]|5> envd PATH
Forgot 'PATH' (for next session)
```
```
и проверить получившееся значение переменной PATH:
```
```
[~/tmp]|6> os.environ['PATH']
<6>'/prepended:/home/jmjones/local/python/psa/bin:/home/jmjones/apps/
lb/bin:/home/jmjones/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/
usr/
bin:/sbin:/bin:/usr/games:/appended'
```
```
Хотя была дана команда удалить сохраняемые изменения для пере
менной PATH, они попрежнему остаются на месте. Это означает лишь
то, что оболочка IPython удалила указание на необходимость сохране
ния этих изменений. Обратите внимание, что процесс, запущенный
с определенными значениями в переменной окружения, будет сохра
нять их, если не изменить их некоторым способом. При следующем за
пуске оболочки IPython окружение изменится:
[~/tmp]|7>
Do you really want to exit ([y]/n)?
jmjones@dinkgutsy:tmp$ ipythonp sh
IPython 0.8.3.bzr.r96 [on Py 2.5.1]
[~/tmp]|2> import os
[~/tmp]|3> os.environ['PATH']
<3> '/home/jmjones/local/python/psa/bin:/home/jmjones/apps/lb/bin:
/home/jmjones/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:
/sbin:/bin:/usr/games'
```
```
Как и следовало ожидать, переменная PATH вернулась к значению, ко
торое предшествовало тому моменту, как мы внесли в нее изменения.
Еще одна полезная особенность в профиле sh – это специальная функ
ция mglob. Функция mglob имеет простой синтаксис для наиболее рас
пространенных вариантов использования. Например, чтобы отыскать
все файлы с расширением .py в проекте Django, можно было бы вос
пользоваться следующей командой:
```
```
[django/trunk]|3> mglob rec:*py
<3> SList (.p, .n, .l, .s, .grep(), .fields() available). Value:
0: ./setup.py
1: ./examples/urls.py
2: ./examples/manage.py
3: ./examples/settings.py
4: ./examples/views.py
...
1103: ./django/conf/project_template/urls.py
1104: ./django/conf/project_template/manage.py
1105: ./django/conf/project_template/settings.py
1106: ./django/conf/project_template/__init__.py
1107: ./docs/conf.py
[django/trunk]|4>
```
```
Директива rec предписывает выполнить рекурсивный поиск по задан
ному вслед за ней шаблону. В данном случае шаблоном служит *py.
Чтобы отобразить список всех каталогов в корневом каталоге проекта
Django, можно было бы воспользоваться следующей командой:
```
```
[django/trunk]|3> mglob dir:*
<3> SList (.p, .n, .l, .s, .grep(), .fields() available).
Value:
0: examples
1: tests
2: extras
3: build
4: django
5: docs
6: scripts
</3>

Функция mglob возвращает объект списка, поэтому все, что в языке Py
thon можно сделать со списком, можно сделать и с полученным спи
ском каталогов.
Это была демонстрация лишь некоторых особенностей поведения про
филя sh. Существуют другие особенности и параметры этого профиля,
которые мы не рассматривали.

### Сбор информации

IPython – это немножко больше, чем просто оболочка, в которой мож
но активно работать. Это еще и инструмент сбора разного рода инфор
мации о программном коде и объектах, с которыми приходится рабо
тать. Она обеспечивает такие возможности в добывании информации,
что с легкостью может рассматриваться как инструмент исследовате
ля. В этом разделе описывается ряд особенностей, которые помогут
вам в сборе информации.

#### page

Если представление объекта, с которым приходится работать, не уме
щается на экране, можно попробовать воспользоваться специальной
функцией page. Вы можете использовать функцию page для вывода
объекта с помощью программы постраничного просмотра. Во многих
системах в качестве такой программы по умолчанию используется
утилита less, но вы можете использовать какуюнибудь другую про
грамму. Ниже демонстрируется стандартный способ использования:

```
In [1]: p = !ps aux
==
['USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND',
'root 1 0.0 0.1 5116 1964? Ss Mar07 0:00 /sbin/init',
< ... дальнейшие результаты обрезаны ... >
In [2]: page p
['USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND',
'root 1 0.0 0.1 5116 1964? Ss Mar07 0:00 /sbin/init',
< ... дальнейшие результаты обрезаны ... >
```

Здесь в переменной p сохраняется результат выполнения системной
команды ps aux. Затем вызывается функция page, которой передается
объект с результатами. После этого функция page запускает програм
му less.
Функция page имеет один дополнительный параметр: –r. Этот пара
метр предписывает функции page передать программе постраничного
просмотра неформатированное строковое представление объекта (ре
зультат вызова функции str()). Для нашего объекта со списком про
цессов это могло бы выглядеть так:

```
In [3]: pager p
iluscdburner/mappingd', 'jmjones 5568 0.0 1.0 232004 10608? S
Mar07 0:00 /usr/lib/gnomeapplets/trashapplet', 'jmjones 5593 0.0 0.9
188996 10076? S Mar07 0:00 /usr/lib/gnomeapplets/battstatapple',
'jmjones 5595 0.0 2.8 402148 29412? S Mar07 0:01 p
<... дальнейшие результаты обрезаны ...>
```

Такой неформатированный вывод выглядит почти нечитабельно. Мы
рекомендуем начинать с форматированного вывода и работать уже
сним.

**pdef**


Специальная функция pdef выводит заголовки определений (сигнату
ры функций) любых вызываемых объектов. В следующем примере мы
создаем свою собственную функцию со строкой документирования
иинструкцией return:
In [1]: def myfunc(a, b, c, d):
...: '''return something by using a, b, c, d to do something'''
...: return a, b, c, d
...:
```
```
In [2]: pdef myfunc
myfunc(a, b, c, d)
```
```
Функция pdef проигнорировала строку документирования и инструк
цию return, но вывела сигнатуру функции. Функцию pdef можно ис
пользовать с любой вызываемой функцией. Она может работать, даже
когда исходный программный код недоступен, но при условии, что
имеется доступ к файлу .pyc или к пакету.

**pdoc**


Функция pdoc выводит строку документирования переданной ей функ
ции. Ниже мы передали pdoc функцию myfunc, которую передавали
функции pdef в примере выше:
In [3]: pdoc myfunc
Class Docstring:
return something by using a, b, c, d to do something
Calling Docstring:
x.__call__(...) <==> x(...)

Результат достаточно очевиден.

#### pfile


Функция pfile передает файл, содержащий указанный объект, про
грамме постраничного просмотра, если этот файл будет найден:

```
In [1]: import os
In [2]: pfile os
```

```
r"""OS routines for Mac, NT, or Posix depending on what system we're on.
This exports:
all functions from posix, nt, os2, mac, or ce, e.g. unlink, stat, etc.
<... дальнейшие результаты обрезаны ...>
```

В этом примере открывается файл модуля os и передается программе
less. Это может оказаться удобным, если вы пытаетесь понять, почему
тот или иной фрагмент программного кода ведет себя тем или иным
способом. Эта функция не работает, если доступным файлом является
пакет или файл с байткодом .pyc.

Ту же информацию, что выводят специальные функции %pdef,
%pdoc и %pfile, можно получить с помощью оператора ??. Причем
использование оператора ?? предпочтительнее.


#### pinfo

Функция pinfo и родственные ей утилиты настолько удобны, что
сложно представить, как можно обходиться без них. Функция pinfo
предоставляет такую информацию, как тип, базовый класс, простран
ство имен и строка документирования. Если представить, что у нас
имеется модуль, содержащий следующее:

```
#!/usr/bin/env python
class Foo:
"""мой класс Foo"""
def __init__(self):
pass
class Bar:
"""мой класс Bar"""
def __init__(self):
pass
class Bam:
"""мой класс Bam"""
def __init__(self):
pass
```

то можно было бы запросить информацию непосредственно о модуле:
```
```
In [1]: import some_module
In [2]: pinfo some_module
Type: module
Base Class: <type 'module'>
String Form: <module 'some_module' from 'some_module.py'>
Namespace: Interactive
File: /home/jmjones/code/some_module.py
Docstring:
<no docstring>
Об определенном классе в этом модуле:
In [3]: pinfo some_module.Foo
Type: classobj
String Form: some_module.Foo
Namespace: Interactive
File: /home/jmjones/code/some_module.py
Docstring:
мой класс Foo
```
```
Constructor information:
Definition: some_module.Foo(self)
```
```
Об экземпляре одного из классов:
In [4]: f = some_module.Foo()
```
```
In [5]: pinfo f
Type: instance
Base Class: some_module.Foo
String Form: <some_module.Foo instance at 0x86e9e0>
Namespace: Interactive
Docstring:
мой класс Foo
```
```
Оператор ?, стоящий перед или после имени объекта, позволит полу
чить ту же информацию, которую выводит функция pinfo:
In [6]:? f
Type: instance
Base Class: some_module.Foo
String Form: <some_module.Foo instance at 0x86e9e0>
Namespace: Interactive
Docstring:
мой класс Foo
```
```
In [7]: f?
Type: instance
Base Class: some_module.Foo
String Form: <some_module.Foo instance at 0x86e9e0>
Namespace: Interactive
Docstring:
мой класс Foo
```
```
А два знака вопроса (??), помещенные перед или после имени объекта,
позволят получить еще больше информации:
In [8]: some_module.Foo ??
Type: classobj
String Form: some_module.Foo
Namespace: Interactive
File: /home/jmjones/code/some_module.py
Source:
class Foo:
"""мой класс Foo"""
```

```
def __init__(self):
pass
Constructor information:
Definition: some_module.Foo(self)
```
```
Оператор ?? выводит ту же информацию, которую дает функция pinfo,
плюс исходный программный код реализации запрошенного объекта.
Поскольку в этом примере мы запросили информацию об определен
ном классе, оператор ?? вывел исходный программный код только для
этого объекта, а не весь файл целиком. Эта особенность оболочки IPy
thon используется значительно чаще, чем любая другая ее особенность.
```
**psource**

```
Функция psource выводит исходный программный код указанного
объекта, будь то модуль или элемент модуля, такой как класс или
функция. Для отображения исходного программного кода использует
ся программа постраничного просмотра. Ниже приводится пример ис
пользования psource для просмотра содержимого модуля:
```
```
In [1]: import some_other_module
In [2]: psource some_other_module
#!/usr/bin/env python
class Foo:
"""мой класс Foo"""
def __init__(self):
pass
class Bar:
"""мой класс Bar"""
def __init__(self):
pass
class Bam:
"""мой класс Bam"""
def __init__(self):
pass
def baz():
"""моя функция baz"""
return None
```
```
Ниже приводится пример использования функции psource для про
смотра исходного кода класса в модуле:
```
```
In [3]: psource some_other_module.Foo
class Foo:
"""мой класс Foo"""
def __init__(self):
pass
```
```
и в следующем примере функция psource используется для вывода ис
ходного кода функции:
```
```
In [4]: psource some_other_module.baz
def baz():
"""моя функция baz"""
return None
```
**psearch**

```
Специальная функция psearch позволяет отыскать объект на языке Py
thon по имени, с возможностью использования шаблонных символов.
Здесь мы лишь коротко опишем функцию psearch. Если вам потребует
ся дополнительная информация о ней, вы можете обратиться к доку
ментации по специальным функциям, введя команду magic в строке
приглашения IPython и отыскав описание функции psearch в списке,
отсортированном по алфавиту.
Для начала объявим следующие объекты:
In [1]: a = 1
```
```
In [2]: aa = "one"
In [3]: b = 2
```
```
In [4]: bb = "two"
In [5]: c = 3
```
```
In [6]: cc = "three"
```
```
Мы можем отыскать все объекты, имена которых начинаются с симво
ла a, b или c, следующим способом:
In [7]: psearch a*
a
aa
abs
all
any
apply
```
```
In [8]: psearch b*
b
basestring
bb
bool
buffer
```
```
In [9]: psearch c*
c
callable
cc
chr
```

```
classmethod
cmp
coerce
compile
complex
copyright
credits
```
```
Обратите внимание, что помимо наших объектов a, aa, b, bb, c и cc были
найдены еще и встроенные объекты.
Оператор? может рассматриваться как приблизительный эквивалент
функции psearch. Например:
In [2]: import os
```
```
In [3]: psearch os.li*
os.linesep
os.link
os.listdir
```
```
In [4]: os.li*?
os.linesep
os.link
os.listdir
```
```
То есть вместо psearch мы вполне можем использовать *?.
Функция psearch имеет дополнительные параметры: –s позволяет
включить, а –e – исключить из поиска указанное пространство из отно
сящихся к этой функции пространств имен. В пространства имен вхо
дят builtin, user, user_global, internal и alias. По умолчанию функция
psearch производит поиск в пространствах имен builtin и user. Чтобы
произвести поиск только в пространстве имен user, можно было бы пе
редать функции psearch параметр –e builtin, который исключит из по
иска пространство имен builtin. Использование этих параметров не
сколько неочевидно, но имеет некоторый смысл. По умолчанию функ
ция psearch производит поиск в пространствах имен builtin и user, по
этому, если использовать параметр –s user, поиск попрежнему будет
производиться в пространствах имен builtin и user. В следующем при
мере мы еще раз выполнили поиск, но на этот раз исключили про
странство встроенных имен builtin:
In [10]: psearche builtin a*
a
aa
```
```
In [11]: psearche builtin b*
b
bb
In [12]: psearche builtin c*
c
cc
```
```
Кроме того, функция psearch позволяет отыскивать объекты указанных
типов. Ниже мы выполнили поиск целочисленных объектов в про
странстве имен user:
In [13]: psearche builtin * int
a
b
c
```
```
В следующем примере произведен поиск строк:
```
```
In [14]: psearche builtin * string
__
___
__name__
aa
bb
cc
```
```
Объекты __и__, которые были найдены здесь, являются сокращениями IPython. Объект __name__ – это специальная переменная, которая
хранит имя модуля. Если переменная __name__ содержит строку
'__main__', это означает, что модуль выполняется как самостоятель
ный сценарий, а не импортируется другим модулем.
```
**who**

```
Оболочка IPython предоставляет множество способов получения спи
сков интерактивных объектов. Первый из них – функция who. Ниже
приводится продолжение предыдущего примера с переменными a, aa,
b, bb, c и cc и использованием функции who:
In [15]: who
a aa b bb c cc
```
```
Эта функция не содержит никаких подвохов, она просто выводит пере
чень всех объектов, которые были определены в интерактивном режи
ме. Функцию who можно использовать для выборки переменных опре
деленных типов, например:
In [16]: who int
a b c
In [17]: who str
aa bb cc
```
**who_ls**

```
Функция who_ls похожа на функцию who, за исключением того, что она
не выводит перечень имен соответствующих переменных, а возвраща
ет список. Ниже приводится пример использования функции who_ls
без аргументов:

```
In [18]: who_ls
Out[18]: ['a', 'aa', 'b', 'bb', 'c', 'cc']
```

А в следующем примере производится выборка объектов определенного типа:

```
In [19]: who_ls int
Out[19]: ['a', 'b', 'c']
In [20]: who_ls str
Out[20]: ['aa', 'bb', 'cc']
```

Функция who_ls возвращает список имен, поэтому вы можете полу
чить доступ к нему с помощью переменной _, которая содержит «по
следний выведенный результат». Ниже демонстрируется способ обхо
да последнего полученного списка с соответствующими именами пере
менных:

```
In [21]: for n in _:
....: print n
....:
....:
aa
bb
cc
```

#### whos

```
Функция whos похожа на функцию who, но в отличие от последней
функция whos выводит информацию в табличном виде. Ниже приво
дится пример использования функции whos без аргументов:
```
```
In [22]: whos
Variable Type Data/Info
```
```
a int 1
aa str one
b int 2
bb str two
c int 3
cc str three
n str cc
```
```
Так же, как и функция who, она способна отбирать переменные в соот
ветствии с указанным типом:
In [23]: whos int
Variable Type Data/Info
```
```
a int 1
b int 2
c int 3
```
```
In [24]: whos str
Variable Type Data/Info
```
```
aa str one
bb str two
cc str three
n str cc
```
**История**

```
В оболочке IPython существует два способа получения доступа к исто
рии вводившихся команд. Первый основан на использовании под
держки библиотеки readline, а второй – на использовании специаль
ной функции hist.
```
```
Поддержка readline
В оболочке IPython обеспечивается доступ ко всем функциональным
возможностям, которые может предоставить приложение, обладаю
щее поддержкой библиотеки readline. Если вы привыкли пользовать
ся управляющими комбинациями для выполнения поиска по истории
команд в оболочке Bash, значит у вас не будет проблем с использовани
ем той же самой функциональности в IPython. В примере ниже опре
деляется несколько переменных, а затем производится поиск по исто
рии команд:
```
```
In [1]: foo = 1
In [2]: bar = 2
```
```
In [3]: bam = 3
In [4]: d = dict(foo=foo, bar=bar, bam=bam)
```
```
In [5]: dict2 = dict(d=d, foo=foo)
In [6]: <CTRLr>
```
```
(reverseisearch)`fo': dict2 = dict(d=d, foo=foo)
<CTRLr>
```
```
(reverseisearch)`fo': d = dict(foo=foo, bar=bar, bam=bam)
```
```
Здесь мы нажали комбинацию клавиш Ctrlr, затем ввели строку fo, ко
торая выступает в качестве критерия поиска. В результате была полу
чена строка, которую мы ввели в приглашении IPython In [5]. Пользу
ясь поддержкой поиска в библиотеке readline, мы вновь нажали ком
бинацию Ctrlr и получили строку, которую мы ввели в приглашении
IPython In [4].
Есть еще некоторые комбинации клавиш, которые можно использо
вать при наличии поддержки readline, но мы коснемся их очень крат
ко. Комбинация Ctrla переносит курсор в начало строки, комбинация
Ctrle – в конец строки. Комбинация Ctrlf вызывает перемещение курсора на один символ вперед (forward), а комбинация Ctrlb – на один
символ назад (backward). Комбинация Ctrld удаляет (delete) один сим
вол под курсором, а комбинация Ctrlh – удаляет один символ левее
курсора (аналогично действию клавиши Backspace (забой)). Комбина
ция Ctrlp вызывает перемещение на одну команду назад, к началу ис
тории, а комбинация Ctrln – на одну команду вперед, к концу истории.
Дополнительную информацию о возможностях readline можно полу
чить в справочном руководстве *nixсистем с помощью команды man
readline.
Функция hist
В дополнение к возможности доступа к истории команд посредством
библиотеки readline оболочка IPython также предоставляет для этого
свою собственную специальную функцию с именем history и сокра
щенный вариант имени hist. При вызове без параметров функция hist
выводит последовательный список команд, вводившихся пользовате
лем. По умолчанию строки в этом списке пронумерованы. В следую
щем примере мы определили несколько переменных, перешли в дру
гой каталог и затем вызвали функцию hist:
```
```
In [1]: foo = 1
In [2]: bar = 2
```
```
In [3]: bam = 3
In [4]: cd /tmp
/tmp
In [5]: hist
1: foo = 1
2: bar = 2
3: bam = 3
4: _ip.magic("cd /tmp")
5: _ip.magic("hist ")
```
```
Четвертый и пятый элементы в списке выше – это вызовы специаль
ных функций. Обратите внимание на то, как они были изменены обо
лочкой IPython, благодаря чему можно видеть, что в действительно
сти команды выполняются через вызов оболочкой функции magic().
Чтобы подавить вывод номеров строк, можно использовать параметр
```
- n. Ниже приводится пример использования функции hist с парамет
ром –n:

```
In [6]: histn
foo = 1
bar = 2
bam = 3
_ip.magic("cd /tmp")
_ip.magic("hist ")
_ip.magic("histn")
```

Это очень удобно, когда при работе в IPython возникает необходимость
скопировать блок программного кода из оболочки IPython и вставить
его в текстовый редактор.
Параметр –t возвращает «преобразованное» (translated) представление
истории, где показано, как в действительности выглядят команды,
введенные в оболочке IPython. Этот параметр установлен по умолча
нию. Ниже приводится история команд, которая образовалась к на
стоящему моменту, полученная с параметром –t:
```
```
In [7]: histt
1: foo = 1
2: bar = 2
3: bam = 3
4: _ip.magic("cd /tmp")
5: _ip.magic("hist ")
6: _ip.magic("histn")
7: _ip.magic("histt")
```
```
При использовании параметра –r выводится история команд в «непо
средственном (сыром) виде» (raw) и отображаются команды в том ви
де, в каком они вводились. Ниже приводится результат применения
параметра –r:
```
```
In [8]: histr
1: foo = 1
2: bar = 2
3: bam = 3
4: cd /tmp
5: hist
6: histn
7: histt
8: histr
```
```
Параметр –g функции обеспечивает возможность поиска в истории по
заданному шаблону. Ниже приводится пример использования пара
метра –g, чтобы отыскать в истории все вхождения слова hist:
```
```
In [9]: histg hist
0187: hist
0188: histn
0189: histg import
0190: histh
0191: histt
0192: histr
0193: histd
0213: histg foo
0219: histg hist
===
^shadow history ends, fetch by %rep <number> (must start with 0)
=== start of normal history ===
5 : _ip.magic("hist ")
6 : _ip.magic("histn")
7 : _ip.magic("histt")
8 : _ip.magic("histr")
9 : _ip.magic("histg hist")
```
```
Обратите внимание на слова «shadow history» (теневая история), поя
вившиеся в предыдущем примере. «Теневая история» – это история
всех команд, которые вводились когдалибо. Строки с элементами этой
истории отображаются в самом начале списка и начинаются с нуля.
Строки с элементами истории текущего сеанса отображаются в конце
списка и не начинаются с нуля.
```
```
История результатов
И в стандартной оболочке Python, и в оболочке IPython имеется воз
можность доступа не только к истории вводившихся команд, но к ис
тории результатов. Первый способ доступа заключается в использова
нии специальной переменной с именем _, которая содержит «послед
ний выведенный результат». Ниже приводится пример использования
переменной _ в IPython:
```
```
In [1]: foo = "foo_string"
In [2]: _
```
```
Out[2]: ''
In [3]: foo
```
```
Out[3]: 'foo_string'
In [4]: _
```
```
Out[4]: 'foo_string'
In [5]: a = _
```
```
In [6]: a
Out[6]: 'foo_string'
```
```
Когда в приглашении In [1] мы определили переменную foo, перемен
ная _ в In [2] вернула пустую строку. Когда мы вывели значение пере
менной foo в In [3], переменная _ в In [4] вернула полученный выше ре
зультат. А операция в In [5] показала, что имеется возможность сохра
нять результат в переменной.
Ниже приводится тот же самый пример, выполненный в стандартной
оболочке Python:
>>> foo = "foo_string"
>>> _
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
NameError: name '_' is not defined
>>> foo
'foo_string'
>>> _
'foo_string'
>>> a = _
>>> a
'foo_string'
```
```
Здесь, в стандартной оболочке Python, наблюдаем практически ту же
самую картину, что и в оболочке IPython, за исключением того, что
при попытке обратиться к имени _ до того, как чтонибудь будет выве
дено, возбуждается исключение NameError.
Оболочка IPython поднимает концепцию «последнего выведенного ре
зультата» на новый уровень. В разделе «Выполнение системных ко
манд» было дано описание операторов! и !! и говорилось, что резуль
тат работы оператора !! нельзя сохранить в переменной, но позднее его
можно использовать. Проще говоря, у вас имеется доступ к любым ре
зультатам с помощью символа подчеркивания (_), вслед за которым
следует число в соответствии с синтаксисом _[0–9]*. Число должно со
ответствовать результату в строке Out [0–9]*.
Чтобы продемонстрировать, как действует этот прием, мы сначала вы
ведем списки файлов, но при этом ничего не будем делать с получен
ными результатами:
In [1]: !!ls apa*py
```
```
Out[1]: SList (.p, .n, .l, .s, .grep(), .fields() available). Value:
0: apache_conf_docroot_replace.py
1: apache_log_parser_regex.py
2: apache_log_parser_split.py
```
```
In [2]: !!ls e*py
Out[2]: SList (.p, .n, .l, .s, .grep(), .fields() available). Value:
0: elementtree_system_profile.py
1: elementtree_tomcat_users.py
```
```
In [3]: !!ls t*py
Out[3]: SList (.p, .n, .l, .s, .grep(), .fields() available). Value:
0: test_apache_log_parser_regex.py
1: test_apache_log_parser_split.py
```
```
Теперь у нас должна иметься возможность доступа к Out [1–3] с помо
щью _1, _2 и _3. Чтобы было более понятно, мы присвоим эти значения
переменным с говорящими именами:
In [4]: apache_list = _1
```
```
In [5]: element_tree_list = _2
In [6]: tests = _3
Теперь apache_list, tree_list и tests содержат те же элементы, которые
были выведены в строках Out [1], Out [2] и Out [3], соответственно:
```
```
In [7]: apache_list
Out[7]: SList (.p, .n, .l, .s, .grep(), .fields() available). Value:
0: apache_conf_docroot_replace.py
1: apache_log_parser_regex.py
2: apache_log_parser_split.py
In [8]: element_tree_list
```
```
Out[8]: SList (.p, .n, .l, .s, .grep(), .fields() available). Value:
0: elementtree_system_profile.py
1: elementtree_tomcat_users.py
In [9]: tests
```
```
Out[9]: SList (.p, .n, .l, .s, .grep(), .fields() available). Value:
0: test_apache_log_parser_regex.py
1: test_apache_log_parser_split.py
```
```
Обобщим сказанное: в оболочке IPython имеется возможность обра
щаться к выведенным ранее результатам либо через специальную пе
ременную _, либо через _ с явно указанным номером полученного ра
нее результата.

### Автоматизация и сокращения

Оболочка IPython делает достаточно много, чтобы повысить произво
дительность труда, и кроме этого она предоставляет ряд функций
и особенностей, помогающих автоматизировать решение задач в IPy
thon.
```
**alias**

```
Для начала упомянем специальную функцию alias. Мы уже рассмат
ривали ее выше в этой главе, поэтому не будем повторно описывать
принципы ее использования. Но нам хотелось бы напомнить, что
функция alias способна не только помочь использовать системные ко
манды системы *nix в оболочке IPython, но также может оказать по
мощь в автоматизации решения задач.
```
**macro**

```
Функция macro позволяет определять блоки программного кода, кото
рые могут выполняться позднее, в составе любого программного кода,
с которым вам придется работать. Макроопределения, создаваемые
с помощью специальной функции macro, выполняются в текущем кон
тексте вашего программного кода. Если у вас имеется некоторая по
следовательность инструкций, которую вы часто используете для об
работки своих файлов, вы можете создать макроопределение, которое
будет выполнять эту работу. Чтобы получить представление о том, как
с помощью макроопределения можно выполнять обработку списка
файлов, рассмотрим следующий пример:
In [1]: dirlist = []
```
```
In [2]: for f in dirlist:
...: print "working on", f
...: print "done with", f
...: print "moving %s to %s.done" % (f, f)
...: print "*" * 40
...:
...:
In [3]: macro procdir 2
Macro `procdir` created. To execute, type its name (without quotes).
Macro contents:
for f in dirlist:
print "working on", f
print "done with", f
print "moving %s to %s.done" % (f, f)
print "*" * 40
```
```
К моменту создания цикла в In [2] в dirlist не было ни одного элемен
та, чтобы их можно было обойти в цикле, но так как мы предполагаем,
что позднее в dirlist появятся элементы, мы создали макрокоманду
с именем procdir, которая выполняет обход списка в цикле. Макроко
манда создается в соответствии с синтаксисом: macro macro_name range_
of_lines, где под range_of_lines подразумевается список строк истории
команд, которые должны быть добавлены в макроопределение. Строки
в этом списке должны определяться номерами или диапазонами номе
ров (например, 1 – 4 ) строк и отделяться друг от друга пробелами.
В следующем примере мы создали список имен файлов и сохранили
его в переменной dirlist, а затем выполнили макрокоманду procdir.
Макрокоманда выполнит обход списка файлов в dirlist:
In [4]: dirlist = ['a.txt', 'b.txt', 'c.txt']
```
```
In [5]: procdir
> procdir()
working on a.txt
done with a.txt
moving a.txt to a.txt.done
****************************************
working on b.txt
done with b.txt
moving b.txt to b.txt.done
****************************************
working on c.txt
done with c.txt
moving c.txt to c.txt.done
****************************************

После того как макрокоманда будет определена, ее можно будет отре
дактировать с помощью функции edit. В результате этого будет от
крыт текстовый редактор. Очень удобно иметь возможность выпол
нить отладку макрокоманды, добиваясь правильной ее работы, преж
де чем сохранить ее.
```
**store**

```
Вы можете сохранить свои макрокоманды и простые переменные с по
мощью специальной функции store. Она имеет следующий стандарт
ный формат: store variable. Кроме того, функция store может прини
мать дополнительные параметры, которые могут оказаться для вас по
лезными: вызов store – d variable удалит указанную переменную из
списка сохраняемых; параметр –z удалит все сохраняемые перемен
ные; а параметр –r выполнит повторную загрузку всех сохраняемых
переменных.
```
**reset**

```
Функция reset удаляет все переменные из интерактивного простран
ства имен. В следующем примере определяются три переменные, за
тем вызывается функция whos, чтобы убедиться в их присутствии, за
тем выполняется очистка пространства имен с помощью функции re
set и повторно вызывается функция whos, чтобы убедиться в том, что
переменные исчезли:
In [1]: a = 1
```
```
In [2]: b = 2
In [3]: c = 3
```
```
In [4]: whos
Variable Type Data/Info
```
```
a int 1
b int 2
c int 3
```
```
In [5]: reset
Once deleted, variables cannot be recovered. Proceed (y/[n])? y
(После удаления переменные нельзя будет восстановить. Продолжить (y/[n])?)
In [6]: whos
Interactive namespace is empty.
(Интерактивное пространство имен очищено.)
```
**run**

```
Функция run выполняет указанный файл в оболочке IPython. Это, кро
ме всего, позволяет работать с модулями на языке Python во внешнем
текстовом редакторе и интерактивно тестировать внесенные изменения в IPython. После выполнения указанной программы управление воз
вращается в оболочку IPython. Функция run имеет следующий формат
записи: run options specified_file args.
При использовании параметра –n переменная __name__ модуля получа
ет в качестве значения название модуля, а не строку '__main__'. Это
приводит к тому, что модуль выполняется так, как если бы он был
просто импортирован.
При использовании параметра –i модуль выполняется в текущем про
странстве имен оболочки IPython, благодаря чему модуль получает
доступ ко всем переменным, которые были определены.
При использовании параметра –e оболочка IPython будет игнориро
вать вызов функции sys.exit() и исключение SystemExit. Даже если
они будут иметь место, оболочка IPython продолжит свою работу.
При использовании параметра –t оболочка IPython выведет информа
цию о времени выполнения модуля.
При использовании параметра –d указанный модуль будет запущен
под управлением отладчика Python (pdb).
При использовании параметра –p указанный модуль будет запущен
под управлением профилировщика.
```
**save**

```
Функция save сохраняет указанные строки ввода в указанный файл.
Порядок использования функции save: save options filename lines.
Строки могут указываться в том же формате, что и в функции macro.
Единственный дополнительный параметр –r определяет, что в файл
следует сохранить строки в непреобразованном виде, то есть том виде,
в каком они вводились. По умолчанию строки сохраняются в преобра
зованном, стандартном для языка Python, виде.
```
**rep**

```
Последняя функция, используемая для автоматизации решения за
дач, – это функция rep. Функция rep может принимать ряд парамет
ров, которые вы найдете полезными. Вызов функции rep без парамет
ров возвращает последний вычисленный результат и помещает стро
ковое его представление в следующей строке ввода. Например:

```
In [1]: def format_str(s):
...: return "str(%s)" % s
...:
In [2]: format_str(1)
Out[2]: 'str(1)'
In [3]: rep
In [4]: str(1)
```

Вызов функции rep в строке In [3] привел к вставке текста в строке In
[4]. Такая ее особенность позволяет программно генерировать ввод
в оболочке IPython. Это особенно удобно при использовании комбина
ций макрокоманд и генераторов.
Обычно функция rep без параметров используется при редактирова
нии без использования мыши. Если у вас имеется переменная, содер
жащая некоторое значение, с помощью этой функции его можно бу
дет редактировать непосредственно. В качестве примера представим,
что у нас имеется функция, которая возвращает каталог bin , куда был
установлен некоторый пакет. Мы сохраняем каталог bin в перемен
ной с именем a:
In [2]: a = some_blackbox_function('squiggly')
```
```
In [3]: a
Out[3]: '/opt/local/squiggly/bin'
```
```
Если вызвать функцию rep прямо сейчас, мы получим строку /opt/lo
cal/squiggly/bin в новой строке ввода, с мигающим курсором в конце
строки, приглашающим нас к ее редактированию:
In [4]: rep
```
```
In [5]: /opt/local/squiggly/bin<мигающий курсор>
```
```
Если нам требуется сохранить не каталог bin , а корневой каталог паке
та, мы можем просто удалить bin в конце строки, окружить строку ка
вычками и добавить в начало строки ввода имя новой переменной
и оператор присваивания:
In [5]: new_a = '/opt/local/squiggly'
```
```
Теперь у нас имеется новая переменная, содержащая строку с именем
корневого каталога данного пакета.
Несомненно, мы могли бы просто скопировать и вставить эту строку,
но для этого пришлось бы выполнить больший объем работы. Зачем
нам отвлекаться от столь удобной клавиатуры, чтобы дотянуться до
мыши? Теперь вы можете использовать переменную new_a в качестве
корневого каталога для выполнения любых необходимых действий
спакетом.
Когда функции rep в качестве параметра передается число, она выби
рает значение соответствующей строки ввода из истории команд,
вставляет ее в следующую строку ввода и помещает курсор в конец
этой строки. Это бывает удобно для запуска, редактирования и повтор
ного запуска отдельных строк или даже небольших блоков програм
мы. Например:

```
In [1]: map = (('a', '1'), ('b', '2'), ('c', '3'))
In [2]: for alph, num in map:
...: print alph, num
...:
...:
a 1
b 2
c 3
```

Теперь нам нужно отредактировать строку ввода In [2] так, чтобы вы
водились значения, умноженные на 2. Для этого можно снова ввести
цикл for или воспользоваться функцией rep:

```
In [3]: rep 2
In [4]: for alph, num in map:
print alph, int(num) * 2
...:
...:
a 2
b 4
c 6
```

Кроме того, функция rep способна принимать диапазоны строк. Син
таксис диапазона аналогичен тому, что используется в функции macro,
которая уже рассматривалась выше в этой главе. Когда функции rep
передается диапазон строк, они выполняются немедленно, например:

```
In [1]: i = 1
In [2]: i += 1
In [3]: print i
2
In [4]: rep 23
lines [u'i += 1\nprint i\n']
3
```
```
In [7]: rep 23
lines [u'i += 1\nprint i\n']
4
```

Здесь в строках с In [1] по In [3] мы определили переменную, увеличи
ли ее на 1, и вывели текущее значение. В строках In [4] и In [7] мы
предложили функции rep повторить строки 2 и 3. Обратите внимание
на отсутствие двух строк (5 и 6) – эти строки были выполнены после
строки In [4].
Последний параметр функции rep, который мы рассмотрим, – строка.
Этот случай можно выразить словами: «передача слова функции rep»
или даже: «передача функции rep искомой строки без кавычек». На
пример:

```
In [1]: a = 1
In [2]: b = 2
In [3]: c = 3
In [4]: rep a
```
```
In [5]: a = 1
```
```
Здесь мы определили несколько переменных и потребовали от функ
ции rep повторить строку, в которой присутствует слово «a». В резуль
тате мы получили строку, введенную в приглашении In [1], и получи
ли возможность отредактировать ее и запустить повторно.
```
### В заключение.

Оболочка IPython является самым ценным инструментом в нашем арсенале. Мастерство владения ее возможностями напоминает мастерство владения текстовым редактором: чем большим опытом вы обладаете, тем быстрее будете решать утомительные задачи. Даже несколько лет тому назад, когда мы только начали использовать оболочку IPython, она уже была весьма мощным инструментом. С тех пор ее мощь увеличилась еще больше. Функция grep и обработка строк – это первые две особенности, которые сразу же приходят на ум, когда мы задумываемся о понастоящему полезных и мощных возможностях, перечень которых непрерывно продолжает пополняться усилиями сообщества IPython. Мы настоятельно рекомендуем поближе познакомиться с оболочкой IPython. Освоение ее – это надежные инвестиции в будущее, о которых вам не придется сожалеть.
