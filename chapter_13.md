## Глава 13. Командная строка

**Введение**

Командная строка имеет особое значение для системного администра
тора. Ни один другой инструмент не обладает таким уровнем значимо
сти или авторитета, как командная строка. Полное овладение искусст
вом командной строки – это своего рода обряд посвящения для боль
шинства системных администраторов. Многие системные админист
раторы не считают администраторами тех, кто использует программы
с графическим интерфейсом, и называют графический интерфейс кос
тылями. Возможно, это не совсем справедливо, но это устоявшееся
мнение об истинном искусстве владения профессией системного адми
нистратора.

В течение очень долгого времени системы UNIX придерживались фи
лософии, что интерфейс командной строки (Command Line Inteface,
CLI) превосходит по своим возможностям любой графический интер
фейс, который когдалибо разрабатывался. В свете последних событий
создается впечатление, что даже Microsoft решила вернуться к своим
корням. Джеффри Сновер (Jeffrey Snover), архитектор Windows Po
wershell, заявил: «Это было ошибкой – думать, что графический ин
терфейс когдалибо сможет или должен вытеснить интерфейс команд
ной строки».

Даже создатели системы Windows, в которой в течение десятилетий
имелся самый худший интерфейс командной строки из всех современ
ных операционных систем, начинают понимать значимость интерфей
са командной строки, что привело к реализации Windows Powershell.
В этой книге мы не будем касаться операционной системы Windows,
но это очень интересный факт, подчеркивающий важность освоения
командной строки и действительную необходимость создания инстру
ментов командной строки.


**460** Глава 13. Командная строка

```
Однако недостаточно просто овладеть существующими в системе
UNIX инструментами командной строки. Чтобы стать настоящим про
фессионалом командной строки, необходимо научиться создавать соб
ственные инструменты и это может быть самой основной причиной, по
которой вы взяли эту книгу в руки. Эта глава вас не разочарует. За
кончив ее чтение, вы станете мастером по созданию инструментов ко
мандной строки на языке Python.
Это было преднамеренное решение – сконцентрировать внимание на
создании инструментов командной строки в последней главе. Мы хо
тели сначала продемонстрировать вам широчайший выбор приемов
программирования на языке Python, а в заключение рассказать вам,
как можно использовать все эти навыки при создании настоящих ше
девров командной строки.
```
### Основы использования потока стандартного ввода.

**стандартного ввода**

```
Самый простой путь к созданию инструментов командной строки опи
рается на знание того факта, что модуль sys позволяет обрабатывать
аргументы командной строки посредством атрибута sys.argv. В приме
ре 13.1 демонстрируется самый простой инструмент командной стро
ки, какой только возможен:
```
```
Пример 13.1. sysargv.py
#!/usr/bin/env python
```
```
import sys
print sys.argv
```
```
Эти две строки программного кода возвращают на стандартный вывод
все, что вводится в командной строке:
```
```
./sysargv.py
['./sysargv.py']
```
```
и
./sysargv.py foo
```
```
вернет на стандартный вывод
['./sysargv.py', 'test']
```
```
и
./sysargv.py foo bad for you
```
```
вернет на стандартный вывод
['./sysargv.py', 'foo', 'bad', 'for', 'you']
```

Основы использования потока стандартного ввода **461**

```
Добавим немного конкретики и слегка изменим программный код
так, чтобы он подсчитывал количество аргументов командной строки,
как показано в примере 13.2.
```
```
Пример 13.2. sysargv.py
#!/usr/bin/env python
import sys
```
```
#Индексы в языке Python начинаются с нуля, поэтому нужно исключить
#из подсчета саму команду – sys.argv[0]
```
```
num_arguments = len(sys.argv) 1
print sys.argv, "You typed in ", num_arguments, "arguments"
```
```
Вы могли бы подумать: «Как все просто, теперь мне осталось лишь по
лучить параметры командной строки по их индексам из списка
sys.argv и написать некоторую логику их обработки». В общем вы пра
вы, это довольно просто реализовать. Давайте добавим некоторые осо
бенности к нашему приложению командной строки. Последнее, что
мы могли бы сделать, – это вывести сообщение об ошибке в поток стан
дартного вывода сообщений об ошибках в случае отсутствия аргумен
тов командной строки, как показано в примере 13.3.
```
```
Пример 13.3. sysargv>step2.py
#!/usr/bin/env python
import sys
num_arguments = len(sys.argv) 1
```
```
#В случае отсутствия аргументов вывести сообщение
#в поток стандартного вывода сообщений об ошибках.
if num_arguments == 0:
sys.stderr.write('Hey, type in an option silly\n')
else:
print sys.argv, "You typed in ", num_arguments, "arguments"
```
```
Использование sys.argv при создании инструментов командной строки
зачастую является неправильным выбором, несмотря на всю его про
стоту. В стандартной библиотеке языка Python имеется модуль opt
parse, который берет на себя решение одной из самых неудобных задач
в создании качественного инструмента командной строки. Даже для
самых крошечных «разовых» инструментов лучше использовать opt
parse, чем sys.argv, так как у «разовых» инструментов есть свойство со
временем превращаться в нормальные рабочие инструменты. В сле
дующем разделе мы объясним, почему лучше использовать модуль opt
parse, но суть ответа заключается в том, что наличие хорошего модуля
разбора аргументов позволит разрешить самые необычные ситуации.
```

**462** Глава 13. Командная строка

### Введение в optparse.

```
Как упоминалось в предыдущем разделе, даже самый маленький сцена
рий может воспользоваться преимуществами модуля optparse при вы
полнении разбора параметров командной строки. Приступая к изуче
нию возможностей optparse, интереснее будет начать со своеобразного
примера «Hello World», который выполняет обработку параметров и ар
гументов. В примере 13.4 приводится наш сценарий «Hello World».
```
```
Пример 13.4. Hello World для модуля optparse
#!/usr/bin/env python
import optparse
```
```
def main():
p = optparse.OptionParser()
p.add_option('sysadmin', 's', default="BOFH")
options, arguments = p.parse_args()
print 'Hello, %s' % options.sysadmin
if __name__ == '__main__':
main()
```
```
Запуская этот сценарий, мы можем получить различные варианты вы
вода:
$ python hello_world_optparse.py
Hello, BOFH
$ python hello_world_optparse.pysysadmin Noah
Hello, Noah
$ python hello_world_optparse.pys Jeremy
Hello, Jeremy
$ python hello_world_optparse.pyinfinity Noah
Usage: hello_world_optparse.py [options]
hello_world_optparse.py: error: no such option:infinity
```
```
В нашем маленьком примере мы видели, что можно использовать как
короткий –s, так и длинный ––sysadmin параметры, а также значение по
умолчанию. Наконец, мы увидели встроенную возможность обработки
ошибок, когда указали неверный параметр и убедились в удобочитае
мости, которой так не хватает языку Perl.
```
### Простые шаблоны использования optparse

**Шаблон использования без ключей**

```
В предыдущем разделе мы упоминали, что модуль optparse может с ус
пехом использоваться даже в маленьких сценариях. В примере 13.5
показан простой шаблон использования модуля optparse, где сценарий
```

Простые шаблоны использования optparse **463**

```
не предусматривает наличие ключей командной строки, что не мешает
ему использовать преимущества optparse.
```
```
Пример 13.5. Клон команды ls
#!/usr/bin/env python
import optparse
import os
```
```
def main():
p = optparse.OptionParser(description="Python 'ls' command clone",
prog="pyls",
version="0.1a",
usage="%prog [directory]")
options, arguments = p.parse_args()
if len(arguments) == 1:
path = arguments[0]
for filename in os.listdir(path):
print filename
else:
p.print_help()
```
```
if __name__ == '__main__':
main()
```
```
В этом примере мы реализовали на языке Python свою версию коман
ды ls, которая принимает единственный аргумент – путь к каталогу,
содержимое которого требуется вывести. Мы не предусматриваем да
же наличие дополнительных ключей, но попрежнему можем пользо
ваться возможностями модуля optparse, опираясь на них при выборе
пути выполнения программы. Сначала при создании экземпляра клас
са OptionParser мы предоставляем некоторую информацию о реализа
ции и добавляем инструкции о порядке использования для потенци
альных пользователей инструмента. Затем мы проверяем количество
аргументов, и если их число больше или меньше одного, мы выводим
инструкцию о порядке использования инструмента с помощью метода
p.print_help(). Ниже приводится пример правильного использования
нашего инструмента, которому передается имя текущего каталога
«.»:
```
```
$ python no_options.py.
.svn
hello_world_optparse.py
no_options.py
```
```
А теперь посмотрим, что произойдет, если запустить сценарий без ар
гументов:
```
```
$ python no_options.py
Usage: pyls [directory]
```
```
Python 'ls' command clone
Options:
```

**464** Глава 13. Командная строка

```
version show program's version number and exit
h,help show this help message and exit
```
```
Интересно, что поведение, связанное с вызовом метода p.print_help(),
которое мы определили для случая запуска сценария, когда число ар
гументов не равно точно одному, равносильно запуску сценария с клю
чом ––help:
```
```
$ python no_options.pyhelp
Usage: pyls [directory]
```
```
Python 'ls' command clone
Options:
version show program's version number and exit
h,help show this help message and exit
```
```
А так как мы определили параметр ––version, то при его использова
нии мы получим следующее:
```
```
$ python no_options.pyversion
0.1a
```
```
В этом примере модуль optparse оказался полезен даже при создании
«разового» сценария, который может не получить дальнейшего разви
тия.
```
**Шаблон true/false**

```
Бывает очень удобно иметь возможность установить некоторый при
знак в значение true или false. Классическим примером такого шаблона
могут служить ключи: ––quiet, который подавляет вывод в поток стан
дартного вывода, и ––verbose, при установке которого программа перехо
дит в режим вывода более подробной информации. В примере 13.6 пока
зано, как это может выглядеть:
```
```
Пример 13.6. Увеличение и уменьшение подробности вывода
#!/usr/bin/env python
import optparse
import os
```
```
def main():
p = optparse.OptionParser(description="Python 'ls' command clone",
prog="pyls",
version="0.1a",
usage="%prog [directory]")
p.add_option("verbose", "v", action="store_true",
help="Enables Verbose Output",default=False)
options, arguments = p.parse_args()
if len(arguments) == 1:
if options.verbose:
print "Verbose Mode Enabled"
path = arguments[0]
```

Простые шаблоны использования optparse **465**

```
for filename in os.listdir(path):
if options.verbose:
print "Filename: %s " % filename
elif options.quiet:
pass
else:
print filename
else:
p.print_help()
if __name__ == '__main__':
main()
```
```
Используя ключ ––verbose, мы тем самым повышаем уровень подроб
ности информации, выводимой в поток стандартного вывода. Посмот
рим, какая информация выводится на каждом из уровней подробно
сти. Сначала нормальный уровень:
$python true_false.py /tmp
.aksusb
alm.log
amt.log
authTokenData
FLEXnet
helloworld
hsperfdata_ngift
ics10003
ics12158
ics13342
icssuis501
MobileSync.lock.f9e26440fe5adbb6bc42d7bf8f87c1e5fc61a7fe
summary.txt
```
```
Теперь в режиме подробного вывода:
```
```
$ python true_false.pyverbose /tmp
Verbose Mode Enabled
Filename: .aksusb
Filename: alm.log
Filename: amt.log
Filename: authTokenData
Filename: FLEXnet
Filename: helloworld
Filename: hsperfdata_ngift
Filename: ics10003
Filename: ics12158
Filename: ics13342
Filename: icssuis501
Filename: MobileSync.lock.f9e26440fe5adbb6bc42d7bf8f87c1e5fc61a7fe
Filename: summary.txt
```
```
Когда мы указываем ключ ––verbose, атрибут options.verbose получает
значение true, в результате чего выполняется условие и вызывается
```

**466** Глава 13. Командная строка

```
инструкция, которая выводит «Filename:» перед фактическим именем
файла. Обратите внимание, что в этом сценарии при вызове метода
p.add_option() мы определили параметры default=False и action="sto
re_true", указав тем самым, что по умолчанию этот параметр будет
иметь значение false, но если при вызове сценария будет указан ключ
––verbose, этот параметр приобретет значение true. В этом заключается
сущность использования логических параметров с модулем optparse.
```
**Шаблон подсчета числа параметров**

```
Если при использовании типичного инструмента командной строки
операционной системы UNIX, например tcpdump, указать параметр
```
- vvv, вы получите намного более подробный вывод, чем при использо
вании параметра –vv или –v. Вы можете реализовать аналогичное пове
дение, воспользовавшись такой возможностью модуля optparse, как
подсчет количества одинаковых параметров. Например, если вам по
требуется снабдить свой сценарий аналогичными уровнями подробно
сти вывода, вы могли бы сделать это, как показано в примере 13.7.

```
Пример 13.7. Шаблон с подсчетом упоминаний параметра
#!/usr/bin/env python
import optparse
import os
```
```
def main():
p = optparse.OptionParser(description="Python 'ls' command clone",
prog="pyls",
version="0.1a",
usage="%prog [directory]")
p.add_option("v", action="count", dest="verbose")
options, arguments = p.parse_args()
if len(arguments) == 1:
if options.verbose:
print "Verbose Mode Enabled at Level: %s" % options.verbose
path = arguments[0]
for filename in os.listdir(path):
if options.verbose == 1:
print "Filename: %s " % filename
elif options.verbose ==2 :
fullpath = os.path.join(path,filename)
print "Filename: %s | Byte Size: %s" % (filename,
os.path.getsize(fullpath))
else:
print filename
else:
p.print_help()
```
```
if __name__ == '__main__':
main()
```

Простые шаблоны использования optparse **467**

```
При использовании шаблона проектирования с автоматическим под
счетом упоминаний параметра мы можем на основе единственного па
раметра реализовать три варианта действий. Когда этот сценарий вы
зывается с ключом –v, атрибут options.verbose получает значение 1; ко
гда сценарий вызывается с ключом –vv, атрибут options.verbose полу
чает значение 2. Наш сценарий при вызове без ключей просто выводит
имена файлов, при вызове с ключом –v он выводит слово «Filename:»
перед каждым именем файла и, наконец, когда сценарий вызывается
сключом –vv, он выводит не только имя файла, но и его размер в бай
тах. Ниже показан результат вызова сценария с ключом –vv:
```
```
$ python verbosity_levels_count.pyvv /tmp
Verbose Mode Enabled at Level: 2
Filename: .aksusb | Byte Size: 0
Filename: alm.log | Byte Size: 1403
Filename: amt.log | Byte Size: 3038
Filename: authTokenData | Byte Size: 32
Filename: FLEXnet | Byte Size: 170
Filename: helloworld | Byte Size: 170
Filename: hsperfdata_ngift | Byte Size: 102
Filename: ics10003 | Byte Size: 0
Filename: ics12158 | Byte Size: 0
Filename: ics13342 | Byte Size: 0
Filename: ics14183 | Byte Size: 0
Filename: icssuis501 | Byte Size: 0
Filename: MobileSync.lock.f9e26440fe5adbb6bc42d7bf8f87c1e5fc61a7fe | Byte
Size: 0
Filename: summary.txt | Byte Size: 382
```
**Шаблон с вариантами значений параметра**

```
Иногда бывает необходимо предоставить несколько возможных значе
ний параметра. В нашем последнем примере мы создали параметры
––verbose и ––quiet, но точно так же мы могли бы реализовать их как
возможные варианты значений параметра ––chatty. В примере 13.8 по
казано, как выглядит версия предыдущего примера, переделанная для
использования вариантов значений.
```
```
Пример 13.8. Шаблон с вариантами значений параметра
#!/usr/bin/env python
import optparse
import os
```
```
def main():
p = optparse.OptionParser(description="Python 'ls' command clone",
prog="pyls",
version="0.1a",
usage="%prog [directory]")
p.add_option("chatty", "c", action="store", type="choice",
dest="chatty",
```

**468** Глава 13. Командная строка

```
choices=["normal", "verbose", "quiet"],
default="normal")
options, arguments = p.parse_args()
print options
if len(arguments) == 1:
if options.chatty == "verbose":
print "Verbose Mode Enabled"
path = arguments[0]
for filename in os.listdir(path):
if options.chatty == "verbose":
print "Filename: %s " % filename
elif options.chatty == "quiet":
pass
else:
print filename
else:
p.print_help()
if __name__ == '__main__':
main()
```
```
Если запустить эту команду с параметром без значения, как это дела
лось в предыдущем примере, будет получено следующее сообщение об
ошибке:
```
```
$ python choices.pychatty
Usage: pyls [directory]
```
```
pyls: error:chatty option requires an argument
```
```
Если указать в параметре ошибочный аргумент, будет получено другое
сообщение об ошибке, где будут указаны допустимые значения:
$ python choices.pychatty=nuclear /tmp
Usage: pyls [directory]
pyls: error: optionchatty: invalid choice: 'nuclear' (choose from 'normal',
'verbose', 'quiet')
```
```
Одно из удобств использования вариантов значений состоит в том, что
в этом случае сценарий не полагается на то, что подойдет любое вве
денное пользователем значение аргумента. Пользователю позволяется
выбирать только из тех значений, которые вы определите. Ниже пока
зано, как выполняется команда при запуске с допустимым значением
параметра:
$ python choices.pychatty=verbose /tmp
{'chatty': 'verbose'}
Verbose Mode Enabled
Filename: .aksusb
Filename: alm.log
Filename: amt.log
Filename: authTokenData
Filename: FLEXnet
```

Простые шаблоны использования optparse **469**

```
Filename: helloworld
Filename: hsperfdata_ngift
Filename: ics10003
Filename: ics12158
Filename: ics13342
Filename: ics14183
Filename: icssuis501
Filename: MobileSync.lock.f9e26440fe5adbb6bc42d7bf8f87c1e5fc61a7fe
Filename: summary.txt
```
```
Если вы обратили внимание, в первой строке вывода указано слово
«chatty» как ключ, а слово «verbose» как значение. В примере выше
мы добавили инструкцию print для вывода атрибута options, чтобы по
казать вам, как он выглядит с точки зрения программы. В заключение
ниже приводится пример запуска программы со значение quiet в пара
метре ––chatty:
$ python choices.pychatty=quiet /tmp
{'chatty': 'quiet'}
```
**Шаблон использования параметров**

**с несколькими аргументами**

```
По умолчанию для каждого параметра модуль optparse принимает
только один аргумент, но существует возможность определить любое
число аргументов. В примере 13.9 приводится сценарий, представ
ляющий собой еще одну версию команды ls, который может выводить
содержимое сразу двух каталогов.
```
```
Пример 13.9. Вывод содержимого двух каталогов
#!/usr/bin/env python
import optparse
import os
```
```
def main():
p = optparse.OptionParser(description="Lists contents of two directories",
prog="pymultils",
version="0.1a",
usage="%prog [dir dir1 dir2]")
p.add_option("dir", action="store", dest="dir", nargs=2)
options, arguments = p.parse_args()
if options.dir:
for dir in options.dir:
print "Listing of %s:\n" % dir
for filename in os.listdir(dir):
print filename
else:
p.print_help()
```
```
if __name__ == '__main__':
main()
```

**470** Глава 13. Командная строка

```
Если попробовать запустить этот сценарий с единственным аргумен
том параметра ––dir, будет получено следующее сообщение об ошибке:
```
```
[ngift@Macintosh8][H:10238][J:0]# python multiple_option_args.pydir /tmp "
Usage: pymultils [dir dir1 dir2]
```
```
pymultils: error:dir option requires 2 arguments
```
```
Указав требуемое число аргументов параметра ––dir, мы получили сле
дующее:
pymultils: error:dir option requires 2 arguments
[ngift@Macintosh8][H:10239][J:0]# python multiple_option_args.pydir /tmp
/Users/ngift/Music
Listing of /tmp:
.aksusb
FLEXnet
helloworld
hsperfdata_ngift
ics10003
ics12158
ics13342
ics14183
ics15392
icssuis501
MobileSync.lock.f9e26440fe5adbb6bc42d7bf8f87c1e5fc61a7fe
summary.txt
Listing of /Users/ngift/Music:
```
```
.DS_Store
.localized
iTunes
```
### командной строки на языке Python. Внедрение команд оболочки в инструменты

**командной строки на языке Python**

```
В главе 10 мы познакомились со множеством способов использования
модуля subprocess. Создание новых инструментов командной строки
путем обертывания существующих команд сценариями на языке Py
thon и изменения их API, или путем включения одной или нескольких
команд UNIX в сценарии на языке Python представляет собой весьма
интересную область для исследований. Нет ничего сложного в том,
чтобы обернуть инструмент командной строки сценарием на языке Py
thon и изменить ее поведение так, чтобы оно полнее отвечало нашим
требованиям. Можно было бы, например, интегрировать в сценарий
конфигурационный файл, в котором определить значения аргументов
для некоторых параметров или задавать в сценарии значения по умол
чанию для других аргументов. Какие бы требования не предъявля
лись, с помощью модулей subprocess и optparse можно без особых про
блем изменить поведение инструментов командной строки UNIX.
```

Внедрение команд оболочки в инструменты командной строки **471**

```
С другой стороны, смешивание инструментов командной строки со
сценарием на языке Python позволяет создавать интересные инстру
менты, которые не такто просто написать на языке C или Bash. Что
вы скажете насчет смешивания команды dd с многопоточным сценари
ем, где используются очереди, tcpdump с библиотекой регулярных вы
ражений для языка Python или использования специализированной
версии rsync? Все эти «смешанные» команды UNIX 2.0 очень напоми
нают особенности, присутствующие в Web 2.0. Смешивание Python
с утилитами UNIX приводит к появлению новых идей и к решению
проблем различными способами. В этом разделе мы исследуем некото
рые из этих приемов.
```
**Шаблон проектирования «кудзу»: обертывание**

**инструментов сценариями на языке Python**

```
Иногда используемый инструмент командной строки не совсем точно
соответствует тому, что требуется вам. Он может требовать слишком
большого числа параметров или порядок следования аргументов отли
чается от того, к которому вы привыкли. Используя язык программи
рования Python, можно очень легко изменить поведение утилиты и за
ставить ее делать именно то, что вам необходимо. Мы назвали это шаб
лоном проектирования «Кудзу». Для тех, кто не знает, поясним, что
кудзу – это быстрорастущее вьющееся растение, завезенное на юг Со
единенных Штатов из Японии. Кудзу часто поглощает естественный
ландшафт, совершенно меняя его внешний вид. С помощью языка Py
thon вы можете делать то же самое со средой UNIX.
В следующем примере мы обернули команду snmpdf сценарием на язы
ке Python, чтобы упростить ее использование. Для начала посмотрим,
как выглядит обычный запуск команды:
[ngift@Macintosh8][H:10285][J:0]# snmpdfc public v 2c example.com
Description size (kB) Used Available Used%
Memory Buffers 2067636 249560 1818076 12%
Real Memory 2067636 1990704 76932 96%
Swap Space 1012084 64 1012020 0%
/ 74594112 17420740 57173372 23%
/sys 0 0 0 0%
/boot 101086 20041 81045 19%
```
```
Для тех, кто не знаком с командой snmpdf, поясним, что она предназна
чена для удаленного выполнения в системах, обладающих поддерж
кой SNMP и настроенных для получения информации из раздела MIB,
имеющего отношение к дискам. Часто инструменты командной стро
ки, использующие протокол SNMP, обладают большим числом пара
метров, что осложняет их использование. Справедливости ради следу
ет заметить, что создатели вынуждены разрабатывать инструменты,
которые могли бы работать с версиями 1, 2 и 3 протокола SNMP, и до
полнительно разрешать целый ворох других проблем. А что, если эти
```

**472** Глава 13. Командная строка

```
проблемы к вам не относятся и к тому же вы достаточно ленивы? Вы
можете создать собственную кудзуверсию утилиты snmpdf, которая
принимает в качестве аргумента только имя машины. Без всяких со
мнений, это возможно. В примере 13.10 показано, как могла бы вы
глядеть такая утилита.
```
```
Часто, чтобы изменить поведение утилиты UNIX с помощью
языка Python, приходится писать больше строк программного
кода, чем на языке Bash. Но, несмотря на это, мы отдаем пред
почтение языку Python, потому что он позволяет использовать
более богатый набор средств для расширения инструментов под
свои нужды. Кроме того, вы можете протестировать этот про
граммный код точно так же, как вы тестируете другие свои сце
нарии, поэтому часто дополнительный программный код – это
правильный выбор в долгосрочной перспективе.
```
```
Пример 13.10. Обертка для команды snmpdf на языке Python
#!/usr/bin/env python
import optparse
from subprocess import call
```
```
def main():
p = optparse.OptionParser(description="Python wrapped snmpdf command",
prog="pysnmpdf",
version="0.1a",
usage="%prog machine")
p.add_option("c", "community", help="snmp community string")
p.add_option("V", "Version", help="snmp version to use")
p.set_defaults(community="public",Version="2c")
options, arguments = p.parse_args()
SNMPDF = "snmpdf"
if len(arguments) == 1:
machine = arguments[0]
#Измененное действие команды snmpdf
call([SNMPDF, "c", options.community, "v",options.Version, machine])
else:
p.print_help()
```
```
if __name__ == '__main__':
main()
```
```
Этот сценарий уместился примерно в двадцать строк программного ко
да, но он делает нашу жизнь намного проще. Использование волшеб
ных особенностей модуля optparse помогло предусмотреть значения по
умолчанию для некоторых аргументов, наилучшим образом соответ
ствующие нашим потребностям. Например, мы определили, что по
умолчанию будет использоваться версия 2 протокола SNMP, так как
мы знаем, что в нашем вычислительном центре используется только
эта версия протокола. Кроме того, для параметра community мы выбра
ли в качестве значения по умолчанию строку "public", потому что
```

Внедрение команд оболочки в инструменты командной строки на языке Python **473**

```
именно это значение определено в нашей лаборатории исследований
и разработки, например. Самое замечательное, что использование мо
дуля optparse позволило нам гибко изменять значения параметров, не
изменяя сам сценарий.
Обратите внимание, что значения по умолчанию устанавливаются с по
мощью метода set_default(), который позволяет одним вызовом уста
навливать сразу все значения по умолчанию аргументов инструмента
командной строки. Мы включили старые параметры, такие как –c,
и с помощью модуля optparse обернули их новыми значениями, в дан
ном случае – options.community. Хотелось бы надеяться, что этот при
мер достаточно наглядно демонстрирует, как прием «кудзу» и широ
кие возможности языка Python позволяют обернуть инструмент и из
менить его так, чтобы он полнее отвечал нашим потребностям.
```
**Шаблон проектирования «гибрид кудзу»: обертывание**

**инструментов сценариями на языке Python**

**с изменением их поведения**

```
В последнем примере мы существенно облегчили использование ути
литы snmpdf, но не изменили поведение инструмента. Оба инструмента
выводят совершенно идентичную информацию. Другой прием, кото
рый можно использовать, позволяет не только обернуть утилиту
UNIX, но и изменить ее поведение с помощью языка Python.
В следующем примере мы воспользуемся генераторами языка Python
и приемами функционального программирования, чтобы отфильтро
вать результаты нашей команды snmpdf в поисках критически важной
информации и затем добавить к ней флаг "CRITICAL". В примере 13.11
показано, как могла бы выглядеть такая утилита.
```
```
Пример 13.11. Измененная версия команды snmpdf с применением генераторов
#!/usr/bin/env python
import optparse
from subprocess import Popen, PIPE
import re
def main():
p = optparse.OptionParser(description="Python wrapped snmpdf command",
prog="pysnmpdf",
version="0.1a",
usage="%prog machine")
p.add_option("c", "community", help="snmp community string")
p.add_option("V", "Version", help="snmp version to use")
p.set_defaults(community="public",Version="2c")
options, arguments = p.parse_args()
SNMPDF = "snmpdf"
if len(arguments) == 1:
machine = arguments[0]
```

**474** Глава 13. Командная строка

```
#Вложенная функциягенератор
def parse():
"""Возвращает объектгенератор со строкой от команды snmpdf"""
ps = Popen([SNMPDF, "c", options.community,
"v",options.Version, machine],
stdout=PIPE, stderr=PIPE)
return ps.stdout
#Конвейер генераторов для поиска критических значений
pattern = "9[09]%"
outline = (line.split() for line in parse()) #удалить возвраты каретки
flag = (" ".join(row) for row in outline if re.search(pattern,
row[1]))
#поиск по шаблону и объединение соответствующих строк в список
for line in flag: print "%s CRITICAL" % line
#Пример возвращаемого значения
#Real Memory 2067636 1974120 93516 95% CRITICAL
else:
p.print_help()
```
```
if __name__ == '__main__':
main()
```
```
Запустив эту «измененную» версию команды snmpdf, мы получили сле
дующий результат на тестовой машине:
```
```
[ngift@Macintosh8][H:10486][J:0]# python snmpdf_alter.py localhost
Real Memory 2067636 1977208 90428 95% CRITICAL
```
```
Теперь у нас имеется совершенно другой сценарий, который выводит
только значения от 90 процентов и выше, обозначенные нами как кри
тические. Мы могли бы запускать этот сценарий из cron каждую ночь
для опроса нескольких сотен машин и отправлять результаты, полу
ченные от нашего сценария, по электронной почте. Кроме того, мы
могли бы расширить этот сценарий и отыскивать записи с объемом ис
пользования 80 процентов, 70 процентов и выдавать предупреждения
по достижении этих уровней. Такой сценарий легко можно было бы
объединить, например, с Google App Engine, с целью создания вебпри
ложения, выполняющего мониторинг использования дискового про
странства во всей инфраструктуре.
Рассмотрим теперь сам программный код. Здесь есть несколько мо
ментов, отличающих этот сценарий от предыдущих примеров, на ко
торых стоит остановиться. Первое отличие состоит в том, что вместо
функции subprocess.call() используется метод subprocess.Popen(). Если
вам когданибудь потребуется анализировать вывод, получаемый от
утилиты UNIX, то subprocess.Popen() – это именно то, что вам нужно.
Кроме того, обратите внимание, что мы использовали метод stdout.re
adlines(), который возвращает список строк. Это будет важно позднее,
когда эти выходные данные будут пропускаться через серию выраже
нийгенераторов.
```

Внедрение команд оболочки в инструменты командной строки на языке Python **475**

```
В разделе с конвейером генераторов мы пропускаем наш объектгене
ратор через два выражения, выполняющих поиск критических значе
ний в соответствии с заданным нами условием. Как отмечалось выше,
мы легко могли бы добавить еще пару строк с выражениямигенерато
рами, чтобы получить результаты для пороговых значений 70 и 80
процентов.
```
```
Этот инструмент, возможно, оказался немного более сложным,
чем вам хотелось бы. Возможно, лучше было бы разбить его на
несколько небольших и универсальных частей, которые можно
было бы импортировать. И всетаки этот сценарий неплохо ил
люстрирует наш пример.
```
**Шаблон проектирования «гибрид кудзу»: обертывание**

**инструментов сценариями на языке Python**

**с порождением процессов**

```
Наш последний пример был достаточно интересным, но существует еще
один интересный способ изменения поведения существующих инстру
ментов UNIX, основанный на запуске нескольких копий для повыше
ния эффективности. Конечно, это может выглядеть немного странным,
но иногда вам просто необходимо будет творчески подходить к своей
работе. Это одна из сторон профессии системного администратора, ко
гда время от времени для разрешения проблем приходится делать бе
зумные вещи.
В примере этого раздела мы создали тестовый сценарий, который соз
давал файлы образов с помощью команд dd, работающих параллельно.
Возьмем эту идею за основу и создадим инструмент командной строки,
который можно было бы использовать снова и снова. Как минимум,
получим средство создания высокой нагрузки на дисковую подсисте
му вводавывода, которое пригодится для тестирования нового файло
вого сервера. Исходный текст сценария приводится в примере 13.12.
```
```
Пример 13.12. Множественная команда dd
from subprocess import Popen, PIPE
import optparse
import sys
class ImageFile():
"""Создает файлы образов с помощью dd"""
def __init__(self, num=None, size=None, dest=None):
self.num = num
self.size = size
self.dest = dest
def createImage(self):
"""создает N идентичных файлов образов по 10 Мбайт"""
value = "%sMB " % str(self.size/1024)
```

**476** Глава 13. Командная строка

```
for i in range(self.num):
try:
cmd = "dd if=/dev/zero of=%s/file.%s bs=1024 count=%s"\
% (self.dest,i,self.size)
Popen(cmd, shell=True, stdout=PIPE)
except Exception, err:
sys.stderr.write(err)
def controller(self):
"""Запускает множество команд dd"""
p = optparse.OptionParser(description="Launches Many dd",
prog="Many dd",
version="0.1",
usage="%prog [options] dest")
p.add_option('n', 'number', help='set many dd',
type=int)
p.add_option('s', 'size', help='size of image in bytes',
type=int)
p.set_defaults(number=10,
size=10240)
options, arguments = p.parse_args()
if len(arguments) == 1:
self.dest = arguments[0]
self.size = options.size
self.num = options.number
#запуск команд dd
self.createImage()
```
```
def main():
start = ImageFile()
start.controller()
if __name__ == "__main__":
main()
```
```
Теперь при запуске нашей версии команды dd мы можем определять
размер одного файла в байтах, путь и общее число файлов/процессов.
Ниже показано, как выглядит вывод этого инструмента:
```
```
$ ./subprocess_dd.py /tmp/
$ 10240+0 records in
10240+0 records out
10485760 bytes transferred in 1.353665 secs (7746199 bytes/sec)
10240+0 records in
10240+0 records out
10485760 bytes transferred in 1.793615 secs (5846160 bytes/sec)
10240+0 records in
10240+0 records out
10485760 bytes transferred in 2.664616 secs (3935186 bytes/sec)
```
```
...дальнейший вывод опущен для экономии места....
```

Интеграция конфигурационных файлов **477**

```
Сразу же можно сказать, что этот инструмент мог бы пригодиться для
тестирования производительности дисковой подсистемы вводавывода
на высокоскоростных устройствах Fibre SAN или NAS. Приложив еще
немного усилий, можно было бы добавить функции для создания отче
тов в формате PDF и отправки результатов по электронной почте. Сле
дует отметить, что то же самое можно было бы реализовать на основе
потоков выполнения, если потоки соответствуют уровню сложности
проблемы, которую необходимо решить.
```
**Интеграция конфигурационных файлов**

```
Интеграция конфигурационных файлов в инструменты командной
строки имеет особую важность для повышения простоты использова
ния и выполнения дополнительных настроек в будущем. На первый
взгляд разговоры об удобстве использования инструментов командной
строки кажутся немного странными, потому что обычно эта тема рас
сматривается только относительно приложений с графическим интер
фейсом или вебприложений. Это несправедливо, потому что инстру
менты командной строки заслуживают такого же внимательного отно
шения к простоте и удобству использования, какое уделяется при соз
дании приложений с графическим интерфейсом.
Конфигурационный файл может также быть полезным средством для
централизованного управления инструментом командной строки, за
пускаемым на разных машинах. Доступ к разделяемому конфигура
ционному файлу можно обеспечить средствами NFS, после чего сотни
машин могли бы считывать его из универсального инструмента ко
мандной строки, созданного вами. С другой стороны, у вас может
иметься своя система управления настройками, которая также могла
бы использоваться для передачи конфигурационных файлов инстру
ментам, созданным вами.
В состав стандартной библиотеки языка Python входит замечательный
модуль ConfigParser, предназначенный для чтения и записи конфигу
рационных файлов, использующий синтаксис ini файлов. Оказывает
ся, формат .ini является прекрасным способом хранения простых кон
фигурационных данных, не требующим от человека, выполняющего
редактирование файла, использования XML и знаний языка Python.
```
```
Следует иметь в виду, что порядок следования записей в конфи
гурационном файле не имеет значения. Для представления со
держимого конфигурационного файла модуль ConfigParser ис
пользует словарь, и вы должны будете обращаться к нему соот
ветствующим образом, чтобы получить корректное отображение.
```
```
Прежде чем приступить к интегрированию конфигурационных фай
лов в инструмент командной строки, мы создадим конфигурационный
```

**478** Глава 13. Командная строка

```
файл «hello world». Создайте файл с именем hello_config.ini и добавьте
в него следующие строки:
```
```
[Section A]
phrase=Config
```
```
Теперь, когда у нас имеется простейший конфигурационный файл, мы
можем приступить к интегрированию этого файла в наш предыдущий
пример инструмента командной строки «Hello World», как показано
в примере 13.13.
```
```
Пример 13.13. Инструмент командной строки с поддержкой
конфигурационного файла
#!/usr/bin/env python
import optparse
import ConfigParser
def readConfig(file="hello_config.ini"):
Config = ConfigParser.ConfigParser()
Config.read(file)
sections = Config.sections()
for section in sections:
#раскомментируйте следующую строку, чтобы увидеть,
#как выполняется разбор конфигурационного файла
#print Config.items(section)
phrase = Config.items(section)[0][1]
return phrase
def main():
p = optparse.OptionParser()
p.add_option('sysadmin', 's')
p.add_option('config', 'c', action="store_true")
p.set_defaults(sysadmin="BOFH")
```
```
options, arguments = p.parse_args()
if options.config:
options.sysadmin = readConfig()
print 'Hello, %s' % options.sysadmin
```
```
if __name__ == '__main__':
main()
```
```
Если теперь запустить этот инструмент без какихлибо параметров,
мы получим значение по умолчанию BOFH, как и в оригинальной вер
сии программы «Hello World»:
[ngift@Macintosh8][H:10543][J:0]# python hello_config_optparse.py
Hello, BOFH
```
```
Однако, если указать параметр ––config, сценарий прочитает содержи
мое конфигурационного файла и даст такой ответ:
[ngift@Macintosh8][H:10545][J:0]# python hello_config_optparse.pyconfig
Hello, Config
```

В большинстве случаев вполне достаточно будет для параметра
––config использовать путь к файлу по умолчанию, но позволить
при этом прямо указывать местоположение конфигурационного
файла. Для этого вместо определения действия store_true мож
но сделать следующее:
p.add_option('config', 'c',
help='Path to read in config file')
```
```
Если бы это была более крупная и полезная программа, мы могли бы
передать ее любому пользователю, даже не знающему языка Python.
Реализованный подход позволил бы ему настраивать поведение про
граммы, изменяя значение в строке phrase=Config, без необходимости
касаться программного кода. Даже если пользователь обладает знани
ем языка Python, он будет избавлен от ввода в командной строке одних
и тех же параметров снова и снова, и при этом сохранится гибкость ин
струмента.
```
**В заключение**

```
Модули optparse и ConfigParser, входящие в состав стандартной биб
лиотеки языка Python, очень просты в работе и давно уже включены
в библиотеку, поэтому они должны быть доступны в большинстве сис
тем, с которыми вам придется сталкиваться. Если вам потребуется на
писать множество инструментов командной строки, то есть смысл ис
следовать дополнительные возможности модуля optparse, такие как
функции обратного вызова и расширение самого модуля optparse. Вам
также могут пригодиться несколько взаимосвязанных модулей, кото
рые отсутствуют в стандартной библиотеке, такие как: CommandLine
App ( http://www.doughellmann.com/projects/CommandLineApp/ ), Arg
parse ( http://pypi.python.org/pypi/argparse ) и ConfigObj ( http://pypi.py>
thon.org/pypi/ConfigObj ).
```
