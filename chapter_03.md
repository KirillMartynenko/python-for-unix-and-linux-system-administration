# Глава 3. Текст

Практически каждому системному администратору приходится иметь
дело с текстом в той или иной форме, например, с файлами журналов,
данными приложений, с XML, HTML и конфигурационными файла
ми или с выводом некоторых команд. Обычно для работы вполне хва
тает таких утилит, как grep и awk, но иногда для решения сложных за
дач необходим более элегантный и выразительный инструмент. Когда
возникает потребность создать файл с данными, извлеченными из дру
гих файлов, часто бывает достаточно перенаправить вывод процесса
обработки (здесь опять приходят на ум grep и awk) в файл. Но иногда
складываются ситуации, когда для выполнения задания требуется ин
струмент с более широкими возможностями.

Как мы уже говорили во «Введении», наш опыт показывает, что язык
Python можно рассматривать как более элегантный, выразительный
и расширяемый, чем Perl, Bash или другие языки программирова
ния, которые мы использовали в своей практике. Подробное описание
причин, почему мы оцениваем Python более высоко, чем Perl или Bash
(то же самое относится к sed и awk), приводится в главе 1. Стандартная
библиотека языка Python, особенности языка и встроенные типы
представляют собой мощные средства чтения текстовых файлов, ма
нипулирования текстом и извлечения информации из текстовых фай
лов. Язык Python и стандартная библиотека обладают богатыми и гиб
кими функциональными возможностями обработки текста с помощью
строкового типа, файлового типа и модуля регулярных выражений.
Недавнее пополнение стандартной библиотеки – модуль ElementTree –
чрезвычайно удобен при работе с данными в формате XML. В этой гла
ве мы покажем, как эффективно использовать стандартную библиоте
ку и встроенные компоненты при работе с текстовой информацией.


## Встроенные компоненты Python и модули.

**str**

Строка – это просто последовательность символов. При любой работе
с текстовой информацией вы почти наверняка вынуждены будете ра
ботать с ней как со строковым объектом или с последовательностью
строковых объектов. Строковый тип, str, – это мощное, гибкое средст
во манипулирования строковыми данными. В этом разделе показыва
ется, как создавать строки и какие операции можно выполнять над
ними после их создания.
```
```
Создание строк
Обычно строка создается путем заключения некоторого текста в ка
вычки:
In [1]: string1 = 'This is a string'
```
```
In [2]: string2 = "This is another string"
In [3]: string3 = '''This is still another string'''
```
```
In [4]: string4 = """And one more string"""
In [5]: type(string1), type(string2), type(string3), type(string4)
Out[5]: (<type 'str'>, <type 'str'>, <type 'str'>, <type 'str'>)
```
```
Апострофы и кавычки, обычные и тройные, обозначают одно и то же:
все они создают объект типа str. Апострофы и кавычки идентичны по
своему действию и являются взаимозаменяемыми. Этим язык Python
отличается от командных оболочек UNIX, где апострофы и кавычки
не являются взаимозаменяемыми. Например:
```
```
jmjones@dink:~$ FOO=sometext
jmjones@dink:~$ echo "Here is $FOO"
Here is sometext
jmjones@dink:~$ echo 'Here is $FOO'
Here is $FOO
```
```
В языке Perl апострофы и кавычки также не могут замещать друг дру
га при создании строк. Ниже приводится похожий пример на языке
Perl.
```
```
#!/usr/bin/perl
$FOO = "some_text";
print " $FOO\n";
print ' $FOO\n';
```
```
И вот какие результаты дает этот небольшой сценарий на языке Perl:
jmjones@dinkgutsy:code$ ./quotes.pl
some_text
$FOO\njmjones@dinkgutsy:code$
```

**104** Глава 3. Текст

```
Это различие отсутствует в языке Python. Право определять различия
Python оставляет за программистом. Например, вы можете использо
вать апострофы, когда внутри строки должны находиться кавычки
и вам не хотелось бы экранировать их (символом обратного слеша).
Точно так же вы можете использовать кавычки, когда внутри строки
должны присутствовать апострофы и вам не хотелось бы экранировать
их, как показано в примере 3.1.
```
```
Пример 3.1. Кавычки и апострофы в языке Python
In [1]: s = "This is a string with 'quotes' in it"
In [2]: s
Out[2]: "This is a string with 'quotes' in it"
In [3]: s = 'This is a string with \'quotes\' in it'
```
```
In [4]: s
Out[4]: "This is a string with 'quotes' in it"
```
```
In [5]: s = 'This is a string with "quotes" in it'
In [6]: s
Out[6]: 'This is a string with "quotes" in it'
In [7]: s = "This is a string with \"quotes\" in it"
```
```
In [8]: s
Out[8]: 'This is a string with "quotes" in it'
```
```
Обратите внимание, что во 2й и 4й строках вывода (Out [4] и Out [8])
включение в строку экранированных кавычек того же типа, что и окру
жающие строку, привело при выводе к изменению типа наружных ка
вычек. (В действительности это приводит отображение строки
к «правильному» применению кавычек разных типов.)
Иногда бывает необходимо, чтобы в одной строке объединялось не
сколько строк. Иногда эту проблему можно решить, вставляя символ
\n там, где необходимо создать разрыв строки, но это довольно неудоб
ный способ. Другая, более ясная альтернатива заключается в исполь
зовании тройных кавычек, которые позволяют определять много
строчный текст. В примере 3.2 демонстрируется неудачная попытка
использовать апострофы для определения многострочного текста и ус
пешная попытка использовать тройные апострофы.
```
```
Пример 3.2. Тройные кавычки
In [6]: s = 'this is
```
```
File "<ipython console>", line 1
s = 'this is
^
SyntaxError: EOL while scanning singlequoted string
(SyntaxError: обнаружен конец строки при интерпретации строки в апострофах)
```

Встроенные компоненты Python и модули **105**

```
In [7]: s = '''this is a
...: multiline string'''
```
```
In [8]: s
Out[8]: 'this is a\nmultiline string'
```
```
Помимо этого существует еще один способ обозначения строк, которые
в языке Python называются «сырыми» строками. Сырые строки созда
ются добавлением символа r непосредственно перед открывающей ка
вычкой. По сути дела, сырые строки отличаются от обычных строк
тем, что в сырых строках Python не интерпретирует экранированные
последовательности символов, тогда как в обычных строках они интер
претируются. При интерпретации экранированных последовательно
стей в языке Python соблюдается практически тот же набор правил, ко
торый описывается стандартом языка C. Например, в обычных стро
ках последовательность \t интерпретируется как символ табуляции,
\n– как символ новой строки и \r – как перевод строки. В табл. 3.1
приводится список экранированных последовательностей в языке Py
thon.
```
```
Таблица 3.1. Экранированные последовательности в языке Python
```
```
Последовательность Интерпретируется как
\newline Игнорируется
\\ Символ обратного слеша
\' Апостроф
\" Кавычка
\a ASCIIсимвол звукового сигнала
\b ASCIIсимвол забоя
\f ASCIIсимвол перевода формата (страницы)
\n ASCIIсимвол новой строки
\N{имя} Именованный символ Юникода (только для строк
в кодировке Юникод)
\r ASCIIсимвол возврата каретки
\t ASCIIсимвол горизонтальной табуляции
\uxxxx Шестнадцатеричный код 16битового символа
(только для строк в кодировке Юникод)
\Uxxxxxxxx Шестнадцатеричный код 32битового символа
(только для строк в кодировке Юникод)
\v ASCIIсимвол вертикальной табуляции
\ooo Восьмеричный код символа
\xhh Шестнадцатеричный код символа
```
Об экранированных последовательностях и сырых строках стоит пом
нить, особенно, когда приходится иметь дело с регулярными выраже
ниями, к которым мы подойдем далее в этой главе. В примере 3.3 де
монстрируется использование экранированных последовательностей
и неформатированных строк.

```
Пример 3.3. Экранированные последовательности и сырые строки
In [1]: s = '\t'
In [2]: s
Out[2]: '\t'
In [3]: print s
```
```
In [4]: s = r'\t'
In [5]: s
Out[5]: '\\t'
In [6]: print s
\t
In [7]: s = '''\t'''
```
```
In [8]: s
Out[8]: '\t'
```
```
In [9]: print s
In [10]: s = r'''\t'''
```
```
In [11]: s
Out[11]: '\\t'
```
```
In [12]: print s
\t
```
```
In [13]: s = r'\''
In [14]: s
Out[14]: "\\'"
In [15]: print s
\'
```

Когда выполняется интерпретация экранированных последовательно
стей, \t превращается в символ табуляции. Когда интерпретация не
выполняется, экранированная последовательность \t воспринимает
ся, как строка из двух символов, \ и t. Строки, окруженные кавычка
ми или апострофами, обычными или тройными, подразумевают, что
последовательность \t будет интерпретироваться как символ табуля
ции. Если те же самые строки предваряются символом r, последова
тельность \t интерпретируется как два символа, \ и t.
Еще один фокус этого примера – различия между __repr__ и __str__. Ко
гда имя переменной вводится в строке приглашения оболочки IPython и нажимается клавиша Enter, значение переменной отображается вызовом метода __repr__. Когда вводится инструкция print, которой передается имя переменной, и нажимается клавиша Enter, переменная отображается вызовом метода __str__. Инструкция print интерпретирует экранированные последовательности в строке и отображает их соответствующим образом. Подробнее о __repr__ и __str__ рассказывается в главе 2, в разделе «Базовые понятия».

Встроенные методы извлечения строковых данных

Строки в языке Python – это объекты, поэтому они имеют методы, ко
торые могут вызываться для выполнения определенных операций. Од
нако под «методами» мы подразумеваем не только методы, которыми
обладает тип str, но и любые другие способы, позволяющие извлекать
данные из объектов типа str. Сюда входят все методы типа str, а также
операторы in и not in, приведенные в примере, следующем ниже.
С технической точки зрения, операторы проверки условия in и not in
вызывают метод __contains__() объекта str. За дополнительной инфор
мацией о том, как работают эти операторы, обращайтесь к приложе
нию. Операторы in и not in могут использоваться для проверки, яв
ляется ли некоторая строка частью другой строки, как показано в при
мере 3.4.
```
```
Пример 3.4. Операторы in и not in
In [1]: import subprocess
In [2]: res = subprocess.Popen(['uname', 'sv'], stdout=subprocess.PIPE)
```
```
In [3]: uname = res.stdout.read().strip()
In [4]: uname
Out[4]: 'Linux #1 SMP Tue Feb 12 02:46:46 UTC 2008'
In [5]: 'Linux' in uname
Out[5]: True
In [6]: 'Darwin' in uname
Out[6]: False
In [7]: 'Linux' not in uname
Out[7]: False
In [8]: 'Darwin' not in uname
Out[8]: True
```
```
Если строка string2 содержит строку string1, то выражение string1 in
string2 вернет значение True, в противном случае – значение False. По
этому проверка вхождения строки "Linux" в строку uname в нашем слу
чае дает в результате значение True, а проверка вхождения строки
"Darwin" в строку uname дает значение False. Применение оператора not
in мы привели «для комплекта».
Иногда бывает достаточно узнать, что некоторая строка является под
строкой другой строки. А иногда требуется узнать, в какой позиции
находится искомая подстрока. Выяснить это можно с помощью мето
дов find() и index(), как показано в примере 3.5.
```
```
Пример 3.5. Методы find() и index()
In [9]: uname.index('Linux')
Out[9]: 0
In [10]: uname.find('Linux')
Out[10]: 0
In [11]: uname.index('Darwin')
```
```
<type 'exceptions.ValueError'> Traceback (most recent call last)
```
```
/home/jmjones/code/<ipython console> in <module>()
<type 'exceptions.ValueError'>: substring not found
```
```
In [12]: uname.find('Darwin')
Out[12]:1
```
```
Если строка string1 присутствует в строке string2 (как в данном приме
ре), метод string2.find(string1) вернет индекс первого символа string1
в строке string2, в противном случае он вернет – 1. (Не беспокойтесь,
к индексам мы перейдем через мгновение). Точно так же, если строка
string1 присутствует в строке string2, метод string2.index(string1) вер
нет индекс первого символа string1 в строке string2, в противном слу
чае он возбудит исключение ValueError. В данном примере метод find()
обнаружил подстроку "Linux" в начале строки, поэтому он вернул зна
чение 0. Однако метод find() не смог обнаружить подстроку "Darwin"
в этой строке, поэтому он вернул значение – 1. Когда в операционной
системе Linux была выполнена попытка отыскать подстроку "Linux"
спомощью метода index(), был получен тот же результат, что и в слу
чае применения метода find(). Но при попытке отыскать подстроку
"Darwin" метод index() возбудил исключение ValueError, показывая, что
не смог отыскать эту подстроку.
Итак, что можно делать с этими числовыми «индексами»? Зачем они
нам нужны? Строки интерпретируются как списки символов. «Ин
декс», который возвращается методами find() и index(), просто пока
зывает, начиная с какого символа в большей строке было обнаружено
совпадение, как показано в примере 3.6.
```
```
Пример 3.6. Срез строки
In [13]: smp_index = uname.index('SMP')
```
```
In [14]: smp_index
Out[14]: 9
```
```
In [15]: uname[smp_index:]
Out[15]: 'SMP Tue Feb 12 02:46:46 UTC 2008'
In [16]: uname[:smp_index]
```
```
Out[16]: 'Linux #1 '
In [17]: uname
```
```
Out[17]: 'Linux #1 SMP Tue Feb 12 02:46:46 UTC 2008'
```
```
Мы оказались в состоянии увидеть все символы, начиная с символа,
индекс которого был получен в результате поиска подстроки "SMP",
и до конца строки, воспользовавшись синтаксической конструкцией
извлечения среза string[index:]. Мы также смогли увидеть все симво
лы от начала строки uname до индекса, который был получен в резуль
тате поиска подстроки "SMP", применив синтаксическую конструкцию
извлечения среза string[:index]. Все различия между этими двумя
конструкциями заключаются в местоположении символа двоеточия
(:) относительно индекса.
Цель примеров на извлечение среза строки и применения операторов
in и not in состоит в том, чтобы показать вам, что строки являются по
следовательностями и поэтому обладают теми же особенностями, что
и другие последовательности, такие как списки. Более полно последо
вательности обсуждаются в разделе «Sequence Operations» в главе 4
книги «Python in a Nutshell» (издательство O’Reilly) Алекса Мартелли
(Alex Martelli) (этот раздел доступен в Интернете на сайте издательст
ва: http://safari.oreilly.com/0596100469/pythonian>CHP>4>SECT>6 ).
Еще два строковых метода, startswith() и endswith(), как следует из их
названий, помогут определить, «начинается» ли или «заканчивается»
ли строка определенной подстрокой, как показано в примере 3.7.

```
Пример 3.7. Методы startswith() и endswith()
In [1]: some_string = "Raymond LuxuryYacht"
In [2]: some_string.startswith("Raymond")
Out[2]: True
In [3]: some_string.startswith("Throatwarbler")
Out[3]: False
In [4]: some_string.endswith("LuxuryYacht")
Out[4]: True
In [5]: some_string.endswith("Mangrove")
Out[5]: False
```

Как видите, интерпретатор Python возвращает информацию, которая
говорит о том, что строка «Raymond LuxuryYacht» начинается с под
строки «Raymond» и заканчивается подстрокой «LuxuryYacht». Она
не начинается с подстроки «Throatwarbler» и не заканчивается подстро
кой «Mangrove». Достаточно просто те же результаты можно получить с помощью операции извлечения среза, но такой подход к решению выглядит менее наглядно и может показаться несколько утомительным в реализации, как показано в примере 3.8:

```
Пример 3.8. Имитация методов startswith() и endswith()
In [6]: some_string[:len("Raymond")] == "Raymond"
Out[6]: True
```
```
In [7]: some_string[:len("Throatwarbler")] == "Throatwarbler"
Out[7]: False
```
```
In [8]: some_string[len("LuxuryYacht"):] == "LuxuryYacht"
Out[8]: True
```
```
In [9]: some_string[len("Mangrove"):] == "Mangrove"
Out[9]: False
```

Операция извлечения среза создает и возвращает новый строко
вый объект, а не изменяет саму строку. Если операции извлече
ния среза часто используются в сценарии, они могут оказывать
существенное влияние на потребление памяти и на производи
тельность. Даже если заметного влияния на производитель
ность не ощущается, тем не менее, лучше воздержаться от ис
пользования операций извлечения среза в случаях, когда доста
точно применения методов startswith() и endswith().
Мы сумели убедиться, что первые символы в строке some_string, число
которых равно длине строки «Raymond», соответствуют строке «Ray
mond». Другими словами, мы сумели убедиться, что строка some_string
начинается с подстроки «Raymond», без использования метода
startswith(). Точно так же мы смогли убедиться, что строка заканчи
вается подстрокой «LuxuryYacht».
Методы lstrip(), rstrip() и strip() без аргументов удаляют ведущие,
заключительные, и ведущие и заключительные пробельные символы,
соответственно. В качестве таких пробельных символов можно на
звать символы табуляции, пробелы, символы возврата каретки и но
вой строки. Метод lstrip() без аргументов удаляет любые пробельные
символы, которые находятся в начале строки, и возвращает новую
строку. Метод rstrip() без аргументов удаляет любые пробельные сим
волы, которые находятся в конце строки, и возвращает новую строку.
Метод strip() без аргументов удаляет любые пробельные символы, ко
торые находятся в начале и в конце строки, и возвращает новую стро
ку, как показано в примере 3.9.
Все три метода из семейства strip() не изменяют саму строку,
а создают и возвращают новый строковый объект. Возможно,
вы никогда не будете испытывать проблем с таким поведением
методов, но вы должны знать о нем.


_Пример 3.9. Методы lstrip(), rstrip() и strip()_

```
In [1]: spacious_string = "\n\t Some NonSpacious Text\n \t\r"
```
```
In [2]: spacious_string
Out[2]: '\n\t Some NonSpacious Text\n \t\r'
```
```
In [3]: print spacious_string
Some NonSpacious Text
```
```
In [4]: spacious_string.lstrip()
Out[4]: 'Some NonSpacious Text\n \t\r'
```
```
In [5]: print spacious_string.lstrip()
Some NonSpacious Text
```
```
In [6]: spacious_string.rstrip()
Out[6]: '\n\t Some NonSpacious Text'
```
```
In [7]: print spacious_string.rstrip()
Some NonSpacious Text
```
```
In [8]: spacious_string.strip()
Out[8]: 'Some NonSpacious Text'
```
```
In [9]: print spacious_string.strip()
Some NonSpacious Text
```
```
Все три метода, lstrip(), rstrip() и strip(), могут принимать единст
венный необязательный аргумент: строку символов, которые следует
удалить из соответствующего места строки. Это означает, что методы
семейства strip() не просто удаляют пробельные символы – они могут
удалять любые символы, какие вы укажете:
In [1]: xml_tag = "<some_tag>"
In [2]: xml_tag.lstrip("<")
Out[2]: 'some_tag>'
```
```
In [3]: xml_tag.lstrip(">")
Out[3]: '<some_tag>'
In [4]: xml_tag.rstrip(">")
Out[4]: '<some_tag'
In [5]: xml_tag.rstrip("<")
Out[5]: '<some_tag>'
```
```
Здесь мы удалили из тега XML левую и правую угловые скобки, по од
ной за раз. А как быть, если нам потребуется удалить обе скобки одно
временно? Сделать это можно следующим способом:
In [6]: xml_tag.strip("<").strip(">")
```
```
Out[6]: 'some_tag'
```

Методы семейства strip() возвращают строку, поэтому мы можем вы
зывать другие строковые операции прямо вслед за вызовом метода
strip(). В этом примере мы объединили вызовы методов strip() в це
почку. Первый вызов метода strip() удаляет начальный символ (ле
вую угловую скобку) и возвращает строку, а второй метод strip() уда
ляет завершающий символ (правую угловую скобку) и возвращает
строку "some_tag". Однако существует более простой способ:
```
In [7]: xml_tag.strip("<>")
Out[7]: 'some_tag'
```
Возможно, вы подумали, что методы семейства strip() удаляют точное
вхождение указанной подстроки, но в действительности удаляются
любые последовательные вхождения указанных символов с соответст
вующей стороны строки. В этом последнем примере методу strip() бы
ло предписано удалить "<>". Это не означает точное соответствие под
строке "<>" и не означает, что должны быть удалены вхождения этих
двух символов, следующих друг за другом именно в таком порядке, –
это означает, что должны быть удалены символы "<" или ">", находя
щиеся в начале или в конце строки.
Ниже приводится, возможно, более понятный пример:

```
In [8]: gt_lt_str = "<><><>gt lt str<><><>"
In [9]: gt_lt_str.strip("<>")
Out[9]: 'gt lt str'
In [10]: gt_lt_str.strip("><")
Out[10]: 'gt lt str'
```

Здесь мы удалили все вхождения символов "<" или ">" с обоих концов
строки. Таким способом мы можем ликвидировать простые символы
и пробелы.
Следует заметить, что такой прием может работать несколько не так,
как вы ожидаете, например:
```
In [11]: foo_str = "<fooooooo>blah<foo>"
In [12]: foo_str.strip("<foo>")
Out[12]: 'blah'
```
У вас могло бы сложиться мнение, что метод strip() в этом примере
удалит символы справа, но не слева. Однако он обнаружит и удалит
любые последовательные вхождения символов "<", "f", "o" и ">". Это
не ошибка, мы не пропустили второй символ "o". Вот еще один, заклю
чительный пример использования метода strip(), который прояснит
это утверждение:

```
In [13]: foo_str.strip("><of")
Out[13]: 'blah'
```

Здесь удаляются символы ">", "<", "f", "o", хотя они следуют не в этом
порядке.
Методы upper() и lower() удобно использовать, когда необходимо вы
полнить сравнение двух строк без учета регистра символов. Метод up
per() возвращает строку со всеми символами из оригинальной строки
в верхнем регистре. Метод lower() возвращает строку со всеми симво
лами из оригинальной строки в нижнем регистре, как показано в при
мере 3.10.

```
Пример 3.10. Методы upper() и lower()
In [1]: mixed_case_string = "VOrpal BUnny"
```
```
In [2]: mixed_case_string == "vorpal bunny"
Out[2]: False
```
```
In [3]: mixed_case_string.lower() == "vorpal bunny"
Out[3]: True
```
```
In [4]: mixed_case_string == "VORPAL BUNNY"
Out[4]: False
```
```
In [5]: mixed_case_string.upper() == "VORPAL BUNNY"
Out[5]: True
```
```
In [6]: mixed_case_string.upper()
Out[6]: 'VORPAL BUNNY'
```
```
In [7]: mixed_case_string.lower()
Out[7]: 'vorpal bunny'
```

Если вам необходимо извлечь часть строки, ограниченной какимили
бо символамиразделителями, метод split() предоставит вам эту воз
можность, как показано в примере 3.11.

```
Пример 3.11. Метод split()
In [1]: comma_delim_string = "pos1,pos2,pos3"
In [2]: pipe_delim_string = "pipepos1|pipepos2|pipepos3"
```
```
In [3]: comma_delim_string.split(',')
Out[3]: ['pos1', 'pos2', 'pos3']
```
```
In [4]: pipe_delim_string.split('|')
Out[4]: ['pipepos1', 'pipepos2', 'pipepos3']
```

Методу split() передается строкаразделитель, по которому необходи
мо разбить строку на подстроки. Часто это единственный символ, та
кой как запятая или вертикальная черта, но это может быть строка,
содержащая более одного символа. В данном примере мы разбили строку comma_delim_string по запятым, а строку pipe_delim_string – по
символу вертикальной черты (|), передавая символ запятой или верти
кальной черты методу split(). Возвращаемым значением метода явля
ется список строк, каждая из которых представляет собой группу по
следовательных символов, находящихся между разделителями. Когда
в качестве разделителя необходимо использовать не единственный
символ, а некоторую строку, метод split() справится и с этим. К мо
менту написания этих строк в языке Python отсутствовал символьный
тип, поэтому хотя в примерах метод split() получал единственный
символ, он рассматривался методом как строка. Поэтому, когда мето
ду split() передается несколько символов, он обработает и их, как по
казано в примере 3.12.

```
Пример 3.12. Строка>разделитель в методе split()
In [1]: multi_delim_string = "pos1XXXpos2XXXpos3"
```
```
In [2]: multi_delim_string.split("XXX")
Out[2]: ['pos1', 'pos2', 'pos3']
```
```
In [3]: multi_delim_string.split("XX")
Out[3]: ['pos1', 'Xpos2', 'Xpos3']
```
```
In [4]: multi_delim_string.split("X")
Out[4]: ['pos1', '', '', 'pos2', '', '', 'pos3']
```

Обратите внимание, что сначала мы использовали в качестве раздели
теля строку "XXX" для разделения строки multi_delim_string. Как
и ожидалось, в результате был получен список ['pos1', 'pos2', 'pos3'].
Затем, мы использовали в качестве разделителя строку "XX" и метод
split() вернул ['pos1', 'Xpos2', 'Xpos3']. Здесь метод split() выбрал все
символы, находящиеся между соседними разделителями "XX". Под
строка "pos1" начинается с начала строки и простирается до первого
разделителя "XX"; подстрока "Xpos2" располагается сразу за первым
вхождением разделителя "XX" и простирается до второго его вхожде
ния; и подстрока "Xpos3" располагается сразу за вторым вхождением "
XX" и простирается до конца строки. Последний вызов метода split()
получает в качестве разделителя единственный символ "X". Обратите
внимание, что позициям между соседними символами "X" соответству
ют пустые строки ("") в результирующем списке. Это означает, что ме
жду соседними символами "X" ничего нет.
Но как быть, если необходимо разбить строку только по первым n вхо
ждениям указанного разделителя? Для этого методу split() следует
передать второй аргумент, с именем max_split. Когда во втором аргу
менте max_split методу split() передается целочисленное значение, он
выполнит только указанное число разбиений исходной строки:

```
In [1]: two_field_string = "8675309,This is a freeform, plain text, string"
In [2]: two_field_string.split(',', 1)
Out[2]: ['8675309', 'This is a freeform, plain text, string']
```

Здесь мы разбиваем строку по запятым и предписываем методу split()
выполнить только одно разбиение. Несмотря на то, что в строке при
сутствует несколько запятых, строка была разбита только один раз.
Если необходимо разбить строку по пробелам, например, чтобы из
влечь из текста отдельные слова, эту задачу легко можно решить вызо
вом метода split() без аргументов:

```
In [1]: prosaic_string = "Insert your clever little piece of text here."
In [2]: prosaic_string.split()
Out[2]: ['Insert', 'your', 'clever', 'little', 'piece', 'of', 'text', 'here.']
```

Когда метод split() не получает никаких аргументов, по умолчанию
он выполняет разбиение строки по пробельным символам.
Чаще всего вы будете получать именно те результаты, которые ожида
ли получить. Однако в случае многострочного текста результат может
получиться неожиданным для вас. Часто при работе с многострочным
текстом бывает необходимо выполнять его обработку по одной строке
за раз. Но вы можете с удивлением обнаружить, что программа разби
вает такой текст на отдельные слова:

```
In [1]: multiline_string = """This
...: is
...: a multiline
...: piece of
...: text"""
```
```
In [2]: multiline_string.split()
Out[2]: ['This', 'is', 'a', 'multiline', 'piece', 'of', 'text']
```
```
Для таких случаев лучше подходит метод splitlines():
In [3]: lines = multiline_string.splitlines()
```
```
In [4]: lines
Out[4]: ['This', 'is', 'a multiline', 'piece of', 'text']
```

Метод splitlines() возвращает список всех строк из многострочного
текста и сохраняет группы «слов». После этого можно выполнить ите
рации по отдельным строкам текста и извлечь отдельные слова:

```
In [5]: for line in lines:
...: print "START LINE::"
...: print line.split()
...: print "::END LINE"
...:
START LINE::
['This']
::END LINE
START LINE::
['is']
::END LINE
START LINE::
['a', 'multiline']
::END LINE
START LINE::
['piece', 'of']
::END LINE
START LINE::
['text']
::END LINE
```

Иногда бывает необходимо не анализировать строку или извлекать из
нее информацию, а объединить в строку уже имеющиеся данные.
В этом случае вам на помощь придет метод join():

```
In [1]: some_list = ['one', 'two', 'three', 'four']
In [2]: ','.join(some_list)
Out[2]: 'one,two,three,four'
In [3]: ', '.join(some_list)
Out[3]: 'one, two, three, four'
In [4]: '\t'.join(some_list)
Out[4]: 'one\ttwo\tthree\tfour'
In [5]: ''.join(some_list)
Out[5]: 'onetwothreefour'
```

Учитывая, что исходные данные хранятся в виде списка, мы можем
объединить строки 'one', 'two', 'three' и 'four' несколькими способа
ми. Мы объединяем элементы списка some_list с помощью запятой, за
пятой и пробела, символа табуляции и пустой строки. Метод join() –
это строковый метод, поэтому вызов его в качестве метода литерала,
такого как ',', является корректным. Метод join() принимает в каче
стве аргумента последовательность строк и объединяет их в одну стро
ку так, чтобы элементы последовательности располагались в исходном
порядке и отделялись строкой, для которой вызывается метод join().
Мы должны предупредить вас об особенностях поведения метода
join() и об аргументе, который он ожидает получить. Обратите внима
ние: метод join() ожидает получить последовательность строк. А что
произойдет, если ему передать последовательность целых чисел?
Взгляните!

```
In [1]: some_list = range(10)
In [2]: some_list
Out[2]: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
In [3]: ",".join(some_list)


exceptions.TypeError Traceback (most recent call last)
/Users/jmjones/<ipython console>

TypeError: sequence item 0: expected string, int found
(TypeError: элемент 0 последовательности: ожидается строка, обнаружено целое)
```

Диагностическая информация, приложенная к исключению, возбуж
денному методом join(), достаточно ясно объясняет происшедшее, но
так как это довольно распространенная ошибка, в этом стоит разо
браться. Вы легко сможете избежать этой ловушки с помощью просто
го генератора списков. Ниже мы прибегли к помощи генератора спи
сков, чтобы преобразовать все элементы списка some_list, которые со
держат целые числа, в строки:

```
In [4]: ",".join([str(i) for i in some_list])
Out[4]: '0,1,2,3,4,5,6,7,8,9'
```

Или можно использовать выражение-генератор:

```
In [5]: ",".join(str(i) for i in some_list)
Out[5]: '0,1,2,3,4,5,6,7,8,9'
```
```
За дополнительной информацией об использовании генераторов спи
сков обращайтесь к разделу «Control Flow Statements» в главе 4 кни
ги «Python in a Nutshell» (этот раздел доступен в Интернете, на сайте
издательства: http://safari.oreilly.com/0596100469/pythonian>CHP>4>
SECT>10 ).
Последний метод, используемый для создания и изменения текстовых
строк, – это метод replace(). Метод replace() принимает два аргумента:
строку, которую требуется заменить, и строку замены, соответствен
но. Ниже приводится простой пример использования метода replace():
In [1]: replacable_string = "trancendental hibernational nation"
```
```
In [2]: replacable_string.replace("nation", "natty")
Out[2]: 'trancendental hibernattyal natty'
```

Обратите внимание, что метод replace() никак не проверяет, является
замещаемая строка частью слова или отдельным словом. Поэтому ме
тод replace() может использоваться только в случаях, когда просто
требуется заменить определенную последовательность символов дру
гой определенной последовательностью символов.
Иногда требуется более тонкое управление операцией замены, когда
вариант простой замены одной последовательности символов на дру
гую не подходит. В таких случаях обычно бывает необходимо иметь
возможность определить шаблон последовательности символов, кото
рую требуется найти и заменить. Применение шаблонов также может
помочь с поиском требуемого текста для последующего извлечения из
него данных. В тех случаях, когда предпочтительнее использовать
шаблоны, вам помогут регулярные выражения. Регулярные выраже
ния мы рассмотрим далее.
Так же, как операция извлечения среза и метод strip(), метод
replace() не изменяет существующую строку, а создает новую.

```
Строки Юникода
До сих пор во всех примерах работы со строками, которые мы видели,
использовались исключительно строковые объекты встроенного типа
str, но в языке Python существует еще один строковый тип, с которым
вам предстоит познакомиться: строки Юникода. Любые символы, ко
торые выводятся на экран дисплея, внутри компьютера представлены
числами. До появления кодировки Юникод существовало множество
разнообразных наборов отображения числовых кодов в символы в за
висимости от языка и платформы. Юникод – это стандарт, обеспечи
вающий единое отображение числовых кодов в символы, независимое
от языка, платформы или даже программы, выполняющей обработку
текста. В этом разделе мы рассмотрим понятие Юникода и способы ра
боты с этой кодировкой, имеющиеся в языке Python. Подробное опи
сание Юникода вы найдете в превосходном учебнике Э. М. Качлинга
(A. M. Kuchling) по адресу: http://www.amk.ca/python/howto/unicode.
Создание строк Юникода выглядит ничуть не сложнее, чем создание
обычных строк:
In [1]: unicode_string = u'this is a unicode string'
```
```
In [2]: unicode_string
Out[2]: u'this is a unicode string'
```
```
In [3]: print unicode_string
this is a unicode string
```
```
Или можно воспользоваться встроенной функцией unicode():
In [4]: unicode('this is a unicode string')
Out[4]: u'this is a unicode string'
```

На первый взгляд, в этом нет ничего примечательного, особенно если
учесть, что здесь мы имеем дело с символами одного языка. Но как
быть, когда приходится работать с символами из нескольких языков?
Здесь вам на помощь придет Юникод. Чтобы внутри строки Юникода
создать символ с определенным числовым кодом, можно воспользо
ваться нотацией \uXXXX или \uXXXXXXXX. Например, ниже приводится
строка Юникода, содержащая символы латиницы, греческого алфави
та и кириллицы:

```
In [1]: unicode_string = u'abc_\u03a0\u03a3\u03a9_\u0414\u0424\u042F'
In [2]: unicode_string
Out[2]: u'abc_\u03a0\u03a3\u03a9_\u0414\u0424\u042f'
```

Интерпретатор генерирует строку (str) в зависимости от используемой
кодировки. В версии Python, которая поставляется вместе с компью
терами Mac, если попытаться вывести строку из предыдущего приме
ра с помощью инструкции print, будет получено сообщение об ошибке:

```
In [3]: print unicode_string
UnicodeEncodeError Traceback (most recent call last)
/Users/jmjones/<ipython console> in <module>()
UnicodeEncodeError: 'ascii' codec can't encode characters in position 46:
ordinal not in range(128)
(UnicodeEncodeError: кодек 'ascii' не в состоянии кодировать символы
в позиции 46: числовые значения находятся вне диапазона range(128))
```

Мы должны определить другой кодек, который знает, как обрабаты
вать все символы в строке:

```
In [4]: print unicode_string.encode('utf8')
```

Здесь мы выполнили кодирование строки, содержащей символы лати
ницы, греческого алфавита и кириллицы, в кодировку UTF8, которая
наиболее часто используется для кодирования данных Юникода.
Строки Юникода обладают теми же возможностями, такими как воз
можность выполнения проверки с помощью оператора in, и методами,
что и обычные строки, о которых мы уже говорили:

```
In [5]: u'abc' in unicode_string
Out[5]: True
In [6]: u'foo' in unicode_string
Out[6]: False
In [7]: unicode_string.split()
Out[7]: [u'abc_\u03a0\u03a3\u03a9_\u0414\u0424\u042f']
In [8]: unicode_string.
unicode_string.__add__            unicode_string.expandtabs
unicode_string.__class__          unicode_string.find
unicode_string.__contains__       unicode_string.index
unicode_string.__delattr__        unicode_string.isalnum
unicode_string.__doc__            unicode_string.isalpha
unicode_string.__eq__             unicode_string.isdecimal
unicode_string.__ge__             unicode_string.isdigit
unicode_string.__getattribute__   unicode_string.islower
unicode_string.__getitem__        unicode_string.isnumeric
unicode_string.__getnewargs__     unicode_string.isspace
unicode_string.__getslice__       unicode_string.istitle
unicode_string.__gt__             unicode_string.isupper
unicode_string.__hash__           unicode_string.join
unicode_string.__init__           unicode_string.ljust
unicode_string.__le__             unicode_string.lower
unicode_string.__len__            unicode_string.lstrip
unicode_string.__lt__             unicode_string.partition
unicode_string.__mod__            unicode_string.replace
unicode_string.__mul__            unicode_string.rfind
unicode_string.__ne__             unicode_string.rindex
unicode_string.__new__            unicode_string.rjust
unicode_string.__reduce__         unicode_string.rpartition
unicode_string.__reduce_ex__      unicode_string.rsplit
unicode_string.__repr__           unicode_string.rstrip
unicode_string.__rmod__           unicode_string.split
unicode_string.__rmul__           unicode_string.splitlines
unicode_string.__setattr__        unicode_string.startswith
unicode_string.__str__            unicode_string.strip
unicode_string.capitalize         unicode_string.swapcase
unicode_string.center             unicode_string.title
unicode_string.count              unicode_string.translate
unicode_string.decode             unicode_string.upper
unicode_string.encode             unicode_string.zfill
unicode_string.endswith
```

Возможно, строки Юникода не потребуются вам немедленно. Но важно знать об их существовании, если вы собираетесь продолжать программировать на языке Python.

### re


Раз поставка языка Python комплектуется в соответствии с принципом «батарейки включены», можно было бы ожидать, что в состав
стандартной библиотеки будут включены модули для работы с регу
лярными выражениями. Так оно и есть. Акцент в этом разделе сделан
на использовании в языке Python регулярных выражений, а не на под
робностях их синтаксиса. Поэтому, если вы не знакомы с регулярны
ми выражениями, рекомендуем вам приобрести книгу «Mastering Re
gular Expressions» (O’Reilly) Джеффри Е. Ф. Фридла (Jeffrey E. F.
Friedl) (доступна также в Интернете на сайте издательства по адресу:
http://safari.oreilly.com/0596528124 ).^1 Далее мы предполагаем, что вы
достаточно уверенно оперируете регулярными выражениями, в про
тивном случае рекомендуем держать книгу Фридла под рукой.
Если вы знакомы с языком Perl, то, возможно, вы уже использовали
регулярные выражения с оператором =~. В языке Python поддержка
регулярных выражений реализована на уровне библиотеки, а не на
уровне синтаксических особенностей языка. Поэтому для работы с ре
гулярными выражениями необходимо импортировать модуль re. Ни


(^1) Джеффри Фридл «Регулярные выражения», 3-е издание. – Пер. с англ. – СПб.: Символ-плюс, 2008. В Интернете можно ознакомиться с 5-й главой этой книги по адресу http://www.books.ru/chapter?id=592346&num=1 – _Прим. перев._

же приводится простой пример создания и использования регулярного выражения, как показано в примере 3.13.

_Пример 3.13. Простой пример использования регулярного выражения_
```
In [1]: import re
In [2]: re_string = "{{(.*?)}}"
In [3]: some_string = "this is a string with {{words}} embedded in\
...: {{curly brackets}} to show an {{example}} of {{regular expressions}}"
In [4]: for match in re.findall(re_string, some_string):
...: print "MATCH>", match
...:
MATCH> words
MATCH> curly brackets
MATCH> example
MATCH> regular expressions
```

Первое, что мы сделали в этом примере, – импортировали модуль re.
Как вы уже наверняка поняли, имя re происходит от «regular expressions» (регулярные выражения). Затем мы создали строку re_string, ко
торая будет играть роль шаблона для поиска. Этому шаблону будут соответствовать две открывающие фигурные скобки ({{), вслед за которы
ми может следовать текст, завершающийся двумя закрывающими фигурными скобками (}}). Затем мы создали строку some_string, которая
содержит группы слов, окруженные фигурными скобками. И в конце
мы выполнили обход результатов поиска в строке some_string по шаблону re_string, полученных от функции findall() из модуля re. Как ви
дите, пример вывел строки words, curly brackets, example и regular expressions, которые представляют все группы слов, заключенные в двойные
фигурные скобки.
В языке Python существует два способа работы с регулярными выражениями. Первый заключается в непосредственном использовании
функций из модуля re, как в предыдущем примере. Второй способ состоит в том, чтобы создать объект скомпилированного регулярного вы
ражения и затем использовать методы этого объекта.
Итак, что же такое скомпилированное регулярное выражение? Это просто объект, созданный вызовом функции re.compile(), которой пе
редается шаблон. Этот объект, созданный за счет передачи шаблона
функции re.compile(), содержит множество методов для работы с регулярным выражением. Между скомпилированным и нескомпилирован
ным регулярными выражениями имеются два основных отличия. Вопервых, вместо ссылки на шаблон регулярного выражения "{{.*?}}"
создается объект скомпилированного выражения на основе шаблона.
Вовторых, вместо функции findall() из модуля re следует вызывать
метод findall() объекта скомпилированного выражения.

За дополнительной информацией о всех функциях, имеющихся в модуле re, обращайтесь к разделу «Module Contents» в справочнике «Python Library Reference», http://docs.python.org/lib/node46.html. За дополнительной информацией об объектах скомпилированных регулярных выражений обращайтесь к разделу «Regular Expression Objects» в справочнике «Python Library Reference», http://docs.python.org/lib/re-objects.html.
В примере 3.14 представлена реализация предыдущего примера с двойными фигурными скобками, выполненная на основе использования
объекта скомпилированного регулярного выражения.

_Пример 3.14. Простое регулярное выражение, скомпилированный шаблон_
```
In [1]: import re
In [2]: re_obj = re.compile("{{(.*?)}}")
In [3]: some_string = "this is a string with {{words}} embedded in\
...: {{curly brackets}} to show an {{example}} of {{regular expressions}}"
In [4]: for match in re_obj.findall(some_string):
...: print "MATCH>", match
...:
MATCH> words
MATCH> curly brackets
MATCH> example
MATCH> regular expressions
```

Выбор метода работы с регулярными выражениями в языке Python за
висит отчасти от личных предпочтений и от самого регулярного выра
жения. Следует заметить, что метод, основанный на использовании
функций модуля re, уступает в производительности методу, основанно
му на использовании объектов скомпилированных регулярных выра
жений. Проблема производительности особенно остро может вставать,
например, когда регулярное выражение применяется в цикле к каждой
строке текстового файла, содержащего сотни и тысячи строк. В приме
рах ниже представлены реализации простых сценариев, использующих
скомпилированые и нескомпилированные регулярные выражения,
которые применяются к файлу, содержащему 500 000 строк текста.
Если воспользоваться специальной функцией timeit, можно увидеть
разницу в производительности между этими двумя сценариями. Смот
рите пример 3.15.


_Пример 3.15. Тест производительности нескомпилированного регулярного выражения_

```
#!/usr/bin/env python
import re
```
```
def run_re():
pattern = 'pDq'
infile = open('large_re_file.txt', 'r')
match_count = 0
lines = 0
for line in infile:
match = re.search(pattern, line)
if match:
match_count += 1
lines += 1
return (lines, match_count)
if __name__ == "__main__":
lines, match_count = run_re()
print 'LINES::', lines
print 'MATCHES::', match_count
```

Функция timeit выполняет программный код несколько раз и возвра
щает время самого лучшего варианта. Ниже показаны результаты за
пуска утилиты timeit для этого сценария в оболочке IPython:

```
In [1]: import re_loop_nocompile
In [2]: timeitn 5 re_loop_nocompile.run_re()
5 loops, best of 3: 1.93 s per loop
```

В этом примере функция run_re() была вызвана 5 раз, и было вычислено среднее из 3 самых лучших показателей, которое составило 1,93 секунды. Специальная функция timeit выполняется с исследуемым программным кодом несколько раз, чтобы уменьшить погрешность, вызванную влиянием других процессов, исполняющихся в системе.
Ниже приводятся результаты измерения времени выполнения того же самого программного кода с помощью утилиты time операционной системы UNIX:

```
jmjones@dink:~/code$ time python re_loop_nocompile.py
LINES:: 500000 MATCHES:: 242
real 0m2.113s
user 0m1.888s
sys 0m0.163s
```

Пример 3.16 – это тот же пример с регулярным выражением за исключением того, что мы используем re.compile() для создания объекта скомпилированного шаблона.

_Пример 3.16. Тест производительности скомпилированного регулярного выражения_

```
#!/usr/bin/env python
import re
def run_re():
pattern = 'pDq'
re_obj = re.compile(pattern)
infile = open('large_re_file.txt', 'r')
match_count = 0
lines = 0
for line in infile:
match = re_obj.search(line)
if match:
match_count += 1
lines += 1
return (lines, match_count)
if __name__ == "__main__":
lines, match_count = run_re()
print 'LINES::', lines
print 'MATCHES::', match_count
```

Испытания с помощью специальной функции timeit в оболочке IPython дали следующие результаты:

```
In [3]: import re_loop_compile
In [4]: timeitn 5 re_loop_compile.run_re()
5 loops, best of 3: 860 ms per loop
```

А испытания того же самого сценария с помощью утилиты time операционной системы UNIX дали следующие результаты:

```
jmjones@dink:~/code$ time python
re_loop_compile.py LINES:: 500000 MATCHES:: 242
real 0m0.996s
user 0m0.836s
sys 0m0.154s
```

Версия со скомпилированным регулярным выражением одержала чистую победу. Время работы этой версии оказалось в два раза меньше как по данным утилиты UNIX time, так и по данным функции timeit оболочки IPython. Поэтому мы настоятельно рекомендуем взять в привычку использовать объекты скомпилированных регулярных выражений.
Как уже говорилось ранее в этой главе, для определения строк, в которых не интерпретируются экранированные последовательности, можно использовать сырые (неформатированные) строки. В примере 3.17 показано применение неформатированных строк для использования в регулярных выражениях.

```
Пример 3.17. Неформатированные строки и регулярные выражения
In [1]: import re
```
```
In [2]: raw_pattern = r'\b[az]+\b'
In [3]: non_raw_pattern = '\b[az]+\b'
```
```
In [4]: some_string = 'a few little words'
```

Встроенные компоненты Python и модули **125**

```
In [5]: re.findall(raw_pattern, some_string)
Out[5]: ['a', 'few', 'little', 'words']
```
```
In [6]: re.findall(non_raw_pattern, some_string)
Out[6]: []
```
```
Шаблонный символ \b в регулярных выражениях соответствует гра
нице слова. То есть, как в случае применения сырой строки, так
и в случае применения обычной строки, мы предполагаем отыскать
отдельные слова, состоящие из символов нижнего регистра. Обратите
внимание, что при использовании raw_pattern были обнаружены от
дельные слова в some_string, а при использовании non_raw_pattern вооб
ще ничего не было найдено. В строке raw_pattern комбинация \b интер
претируется как два отдельных символа, в то время как в строке
non_raw_pattern она интерпретируется как символ забоя (backspace).
В результате функция findall() сумела отыскать отдельные слова с по
мощью неформатированной строки шаблона. Однако при использова
нии шаблона в виде обычной строки функция findall() не отыскала ни
одного символа забоя (backspace).
Чтобы с помощью шаблона non_raw_pattern можно было отыскать соот
ветствие в строке, необходимо окружить требуемое слово символами
\b, как показано ниже:
```
```
In [7]: some_other_string = 'a few \blittle\b words'
In [8]: re.findall(non_raw_pattern, some_other_string)
Out[8]: ['\x08little\x08']
```

Обратите внимание на шестнадцатеричную форму записи символа
"\x08" в соответствии, найденном функцией findall(). Эта шестнадца
теричная форма записи соответствует символам забоя (backspace), ко
торые были добавлены с помощью экранированной последовательно
сти \b.
Как видите, неформатированные строки могут пригодиться, когда
предполагается использовать специальные последовательности, такие
как "\b", обозначающую границу слова, "\d", обозначающую цифру,
или "\w", обозначающую алфавитноцифровой символ. Полный пере
чень специальных последовательностей, начинающихся с символа об
ратного слеша, вы найдете в разделе «Regular Expression Syntax»
в справочнике «Python Library Reference», http://docs.python.org/lib/
re>syntax.html.
Примеры с 3.14 по 3.17 были очень простыми. В них во всех использова
лись регулярные выражения и различные методы, применяемые к ним.
Иногда такого ограниченного использования регулярных выражений
вполне достаточно. Иногда бывает необходимо нечто более мощное,
чем имеется в библиотеке регулярных выражений.
К основным методам (или функциям) регулярных выражений, которые
используются наиболее часто, относятся findall(), finditer(), match()
иsearch(). Вам также могут потребоваться методы split() и sub(), но,
вероятно, не так часто, как другие методы.
Метод findall() отыскивает все вхождения указанного шаблона в стро
ке. Если метод findall() найдет соответствия шаблону, тип возвращае
мой структуры данных будет зависеть от наличия групп в шаблоне.
Краткое напоминание: группировка в регулярных выражениях
позволяет указывать текст внутри регулярного выражения, ко
торый следует извлечь из результата. За дополнительной ин
формацией обращайтесь к разделу «Common Metacharacters and
Fields» в книге Фридла (Friedl) «Mastering Regular Expres
sions»^1 или в Интернете по адресу: http://safari.oreilly.com/0596528124/regex3-CHP-3-SECT-5?imagepage=137.
Если в регулярном выражении отсутствуют группы, а совпадение найдено, тогда findall() вернет список строк. Например:

```
In [1]: import re
In [2]: re_obj = re.compile(r'\bt.*?e\b')
In [3]: re_obj.findall("time tame tune tint tire")
Out[3]: ['time', 'tame', 'tune', 'tint tire']
```

В этом шаблоне отсутствуют группы, поэтому findall() возвращает список строк. Здесь можно наблюдать интересный побочный эффект –
последний элемент списка содержит два слова, tint и tire. Используе
мое здесь регулярное выражение соответствует словам, начинающимся
с символа «t» и заканчивающимся символом «e». Но часть выражения
.*? соответствует любым символам, включая пробелы. Метод findall()
отыскал все, что предполагалось. Он отыскал слово, начинающееся
с символа «t» (tint), и продолжил просмотр строки, пока не обнаружил
слово, завершающееся символом «e» (tire). Поэтому соответствие «tint
tire» вполне согласуется с шаблоном. Чтобы исключить пробел, можно
было бы использовать регулярное выражение r'\bt\w*e\b':
In [4]: re_obj = re.compile(r'\bt\w*e\b')
```
```
In [5]: re_obj.findall("time tame tune tint tire")
Out[5]: ['time', 'tame', 'tune', 'tire']
```
```
Второй тип структуры данных, который может быть получен, – это
список кортежей. Если группы присутствуют в выражении и было
найдено совпадение, то findall() вернет список кортежей. Подобный
шаблон и строка показаны в примере 3.18.

```
(^1) Джеффри Фридл «Регулярные выражения», 3е издание. – Пер. с англ. –
СПб.: Символплюс, 2008. Глава 3. Раздел «Стандартные метасимволы
и возможности». – _Прим. перев._

Пример 3.18. Простая группировка и метод findall()
In [1]: import re
```
```
In [2]: re_obj = re.compile(r"""(A\W+\b(big|small)\b\W+\b
...: (brown|purple)\b\W+\b(cow|dog)\b\W+\b(ran|jumped)\b\W+\b
...: (to|down)\b\W+\b(the)\b\W+\b(street|moon).*?\.)""",
...: re.VERBOSE)
```
```
In [3]: re_obj.findall('A big brown dog ran down the street. \
...: A small purple cow jumped to the moon.')
```
```
Out[3]:
[('A big brown dog ran down the street.',
'big',
'brown',
'dog',
'ran',
'down',
'the',
'street'),
('A small purple cow jumped to the moon.',
'small',
'purple',
'cow',
'jumped',
'to',
'the',
'moon')]
```

Несмотря на свою простоту, этот пример демонстрирует ряд важных
моментов. Вопервых, обратите внимание, что этот простой шаблон не
лепо длинен и содержит массу неалфавитноцифровых символов, от
которых начинает рябить в глазах, если смотреть слишком долго. Это
обычная вещь для многих регулярных выражений. Затем, обратите
внимание, что шаблон содержит явные вложенные группы. Объемлю
щая группа будет соответствовать любому тексту, начинающемуся
с символа «A» и заканчивающемуся точкой. Символы между началь
ным символом «A» и завершающей точкой образуют вложенные груп
пы, которые должны соответствовать словам «big» или «small»,
«brown» или «purple» и так далее. Далее, возвращаемое значение мето
да findall() представляет собой список кортежей. Элементами этих
кортежей являются группы, которые были определены в регулярном
выражении. Первый элемент кортежа – все предложение, потому что
оно соответствует наибольшей, объемлющей группе. Последующие
элементы кортежа соответствуют каждой из подгрупп. Наконец, обра
тите внимание на последний аргумент в вызове метода re.compile() –
re.VERBOSE. Это позволило нам записать регулярное выражение в много
строчном режиме, то есть мы смогли расположить регулярное выраже
ние в нескольких строках, не оказывая влияния на поиск соответст
вий. Пробел, оказавшийся за пределами группировки, был проигнорирован. Хотя мы и не продемонстрировали здесь такую возможность,
тем не менее, многострочный режим позволяет вставлять коммента
рии в конец каждой строки регулярного выражения, чтобы описать,
что делает та или иная его часть. Одна из основных сложностей, свя
занных с регулярными выражениями, состоит в том, что описание
шаблона часто бывает очень длинным и трудным для чтения. Цель
re.VERBOSE состоит в том, чтобы упростить написание регулярных выра
жений, следовательно, это ценный инструмент, облегчающий сопрово
ждение программного кода, содержащего регулярные выражения.
Метод finditer() является разновидностью метода findall(). Вместо
того чтобы возвращать список кортежей, как это делает метод find
all(), finditer() возвращает итератор, как это следует из имени мето
да. Каждый элемент итератора – это объект найденного совпадения,
который мы обсудим далее в этой главе. Пример 3.19 реализует тот же
простой пример, только в нем вместо метода findall() используется
метод finditer().
_Пример 3.19. Пример использования метода finditer()_
```
In [4]: re_iter = re_obj.finditer('A big brown dog ran down the street. \
...: A small purple cow jumped to the moon.')
In [5]: re_iter
```
```
Out[5]: <callableiterator object at 0xa17ad0>
In [6]: for item in re_iter:
...: print item
...: print item.groups()
...:
<_sre.SRE_Match object at 0x9ff858>
('A big brown dog ran down the street.', 'big', 'brown', 'dog', 'ran',
'down', 'the', 'street')
<_sre.SRE_Match object at 0x9ff940>
('A small purple cow jumped to the moon.', 'small', 'purple', 'cow',
'jumped', 'to', 'the', 'moon')
```

Если прежде вы никогда не сталкивались с итераторами, вы можете
представлять их себе как списки, которые создаются в тот момент, ко
гда они необходимы. Один из недостатков такого определения состоит
в том, что вы не можете обратиться к определенному элементу итера
тора по его индексу, как, например, к элементу списка some_list[3].
Вследствие этого ограничения вы не можете получить срез итератора,
как, например, в случае списка some_list[2:6]. Тем не менее, независи
мо от этих ограничений итераторы представляют собой легкое и мощ
ное средство, особенно когда необходимо выполнить итерации через
некоторую последовательность, потому что при этом последователь
ность не загружается целиком в память, а элементы ее возвращаются
по требованию. Это позволяет итераторам занимать меньший объем памяти, чем соответствующие им списки. Кроме того, доступ к эле
ментам последовательности производится быстрее.
Еще одно преимущество метода finditer() перед findall() состоит в том,
что каждый элемент, возвращаемый методом finditer(), – это объект
match, а не простой список строк или список кортежей, соответствую
щих найденному тексту.
Методы match() и search() обеспечивают похожие функциональные
возможности. Оба метода применяют регулярное выражение к строке;
оба указывают, с какой позиции начать и в какой закончить поиск по
шаблону; оба возвращают объект match для первого найденного соот
ветствия заданному шаблону. Разница между этими двумя методами
состоит в том, что метод match() пытается отыскать совпадение только
от начала строки или от указанного места в строке, не переходя в дру
гие позиции в строке, а метод search() будет пытаться отыскать соот
ветствие шаблону в любом месте строки или между начальной и конеч
ной позицией, которые вы укажете, как показано в примере 3.20.

```
Пример 3.20. Сравнение методов match() и search()
In [1]: import re
```
```
In [2]: re_obj = re.compile('FOO')
In [3]: search_string = ' FOO'
```
```
In [4]: re_obj.search(search_string)
Out[4]: <_sre.SRE_Match object at 0xa22f38>
```
```
In [5]: re_obj.match(search_string)
In [6]:
```
```
Даже при том, что в строке search_string имеется соответствие шабло
ну, поиск по которому производит метод match(), тем не менее, поиск
завершается неудачей, потому что подстрока в search_string, соответ
ствующая шаблону, находится не в начале строки. Метод search(), на
против, нашел соответствие и вернул объект match.
Методы search() и match() принимают параметры, определяющие на
чальную и конечную позицию поиска в строке, как показано в приме
ре 3.21.
```
```
Пример 3.21. Параметры начала и конца поиска в методах search()
и match()
In [6]: re_obj.search(search_string, pos=1)
Out[6]: <_sre.SRE_Match object at 0xabe030>
```
```
In [7]: re_obj.match(search_string, pos=1)
Out[7]: <_sre.SRE_Match object at 0xabe098>
In [8]: re_obj.search(search_string, pos=1, endpos=3)
In [9]: re_obj.match(search_string, pos=1, endpos=3)
In [10]:
```

Параметр pos – это индекс, определяющий место в строке, откуда дол
жен начинаться поиск по шаблону. В данном примере передача пара
метра pos методу search() не повлияла на результат, но передача пара
метра pos методу match()привела к тому, что он нашел соответствие
шаблону, хотя без параметра pos соответствие обнаружить не удалось.
Установка параметра endpos в значение 3 привела к тому, что оба
метода – и match(), и search() не нашли соответствие, потому что соот
ветствие шаблону включает символ в третьей позиции.
Методы findall() и finditer() отвечают на вопрос: «чему соответствует
мой шаблон?», а главный вопрос, на который отвечают методы search()
и match(): «имеется ли соответствие моему шаблону?». Методы search()
и match() отвечают также на вопрос: «каково первое соответствие мо
ему шаблону?», но часто единственное, что требуется узнать, это:
«имеется ли соответствие моему шаблону?». Например, предположим,
что необходимо написать сценарий, который должен читать строки из
файла журнала и обертывать каждую строку в теги HTML, чтобы обес
печить удобочитаемое отображение. При этом хотелось бы, чтобы все
строки, содержащие текст «ERROR», отображались красным цветом,
для чего можно было бы выполнить цикл по всем строкам в файле, про
верить их с помощью регулярного выражения и, если метод search()
обнаруживает текст «ERROR», можно было бы определить такой фор
мат строки, чтобы она отображалась красным цветом.
Методы search() и match() удобны не только тем, что они определяют
наличие соответствия, но и тем, что они возвращают объект match. Объ
екты match содержат различные методы извлечения данных, которые
могут пригодиться при обходе полученных результатов. Особый инте
рес представляют такие методы объекта match, как start(), end(),
span(), groups() и groupdict().
Методы start(), end() и span() определяют позиции в строке поиска,
где совпадение с шаблоном начинается и где заканчивается. Метод
start() возвращает целое число, определяющее позицию в строке на
чала найденного соответствия. Метод end() возвращает целое число,
определяющее позицию в строке конца найденного соответствия.
Аметод span() возвращает кортеж, содержащий позицию начала и кон
ца совпадения.
Метод groups() возвращает кортеж совпадения, каждый элемент кото
рого соответствует группе, имеющейся в шаблоне. Этот кортеж напо
минает кортежи в списке, возвращаемом методом findall(). Метод
groupdict() возвращает словарь именованных групп, ключи которого
соответствуют именам групп, присутствующих непосредственно в ре
гулярном выражении, например: (?P<group_name>pattern).
Подводя итоги, можно сказать – чтобы эффективно использовать регу
лярные выражения, следует взять в привычку использовать объекты
скомпилированных регулярных выражений. Используйте методы
findall() и finditer(), когда необходимо получить части текста, соот
ветствующие шаблону. Запомните, что метод finditer() обладает более
высокой гибкостью, чем findall(), потому что возвращает итератор по
объектам match. Более подробный обзор библиотеки регулярных выра
жений вы найдете в главе 9 книги «Python in a Nutshell» Алекса Мар
телли (Alex Martelli) (O’Reilly). Чтобы познакомиться с регулярными
выражениями в действии, обращайтесь к книге «Data Crunching» Гре
га Уилсона (Greg Wilson) (The Pragmatic Bookshelf).

```
**Работа с конфигурационным файлом Apache**

```
Теперь, когда вы получили представление о работе с регулярными вы
ражениями в языке Python, попробуем поработать с конфигурацион
ным файлом вебсервера Apache:
NameVirtualHost 127.0.0.1:80
<VirtualHost localhost:80>
DocumentRoot /var/www/
<Directory />
Options FollowSymLinks
AllowOverride None
</Directory>
ErrorLog /var/log/apache2/error.log
LogLevel warn
CustomLog /var/log/apache2/access.log combined
ServerSignature On
</VirtualHost>
<VirtualHost local2:80>
DocumentRoot /var/www2/
<Directory />
Options FollowSymLinks
AllowOverride None
</Directory>
ErrorLog /var/log/apache2/error2.log
LogLevel warn
CustomLog /var/log/apache2/access2.log combined
ServerSignature On
</VirtualHost>
```
```
Это слегка измененный конфигурационный файл Apache в Ubuntu.
Мы создали именованные виртуальные хосты для некоторых своих
нужд. Мы также добавили в файл /etc/hosts следующую строку:
127.0.0.1 local2
```
```
Она позволяет указать броузеру, что серверу с именем local2 соответст
вует IPадрес 127.0.01, то есть локальный компьютер. И в чем же здесь
смысл? Если в броузере ввести адрес http://local2 , он передаст серверу
указанное имя в заголовке HTTP. Ниже приводится HTTPзапрос, направленный серверу local2:
```
```
GET / HTTP/1.1
Host: local2
UserAgent: Mozilla/5.0 (X11; U; Linux x86_64; enUS; rv:1.8.1.13)
Gecko/20080325 Ubuntu/7.10 (gutsy) Firefox/2.0.0.13
Accept: text/xml,application/xml,application/xhtml+xml,text/html
AcceptLanguage: enus,en;q=0.5
AcceptEncoding: gzip,deflate
AcceptCharset: ISO88591,utf8;q=0.7,*;q=0.7
KeepAlive: 300
Connection: keepalive
IfModifiedSince: Tue, 15 Apr 2008 17:25:24 GMT
IfNoneMatch: "ac5ea5344aecaf804900"
CacheControl: maxage=0
```
```
Обратите внимание, что запрос начинается с заголовка Host:. Когда
вебсервер Apache получит такой запрос, он направит его виртуально
му хосту с именем local2.
Теперь все, что нам предстоит сделать, – это написать сценарий, кото
рый анализирует конфигурационный файл вебсервера Apache, такой,
как показано выше, отыскивает раздел VirtualHost и замещает значе
ние параметра DocumentRoot в этом разделе. Сам сценарий приводится
ниже:

```
#!/usr/bin/env python

from cStringIO import StringIO
import re

vhost_start = re.compile(r'<VirtualHost\s+(.*?)>')
vhost_end = re.compile(r'</VirtualHost')
docroot_re = re.compile(r'(DocumentRoot\s+)(\S+)')
def replace_docroot(conf_string, vhost, new_docroot):

'''отыскивает в файле httpd.conf строки DocumentRoot, соответствующие
указанному vhost, и замещает их новыми строками new_docroot
'''

conf_file = StringIO(conf_string)
in_vhost = False
curr_vhost = None
for line in conf_file:
vhost_start_match = vhost_start.search(line)
if vhost_start_match:
curr_vhost = vhost_start_match.groups()[0]
in_vhost = True
if in_vhost and (curr_vhost == vhost):
docroot_match = docroot_re.search(line)
if docroot_match:
sub_line = docroot_re.sub(r'\1%s' % new_docroot, line)
line = sub_line
vhost_end_match = vhost_end.search(line)
if vhost_end_match:
in_vhost = False
yield line
if __name__ == '__main__':
import sys
conf_file = sys.argv[1]
vhost = sys.argv[2]
docroot = sys.argv[3]
conf_string = open(conf_file).read()
for line in replace_docroot(conf_string, vhost, docroot):
print line,
```

Этот сценарий сначала создает три объекта скомпилированных регулярных выражений: один соответствует открывающему тегу Virtual
Host, один – закрывающему тегу VirtualHost и один – строке с параметром DocumentRoot. Мы также создали функцию, которая выполняет эту
утомительную работу. Функция называется replace_docroot и принима
ет в качестве аргументов тело конфигурационного файла в виде строки,
имя раздела VirtualHost, который требуется отыскать, и значение пара
метра DocumentRoot, которое требуется назначить для данного виртуаль
ного хоста. Функция устанавливает признак состояния, который ука
зывает, находится ли текущая анализируемая строка в разделе Virtu
alHost. Кроме того, сохраняется имя текущего виртуального хоста. При
анализе строк в разделе VirtualHost эта функция пытается отыскать
строку с параметром DocumentRoot и изменяет его значение. Поскольку
функция replace_docroot() выполняет итерации по каждой строке в кон
фигурационном файле, она возвращает либо неизмененную исходную
строку, либо измененную строку с параметром DocumentRoot.
Мы создали простой интерфейс командной строки к этой функции.
В нем не предусматривается использование ничего особенного, такого
как функция optparse, и не выполняется проверка на количество вход
ных аргументов, но он работает. Теперь попробуем применить этот
сценарий к конфигурационному файлу вебсервера Apache, представ
ленному выше, и изменим настройки VirtualHost local2:80 так, чтобы
он использовал каталог /tmp в качестве корневого каталога докумен
тов. Предусмотренный нами интерфейс командной строки просто вы
водит строки, возвращаемые функцией replace_docroot(), а не изменя
ет сам файл:

```
jmjones@dinkgutsy:code$ python apache_conf_docroot_replace.py
/etc/apache2/sitesavailable/psa
local2:80 /tmp
NameVirtualHost 127.0.0.1:80
<VirtualHost localhost:80>
DocumentRoot /var/www/
<Directory />
Options FollowSymLinks
AllowOverride None
</Directory>
ErrorLog /var/log/apache2/error.log
LogLevel warn
CustomLog /var/log/apache2/access.log combined
ServerSignature On
</VirtualHost>
<VirtualHost local2:80>
DocumentRoot /tmp
<Directory />
Options FollowSymLinks
AllowOverride None
</Directory>
ErrorLog /var/log/apache2/error2.log
LogLevel warn
CustomLog /var/log/apache2/access2.log combined
ServerSignature On
</VirtualHost>
```

Единственная строка, которая изменилась, – это строка с параметром DocumentRoot в разделе VirtualHost local2:80. Ниже приводятся различия, полученные после того, как вывод сценария был перенаправлен в файл:

```
jmjones@dinkgutsy:code$ diff apache_conf.diff /etc/apache2/sitesavailable/psa
20c20
< DocumentRoot /tmp

> DocumentRoot /var/www2/
```

Изменение значения параметра DocumentRoot в конфигурационном файле веб-сервера Apache – это достаточно простая задача, но когда это
приходится делать достаточно часто или когда имеется множество вир
туальных хостов, которые приходится изменять, тогда есть смысл на
писать сценарий, подобный тому, что был показан выше. Не менее про
сто можно было бы изменить сценарий так, чтобы он комментировал
требуемый раздел VirtualHost, изменял значение параметра LogLevel
или изменял имя файла журнала для указанного виртуального хоста.

### Работа с файлами

Овладение приемами работы с файлами является ключом к обработке
текстовых данных. Зачастую текст, который требуется обработать, на
ходится в текстовом файле, например, в файле журнала, в конфигура
ционном файле или в файле с данными приложения. Нередко резуль
таты анализа данных требуется сохранить в виде файла отчета или
просто записать их в текстовый файл для последующего изучения.
К счастью, в языке Python имеется простой в использовании тип объ
ектов с именем file, который в состоянии помочь выполнить все необ
ходимые действия с файлами.

Создание файлов
Это может показаться странным, но чтобы прочитать содержимое су
ществующего файла, необходимо создать новый объект типа file. Од
нако не надо путать операцию создания нового объекта с созданием но
вого файла. Чтобы выполнить операцию записи в файл, необходимо
создать новый объект file и, возможно, создать новый файл на диске,
поэтому в такой ситуации создание объекта file интуитивно более по
нятно, чем создание объекта file для чтения. Создавать объект file
обязательно, потому что он необходим для организации взаимодейст
вий с файлом на диске.
Для создания объекта file используется встроенная функция open().
Ниже приводится фрагмент программного кода, который открывает
файл для чтения:
```
```
In [1]: infile = open("foo.txt", "r")
In [2]: print infile.read()
Some Random
Lines
Of
Text.
```
```
Функция open() – это встроенная функция, поэтому нет никакой необ
ходимости импортировать какойлибо модуль. Функция open() прини
мает три аргумента: имя файла, режим открытия и размер буфера.
Обязательным является только первый аргумент – имя файла. Наибо
лее часто используются режимы: «r» (режим чтения, используется по
умолчанию), «w» (режим записи) и «a» (режим записи в конец файла).
Вместе с этими тремя спецификаторами режимов может использо
ваться дополнительный спецификатор «b», определяющий двоичный
режим доступа. Третий аргумент, размер буфера, определяет способ
буферизации операций над файлом.
В предыдущем примере было предписано открыть файл foo.txt в режи
ме для чтения и сохранить ссылку на созданный объект файла в пере
менной infile. После получения ссылки на объект в переменной infile
появилась возможность обратиться к методу read() этого объекта, ко
торый читает содержимое файла целиком.
Создание объекта типа file для записи в файл выполняется почти так
же, как создание объекта для чтения из файла. Просто вместо специ
фикатора режима "r" следует использовать спецификатор "w":
```
```
In [1]: outputfile = open("foo_out.txt", "w")
In [2]: outputfile.write("This is\nSome\nRandom\nOutput Text\n")
```
```
In [3]: outputfile.close()
```
```
В этом примере предписывается открыть файл foo_out.txt в режиме
для записи и сохранить ссылку на вновь созданный объект типа file
в переменной outputfile. После получения ссылки на объект мы смог
ли обратиться к методу write(), чтобы записать в файл некоторый
текст и закрыть его вызовом метода close().
Несмотря на всю простоту создания файлов, у вас может появиться
желание создавать файлы способом, более устойчивым к появлению
ошибок. Считается хорошей практикой обертывать вызов функции
open() конструкцией try/finally, особенно, когда вслед за этим вызы
вается метод write(). Ниже приводится пример реализации записи
в файл с использованием инструкции try/finally:
In [1]: try:
...: f = open('writeable.txt', 'w')
...: f.write('quick line here\n')
...: finally:
...: f.close()
```
```
При такой реализации записи файлов метод close() вызывается, когда
гденибудь в блоке try возникает исключение. В действительности
этот подход позволяет методу close() закрыть файл, даже когда в бло
ке try не возникает исключение. Блок finally выполняется после за
вершения работы блока try всегда, независимо от того, возникло ис
ключение или нет.
В версии Python 2.5 появилась новая идиома – инструкция with, ко
торая позволяет использовать менеджер контекста. Менеджер
контекста – это просто объект с методами __enter__() и __exit__(). Ко
гда объект создается с помощью инструкции with, вызывается метод
__enter__() менеджера контекста. Когда выполнение блока with завер
шается, вызывается метод __exit__() менеджера контекста, даже если
возникло исключение. Объекты типа file имеют методы __enter__() и
__exit__(). В методе __exit__() объекта типа file вызывается метод
close(). Ниже приводится пример использования инструкции with:
In [1]: from __future__ import with_statement
```
```
In [2]: with open('writeable.txt', 'w') as f:
...: f.write('this is a writeable file\n')
...:
...:
```
```
Хотя в этом фрагменте отсутствует вызов метода close() объекта f, ме
неджер контекста закроет файл после выхода из блока with:
```
```
In [3]: f
Out[3]: <closed file 'writeable.txt', mode 'w' at 0x1382770>
```
```
In [4]: f.write("this won't work")
```
```
ValueError Traceback (most recent call last)
/Users/jmjones/<ipython console> in <module>()
ValueError: I/O operation on closed file
(ValueError: операция вводавывода с закрытым файлом)
```
```
Как и следовало ожидать, файл был закрыт. Хотя это хорошая прак
тика – обрабатывать все возможные исключения и гарантировать за
крытие файла, когда это необходимо, но ради простоты и ясности мы
не будем предусматривать такую обработку во всех примерах.
Полный перечень методов объектов типа file вы найдете в разделе «File
Objects» в справочнике «Python Library Reference» по адресу: http://
docs.python.org/lib/bltin>file>objects.html.
```
```
Чтение из файлов
Как только появляется объект файла, открытого для чтения с флагом r,
вы получаете возможность использовать три обычных метода объекта
file, удобных для получения данных, содержащихся в файле: read(),
readline() и readlines(). Метод read() читает, что не удивительно, дан
ные из объекта открытого файла и возвращает эти данные в виде стро
ки. Метод read() принимает необязательный аргумент, который ука
зывает число байтов, которые требуется прочитать из файла. Если этот
аргумент отсутствует, метод read() попытается прочитать содержимое
файла целиком. Если размер файла меньше, чем величина аргумента,
метод read() будет читать данные, пока не встретит конец файла и вер
нет то, что удалось прочитать.
Допустим, что имеется следующий файл:
jmjones@dink:~/some_random_directory$ cat foo.txt Some Random
Lines
Of
Text.
```
```
Тогда метод read() будет работать с этим файлом, как показано ниже:
```
```
In [1]: f = open("foo.txt", "r")
In [2]: f.read()
Out[2]: 'Some Random\n Lines\nOf \n Text.\n'
```
```
Обратите внимание, что символы новой строки отображаются как по
следовательности \n – это стандартный способ обозначения символа
новой строки.
Если бы требовалось прочитать только первые 5 байтов, сделать это
можно было бы следующим способом:
```
```
In [1]: f = open("foo.txt", "r")
In [2]: f.read(5)
Out[2]: 'Some '
```
```
Следующий метод, позволяющий получать текст из файла, – метод
readline(). Метод readline() читает текст из файла по одной строке за раз. Этот метод принимает один необязательный аргумент: size. Он
определяет максимальное число байтов, которые метод readline() бу
дет читать из файла, прежде чем вернуть строку, независимо от того,
был достигнут конец строки или нет. Поэтому в следующем примере
программа читает первую строку из текста из файла foo.txt , затем чи
тает первые 7 байтов текста из второй строки, а после этого считывает
остаток второй строки:
In [1]: f = open("foo.txt", "r")
```
```
In [2]: f.readline()
Out[2]: 'Some Random\n'
```
```
In [3]: f.readline(7)
Out[3]: ' Lin'
```
```
In [4]: f.readline()
Out[4]: 'es\n'
```
```
Последний метод получения текста из объектов типа file, который мы
рассмотрим, – это метод readlines(). Имя readlines() – это не опечатка
и не ошибка, закравшаяся при копировании имени метода из преды
дущего примера. Метод readlines() читает сразу все строки из файла.
Впрочем, это почти правда. Метод readlines() имеет аргумент sizehint,
определяющий максимальное число байтов, которые требуется прочи
тать. В следующем примере мы создали файл biglines.txt , содержащий
10 000 строк, в каждой из которых по 80 символов. После этого мы от
крыли файл, указали, что нам требуется прочитать из файла N первых
строк, общий объем которых составляет примерно 1024 байта, опреде
лили число прочитанных строк и байтов и затем прочитали оставшую
ся часть файла:
```
```
In [1]: f = open("biglines.txt", "r")
In [2]: lines = f.readlines(1024)
```
```
In [3]: len(lines)
Out[3]: 102
```
```
In [4]: len("".join(lines))
Out[4]: 8262
```
```
In [5]: lines = f.readlines()
In [6]: len(lines)
Out[6]: 9898
In [7]: len("".join(lines))
Out[7]: 801738
```
```
Команда в строке [3] показывает, что было прочитано 102 строки, а ко
манда в строке [4] показала, что общее число прочитанных байтов со
ставило 8262. Как так вышло, что мы указали «примерное» число бай
тов, которые требуется прочитать, равное 1024, а получили 8262? Оно было округлено до размера внутреннего буфера, который равен при
мерно 8 килобайтам. Суть в том, что аргумент sizehint не всегда оказы
вает влияние так, как вам того хотелось бы, и об этом следует помнить.
```
```
Запись в файлы
Иногда возникает потребность не только читать данные из файлов, но
также создавать собственные файлы и записывать в них данные. Объ
екты типа file обладают двумя основными методами, которые позво
лят вам записывать данные в файлы. Первый метод, который уже де
монстрировался выше, – это метод write(). Метод write() принимает
один аргумент: строку, которую требуется записать в файл. В следую
щем примере демонстрируется запись данных в файл:
```
```
In [1]: f = open("some_writable_file.txt", "w")
In [2]: f.write("Test\nFile\n")
```
```
In [3]: f.close()
In [4]: g = open("some_writable_file.txt", "r")
```
```
In [5]: g.read()
Out[5]: 'Test\nFile\n'
```
```
Команда [1] открывает файл с флагом режима w, то есть в режиме для
записи. Команда [2] записывает в файл две строки. Команда [4] создает
новый объект файла и присваивает ссылку на него другой переменной,
с именем g, чтобы избежать путаницы, хотя вполне возможно было ис
пользовать и переменную f. И команда [5] показывает, что метод read()
возвращает те же самые данные, которые были записаны в файл.
Следующий основной метод записи данных в файл – это метод write
lines(). Метод writelines() принимает один обязательный параметр:
последовательность, которая должна быть записана в файл. Допуска
ется использовать последовательности любого итерируемого типа, та
кие как списки, кортежи, генераторы списков (которые можно счи
тать списками) или генераторы. Ниже приводится пример вызова ме
тода writelines(), который получает данные для записи в файл от вы
ражениягенератора:
```
```
In [1]: f = open("writelines_outfile.txt", "w")
In [2]: f.writelines("%s\n" % i for i in range(10))
```
```
In [3]: f.close()
In [4]: g = open("writelines_outfile.txt", "r")
```
```
In [5]: g.read()
Out[5]: '0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n'
```
```
И еще один пример функциигенератора, которая может использо
ваться для записи данных в файл (этот пример функционально эквивалентен предыдущему, но для его реализации потребовалось написать
больше программного кода):
```
```
In [1]: def myRange(r):
...: i = 0
...: while i < r:
...: yield "%s\n" % i
...: i += 1
...:
...:
In [2]: f = open("writelines_generator_function_outfile", "w")
```
```
In [3]: f.writelines(myRange(10))
In [4]: f.close()
```
```
In [5]: g = open("writelines_generator_function_outfile", "r")
In [6]: g.read()
Out[6]: '0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n'
```
```
Следует заметить, что метод writelines() не записывает символы новой
строки (\n) автоматически – вы сами должны включать их в последо
вательность, предназначенную для записи в файл. Кроме того, следует
знать, что этот метод можно использовать не только для построчной
записи данных в файл. Возможно, этому методу лучше подошло бы на
звание writeiter().Так случилось, что в предыдущих примерах мы за
писывали текст, который уже содержал символы новой строки, но нет
никаких причин, которые требовали бы их наличия.
```
```
Дополнительные ресурсы
За дополнительной информацией об объектах типа file обращайтесь
к главе 7 в книге «Learning Python» Дэвида Ашера (David Ascher)
и Марка Лутца (Mark Lutz) (O’Reilly) (имеется также в Интернете по
адресу: http://safari.oreilly.com/0596002815/lpython2>chp>7>sect>2 ) или
к разделу «File Objects» в справочнике «Python Library Reference»
(доступному в Интернете по адресу: http://docs.python.org/lib/bltin>fi>
le>objects.html ).
За дополнительной информацией о выраженияхгенераторах обра
щайтесь к разделу «generator expressions» в справочнике «Python
Language Reference» (доступному в Интернете по адресу: http://
docs.python.org/ref/genexpr.html ). За дополнительной информацией об
инструкции yield обращайтесь к разделу «yield statement» в справоч
нике «Python Language Reference» (доступному в Интернете по адре
су: http://docs.python.org/ref/yield.html ).

### Стандартный ввод и вывод


Операции чтения текста из потока стандартного ввода процесса и за
писи в поток стандартного вывода процесса знакомы большинству сис
темных администраторов. Стандартный ввод – это обычные данные,
поступающие в программу, которые программа может читать в ходе
своей работы. Стандартный вывод – это данные, которые программа
выводит в процессе выполнения. Преимущество использования стан
дартного ввода и вывода состоит в том, что это позволяет объединять
команды в конвейеры с другими утилитами.
Стандартная библиотека языка Python содержит встроенный модуль
с именем sys, который обеспечивает простые способы доступа к стан
дартному вводу и стандартному выводу. Стандартная библиотека пре
доставляет доступ к стандартному вводу и выводу как к объектам типа
file, несмотря на то, что они не имеют никакого отношения к файлам
на диске. А так как эти объекты напоминают объекты типа file, для
работы с ними можно использовать те же самые методы, которые ис
пользуются при работе с файлами. Вы можете работать с ними, как ес
ли бы это были файлы на диске, и обращаться к соответствующим ме
тодам для выполнения требуемых операций.
После импортирования модуля sys стандартный ввод становится дос
тупен в виде атрибута stdin этого модуля (sys.stdin). Атрибут sys.stdin –
это доступный для чтения объект типа file. Обратите внимание, что
произойдет, если создать «настоящий» объект типа file, открыв файл
с именем foo.txt на диске, и затем сравнить его с объектом sys.stdin:
In [1]: import sys
```
```
In [2]: f = open("foo.txt", "r")
In [3]: sys.stdin
```
```
Out[3]: <open file '<stdin>', mode 'r' at 0x14020>
In [4]: f
Out[4]: <open file 'foo.txt', mode 'r' at 0x12179b0>
In [5]: type(sys.stdin) == type(f)
Out[5]: True
```
```
Интерпретатор воспринимает их как объекты одного и того же типа,
поэтому они обладают одними и теми же методами. Несмотря на то,
что с технической точки зрения эти объекты принадлежат одному
и тому же типу и обладают одними и теми же методами, поведение не
которые методов будет отличаться. Например, методы sys.stdin.seek()
и sys.stdin.tell() доступны, но при обращении к ним возбуждается ис
ключение (в данном случае исключение IOError). Однако во всем ос
тальном стандартный ввод и вывод напоминают объекты типа file,
и вы в значительной степени можете воспринимать их как обычные
дисковые файлы.
Доступ к sys.stdin в оболочке Python (или в оболочке IPython) прак
тически лишен всякого смысла. Попытка импортировать модуль sys
ивызвать метод sys.stdin.read() просто заблокирует работу оболочки.
Чтобы продемонстрировать вам, как работает объект sys.stdin, мы написали сценарий, который читает данные из sys.stdin и выводит обратно каждую прочитанную строку с соответствующим ей номером, как показано в примере 3.22.

```
Пример 3.22. Нумерация строк, читаемых методом sys.stdin.readline
#!/usr/bin/env python
import sys
counter = 1
while True:
line = sys.stdin.readline()
if not line:
break
print "%s: %s" % (counter, line)
counter += 1
```

В этом примере мы создали переменную counter, с помощью которой
сценарий следит за номерами введенных строк. Далее следует цикл
while, в теле которого выполняется чтение строк со стандартного вво
да. Для каждой строки вводится ее порядковый номер и ее содержи
мое. Так как программа все время находится в процессе выполнения
цикла, она обрабатывает все строки, которые ей поступают, даже если
они оказываются пустыми. Но даже пустые строки – не совсем пустые:
они содержат символ новой строки (\n). Когда сценарий обнаруживает
признак «конца файла», он прерывает работу цикла.
Ниже приводится результат объединения в конвейер команды who и пре
дыдущего сценария:
```
```
jmjones@dink:~/psabook/code$ who | ./sys_stdin_readline.py
1: jmjones console Jul 9 11:01
2: jmjones ttyp1 Jul 9 19:58
3: jmjones ttyp2 Jul 10 05:10
4: jmjones ttyp3 Jul 11 11:51
5: jmjones ttyp4 Jul 13 06:48
```
```
6: jmjones ttyp5 Jul 11 21:49
7: jmjones ttyp6 Jul 15 04:38
```
```
Достаточно интересно, что предыдущий пример можно реализовать
гораздо проще и короче, если использовать функцию enumerate(), как
показано в примере 3.23.
```
```
Пример 3.23. Пример использования метода sys.stdin.readline()
#!/usr/bin/env python
import sys
```
```
for i, line in enumerate(sys.stdin):
print "%s: %s" % (i, line)
Чтобы получить доступ к стандартному вводу, необходимо импортиро
вать модуль sys и затем воспользоваться атрибутом stdin. Точно так
же, чтобы получить доступ к стандартному выводу, необходимо им
портировать модуль sys и воспользоваться атрибутом stdout. Так же,
как sys.stdin представляет объект файла, доступного для чтения, объ
ект sys.stdout представляет объект файла, доступного для записи.
И так же, как sys.stdin имеет тот же тип, что и объект файла, доступ
ного для чтения, объект sys.stdout имеет тот же тип, что и объект фай
ла, доступного для записи:
In [1]: import sys
In [2]: f = open('foo.txt', 'w')
In [3]: sys.stdout
Out[3]: <open file '<stdout>', mode 'w' at 0x14068>
In [4]: f
Out[4]: <open file 'foo.txt', mode 'w' at 0x1217968>
In [5]: type(sys.stdout) == type(f)
Out[5]: True
```
```
Важное замечание: следующее утверждение не должно быть неожи
данным, поскольку любой файл, открытый для чтения, и любой файл,
открытый для записи, относятся к одному и тому же типу:
```
```
In [1]: readable_file = open('foo.txt', 'r')
In [2]: writable_file = open('foo_writable.txt', 'w')
In [3]: readable_file
Out[3]: <open file 'foo.txt', mode 'r' at 0x1243530>
In [4]: writable_file
Out[4]: <open file 'foo_writable.txt', mode 'w' at 0x1217968>
In [5]: type(readable_file) == type(writable_file)
Out[5]: True
```
```
Важно знать, что sys.stdout может в значительной степени рассматри
ваться как объект типа file, открытый для записи, точно так же как
иsys.stdin может рассматриваться как объект типа file, открытый
для чтения.

### StringIO


Как быть в случае, когда функция, выполняющая обработку текста,
предназначена для работы с объектом типа file, а данные, которые
предстоит обрабатывать, доступны в виде текстовой строки, а не в виде
объекта file? Самое простое решение состоит в том, чтобы воспользо
ваться модулем StringIO:

```
In [1]: from StringIO import StringIO
In [2]: file_like_string = StringIO("This is a\nmultiline string.\n
readline() should see\nmultiple lines of\ninput")
In [3]: file_like_string.readline()
Out[3]: 'This is a\n'
In [4]: file_like_string.readline()
Out[4]: 'multiline string.\n'
In [5]: file_like_string.readline()
Out[5]: 'readline() should see\n'
In [6]: file_like_string.readline()
Out[6]: 'multiple lines of\n'
In [7]: file_like_string.readline()
Out[7]: 'input'
```

В этом примере мы создали объект StringIO, конструктору которого пе
редается строка "This is a\nmultiline string. \nreadline() should see\nmul
tiple lines of\ninput". После этого появилась возможность вызывать
метод readline() объекта StringIO. Хотя в этом примере использовался
только метод readline(), это далеко не единственный доступный метод,
заимствованный у объектов типа file:

```
In [8]: dir(file_like_string)
Out[8]:
['__doc__',
'__init__',
'__iter__',
'__module__',
'buf',
'buflist',
'close',
'closed',
'flush',
'getvalue',
'isatty',
'len',
'next',
'pos',
'read',
'readline',
'readlines',
'seek',
'softspace',
'tell',
'truncate',
'write',
'writelines']
```

Конечно, между файлами и строками существуют различия, но ин
терфейс позволяет легко переходить между использованием файлов
и строк. Ниже приводится сравнение методов и атрибутов объектов
типа file и объектов типа StringIO:

```
In [9]: f = open("foo.txt", "r")
In [10]: from sets import Set
```
```
In [11]: sio_set = Set(dir(file_like_string))
In [12]: file_set = Set(dir(f))
```
```
In [13]: sio_set.difference(file_set)
Out[13]: Set(['__module__', 'buflist', 'pos', 'len', 'getvalue', 'buf'])
```
```
In [14]: file_set.difference(sio_set)
Out[14]: Set(['fileno', '__setattr__', '__reduce_ex__', '__new__',
'encoding',
'__getattribute__', '__str__', '__reduce__', '__class__', 'name',
'__delattr__', 'mode', '__repr__', 'xreadlines', '__hash__', 'readinto',
'newlines'])
```

Как видите, если возникнет необходимость работать со строкой как
с файлом, объект типа StringIO может оказать существенную помощь.


### urllib

Что, если интересующий вас файл находится гдето в сети? Или вы хо
тите использовать уже существующий фрагмент программного кода,
который предполагает работу с объектом file? Встроенный тип file не
умеет взаимодействовать с сетью, и в этой ситуации вам поможет мо
дуль urllib.
Если вам требуется только вызвать метод read() для получения дан
ных файла, расположенного на некотором вебсервере, для этого мож
но просто воспользоваться методом urllib.urlopen(), как показано
в простом примере ниже:
```
```
In [1]: import urllib
In [2]: url_file = urllib.urlopen("http://docs.python.org/lib/module
urllib.html")
In [3]: urllib_docs = url_file.read()
```
```
In [4]: url_file.close()
In [5]: len(urllib_docs)
Out[5]: 28486
In [6]: urllib_docs[:80]
Out[6]: '<!DOCTYPE html PUBLIC "//W3C//DTD HTML 4.0 Transitional//EN">\
n<html>\n<head>\n<li'
```
```
In [7]: urllib_docs[80:]
Out[7]: 'nt...</a></i> for information on suggesting changes.\
n</address>\n</body>\n</html>\n'
```
```
Здесь сначала импортируется модуль urllib. Затем создается fileпо
добный объект с именем url_file. Далее выполняется чтение содержи
мого url_file в строку с именем urllib_docs. И только для того, чтобы продемонстрировать, что данные действительно были получены из
Интернета, с помощью операции извлечения среза выводятся первые и последние 80 символов полученного документа. Обратите внимание,
что объекты файлов, созданные средствами urllib, поддерживают ме
тоды read() и close(). Кроме того, они поддерживают методы read
line(), readlines(), fileno(), info() и geturl().
Если вам потребуются более широкие возможности, такие как работа
через проксисервер, ищите дополнительную информацию о модуле
urllib по адресу: http://docs.python.org/lib/module>urllib.html. Если
вам требуются еще более широкие возможности, такие как аутентифи
кация и работа с cookie, подумайте об использовании модуля urllib2,
описание которого вы найдете по адресу: http://docs.python.org/lib/
module>urllib2.html.

## Анализ журналов

С точки зрения системного администратора никакое обсуждение во
просов обработки текста не может считаться законченным без обсуж
дения проблемы анализа файлов журналов, поэтому здесь мы рассмот
рим эту проблему. Мы заложили основу знаний, которые позволят вам
открыть файл журнала, прочитать его построчно и при этом извлекать
данные тем способом, который вы сочтете наиболее подходящим. Пре
жде чем приступить к реализации очередного примера, нам необходи
мо ответить на вопрос: «Что нам необходимо получить в результате
чтения файла журнала?». Ответ достаточно прост: прочитать журнал
обращений к вебсерверу Apache и определить количество байтов, по
лученных каждым отдельным клиентом.
Согласно описанию http://httpd.apache.org/docs/1.3/logs.html «ком
бинированный» формат записи в файле журнала имеет следующий
вид:
```
```
127.0.0.1 frank [10/Oct/2000:13:55:360700] "GET /apache_pb.gif HTTP/1.0"
200 2326 "http://www.example.com/start.html" "Mozilla/4.08 [en] (Win98; I
;Nav)"
```
```
И это соответствует данным в нашем файле журнала вебсервера Apa
che. В каждой строке журнала интерес для нас будут представлять две
вещи: IPадрес клиента и число переданных байтов. IPадрес клиента
находится в первом поле записи, в данном случае – это адрес 127.0.0.1.
Количество переданных байтов содержится в третьем поле с конца,
в данном случае было передано 2326 байтов. Как же нам получить эти
поля? Взгляните на пример 3.24.
_Пример 3.24. Сценарий анализа файла журнала веб>сервера Apache – разбиение по пробелам_

```
#!/usr/bin/env python
"""
ПОРЯДОК ИСПОЛЬЗОВАНИЯ:
apache_log_parser_split.py some_log_file
Этот сценарий принимает единственный аргумент командной строки: имя файла
журнала, который требуется проанализировать. Он анализирует содержимое файла
и генерирует отчет, содержащий перечень удаленных хостов и число байтов,
переданных каждому из них.
"""
import sys

def dictify_logline(line):

'''возвращает словарь, содержащий информацию, извлеченную из
комбинированного файла журнала
В настоящее время нас интересуют только адреса удаленных хостов
и количество переданных байтов, но для полноты картины мы
добавили выборку кода состояния.
'''

split_line = line.split()
return {'remote_host': split_line[0],
'status': split_line[8],
'bytes_sent': split_line[9],
}

def generate_log_report(logfile):

'''возвращает словарь в формате:
remote_host=>[список числа переданных байтов]
Эта функция принимает объект типа file, выполняет обход всех строк
в файле и создает отчет о количестве байтов, переданных при каждом
обращении удаленного хоста к вебсерверу.
'''

report_dict = {}
for line in logfile:
line_dict = dictify_logline(line)
print line_dict
try:
bytes_sent = int(line_dict['bytes_sent'])
except ValueError:
##полностью игнорировать непонятные нам ошибки
continue
report_dict.setdefault(line_dict['remote_host'],
[]).append(bytes_sent)
return report_dict
if __name__ == "__main__":
if not len(sys.argv) > 1:
print __doc__
sys.exit(1)
infile_name = sys.argv[1]
try:
infile = open(infile_name, 'r')
except IOError:
print "You must specify a valid file to parse"
print __doc__
sys.exit(1)
log_report = generate_log_report(infile)
print log_report
infile.close()
```

Этот пример чрезвычайно прост. В разделе __main__ выполняется всего
несколько действий. Вопервых, осуществляется минимально необхо
димая проверка аргументов командной строки, чтобы убедиться, что
сценарий получил как минимум один аргумент. Если пользователь за
пустит сценарий без аргументов, сценарий выведет сообщение о по
рядке использования и завершит работу. Более полное обсуждение,
как лучше обрабатывать аргументы и параметры командной строки,
приводится в главе 13. Далее, в разделе __main__ предпринимается по
пытка открыть указанный файл журнала. Если попытка открыть
файл завершается неудачей, сценарий выведет сообщение о порядке
использования и завершит работу. После этого сценарий передает
файл функции generate_log_report() и выводит результаты.
Функция generate_log_report() создает словарь, который играет роль
отчета. После этого она выполняет обход всех строк в файле и передает
каждую строку функции dictify_logline(), которая в свою очередь воз
вращает словарь, содержащий необходимую нам информацию. Затем
она проверяет, является ли значение bytes_sent целым числом. Если
это целое число, обработка строки продолжается, если нет – выполня
ется переход к следующей строке. После этого она добавляет в словарь
отчета данные, полученные от функции dictify_logline(). Наконец,
она возвращает сформированный словарь отчета программному коду
вразделе __main__.
Функция dictify_logline() просто разбивает строку по пробелам, из
влекает определенные элементы из полученного списка и возвращает
словарь с данными, извлеченными из строки.
Будет ли работать такой сценарий? Проверим это с помощью модуль
ного теста из примера 3.25.
```
```
Пример 3.25. Модульный тест сценария анализа файла журнала веб>сервера
Apache – разбиение по пробелам
#!/usr/bin/env python
import unittest
import apache_log_parser_split
class TestApacheLogParser(unittest.TestCase):
```
```
def setUp(self):
pass
```
```
def testCombinedExample(self):
# тест комбинированного примера с сайта apache.org
combined_log_entry = '127.0.0.1 \
' frank [10/Oct/2000:13:55:360700] '\
'"GET /apache_pb.gif HTTP/1.0" 200 2326 '\
'"http://www.example.com/start.html" '\
'"Mozilla/4.08 [en] (Win98; I ;Nav)"'
self.assertEqual(
apache_log_parser_split.dictify_logline(combined_log_entry),
{'remote_host':'127.0.0.1', 'status':'200', 'bytes_sent':'2326'})
def testCommonExample(self):
# тест общего примера с сайта apache.org
common_log_entry = '127.0.0.1 '\
' frank [10/Oct/2000:13:55:360700] '\
'"GET /apache_pb.gif HTTP/1.0" 200 2326'
self.assertEqual(
apache_log_parser_split.dictify_logline(common_log_entry),
{'remote_host':'127.0.0.1', 'status':'200', 'bytes_sent':'2326'})
def testExtraWhitespace(self):
# тест для случая с дополнительными пробелами между полями
common_log_entry = '127.0.0.1 '\
' frank [10/Oct/2000:13:55:360700] '\
'"GET /apache_pb.gif HTTP/1.0" 200 2326'
self.assertEqual(
apache_log_parser_split.dictify_logline(common_log_entry),
{'remote_host':'127.0.0.1', 'status':'200', 'bytes_sent':'2326'})
def testMalformed(self):
# тест для случая с дополнительными пробелами между полями
common_log_entry = '127.0.0.1 '\
' frank [10/Oct/2000:13:55:360700] '\
'"GET /some/url/with white space.html HTTP/1.0" 200 2326'
self.assertEqual(
apache_log_parser_split.dictify_logline(common_log_entry),
{'remote_host':'127.0.0.1', 'status':'200', 'bytes_sent':'2326'})
if __name__ == '__main__':
unittest.main()
```

Этот сценарий работает с комбинированным и общим форматами запи
сей в журнале, но небольшое изменение в строке приводит к тому, что
тест завершается неудачей. Ниже приводятся результаты тестиро
вания:
jmjones@dinkgutsy:code$ python test_apache_log_parser_split.py
...F
======================================================================
FAIL: testMalformed (__main__.TestApacheLogParser)
```
```
Traceback (most recent call last):
File "test_apache_log_parser_split.py", line 38, in testMalformed
{'remote_host': '127.0.0.1', 'status': '200', 'bytes_sent': '2326'})
AssertionError: {'status': 'space.html', 'bytes_sent': 'HTTP/1.0"',
'remote_host': '127.0.0.1'} != {'status': '200', 'bytes_sent': '2326',
'remote_host': '127.0.0.1'}
```
```
Ran 4 tests in 0.001s
FAILED (failures=1)
```
```
Вследствие того, что в поле адреса появились два лишних пробела, все
последующие поля в этой записи сместились на две позиции вправо.
Здоровая подозрительность – хорошее качество. Основываясь на спе
цификациях форматов записей в журнале, можно достаточно уверен
но извлекать адреса удаленных хостов и число переданных байтов,
опираясь на способ выделения полей по пробелам. Пример 3.26 пред
ставляет реализацию того же самого сценария, выполненную с приме
нением регулярных выражений.
```
```
Пример 3.26. Сценарий анализа файла журнала веб>сервера Apache
#!/usr/bin/env python
"""
ПОРЯДОК ИСПОЛЬЗОВАНИЯ:
apache_log_parser_regex.py some_log_file
Этот сценарий принимает единственный аргумент командной строки: имя файла
журнала, который требуется проанализировать. Он анализирует содержимое файла
и генерирует отчет, содержащий перечень удаленных хостов и число байтов,
переданных каждому из них.
"""
import sys
import re
log_line_re = re.compile(r'''(?P<remote_host>\S+) #IP ADDRESS
\s+ #whitespace
\S+ #remote logname
\s+ #whitespace
\S+ #remote user
\s+ #whitespace
\[[^\[\]]+\] #time
\s+ #whitespace
"[^"]+" #first line of request
\s+ #whitespace
(?P<status>\d+)
\s+ #whitespace
(?P<bytes_sent>|\d+)
\s* #whitespace
''', re.VERBOSE)
def dictify_logline(line):

'''возвращает словарь, содержащий информацию, извлеченную
из комбинированного файла журнала
В настоящее время нас интересуют только адреса удаленных хостов
и количество переданных байтов, но но для полноты картины
мы добавили выборку кода состояния.
'''

m = log_line_re.match(line)
if m:
groupdict = m.groupdict()
if groupdict['bytes_sent'] == '':
groupdict['bytes_sent'] = '0'
return groupdict
else:
return {'remote_host': None,
'status': None,
'bytes_sent': "0",
}
def generate_log_report(logfile):
'''возвращает словарь в формате:
remote_host=>[список числа переданных байтов]
```
```
Эта функция принимает объект типа file, выполняет обход
всех строк в файле и создает отчет о количестве байтов,
переданных при каждом обращении удаленного хоста к вебсерверу.
'''
report_dict = {}
for line in logfile:
line_dict = dictify_logline(line)
print line_dict
try:
bytes_sent = int(line_dict['bytes_sent'])
except ValueError:
##полностью игнорировать непонятные нам ошибки
continue
report_dict.setdefault(line_dict['remote_host'],
[]).append(bytes_sent)
return report_dict
```
```
if __name__ == "__main__":
if not len(sys.argv) > 1:
print __doc__
sys.exit(1)
infile_name = sys.argv[1]
try:
infile = open(infile_name, 'r')
except IOError:
print "You must specify a valid file to parse"
print __doc__
sys.exit(1)
log_report = generate_log_report(infile)
print log_report
infile.close()
```

Единственная функция, которая изменилась по сравнению с приме
ром, основанным на «разбиении по пробелам», – это функция dicti
fy_logline(). При этом подразумевается, что тип значения, возвращае
мого этой функцией, остался прежним и в примере, основанном на
применении регулярных выражений. Вместо того, чтобы разбивать
строку из журнала по пробелам, мы воспользовались объектом скомпи
лированного регулярного выражения, log_line_re, для выявления соот
ветствий с помощью метода match(). Если соответствие обнаружено,
с помощью метода groupdict() извлекаются практически готовые к воз
врату данные, где значение bytes_sent устанавливается равным 0, если
поле содержит прочерк (–) (потому что прочерк означает «нисколько»).
Если соответствие не было найдено, возвращается словарь с теми же са
мыми ключами, но со значениями элементов, равными None и 0.
Действительно ли версия сценария, основанная на использовании ре
гулярных выражений, работает лучше, чем предыдущая? Да, это так.
Ниже приводится модульный тест для новой версии сценария анализа
файлов журнала вебсервера Apache:
#!/usr/bin/env python
```
```
import unittest
import apache_log_parser_regex
```
```
class TestApacheLogParser(unittest.TestCase):
def setUp(self):
pass
def testCombinedExample(self):
# тест комбинированного примера с сайта apache.org
combined_log_entry = '127.0.0.1 \
' frank [10/Oct/2000:13:55:360700] '\
'"GET /apache_pb.gif HTTP/1.0" 200 2326 '\
'"http://www.example.com/start.html" '\
'"Mozilla/4.08 [en] (Win98; I ;Nav)"'
self.assertEqual(
apache_log_parser_regex.dictify_logline(combined_log_entry),
{'remote_host':'127.0.0.1', 'status':'200', 'bytes_sent':'2326'})
def testCommonExample(self):
# тест общего примера с сайта apache.org
common_log_entry = '127.0.0.1 '\
' frank [10/Oct/2000:13:55:360700] '\
'"GET /apache_pb.gif HTTP/1.0" 200 2326'
self.assertEqual(
apache_log_parser_regex.dictify_logline(common_log_entry),
{'remote_host':'127.0.0.1', 'status':'200', 'bytes_sent':'2326'})
```
```
def testMalformed(self):
# тест для модифицированного примера с ошибками с сайта apache.org
#malformed_log_entry = '127.0.0.1 '\
#' frank [10/Oct/2000 13:55:360700] '\
#'"GET /apache_pb.gif HTTP/1.0" 200 2326 '\
#'"http://www.example.com/start.html" '\
#'"Mozilla/4.08 [en] (Win98; I ;Nav)"'
```
```
malformed_log_entry = '127.0.0.1 '\
' frank [10/Oct/2000:13:55:360700] '\
'"GET /some/url/with white space.html HTTP/1.0" 200 2326'
self.assertEqual(
apache_log_parser_regex.dictify_logline(common_log_entry),
{'remote_host':'127.0.0.1', 'status':'200', 'bytes_sent':'2326'})
```
```
if __name__ == '__main__':
unittest.main()
```
```
И ниже – результаты модульного тестирования:
jmjones@dinkgutsy:code$ python test_apache_log_parser_regex.py
...
```
```
Ran 3 tests in 0.001s
OK
```
## ElementTree

```
Если текст, который необходимо проанализировать, имеет формат
XML, скорее всего вам придется подходить к решению этой проблемы
с несколько иной стороны, чем, например, к анализу обычных тексто
вых файлов журналов. Едва ли вы захотите читать такие файлы стро
ку за строкой и выполнять поиск по шаблону, и едва ли получится ши
роко использовать регулярные выражения. В формате XML использу
ется древовидная структура организации данных, поэтому подход, ос
нованный на построчном чтении, здесь не годится. И использование
регулярных выражений для построения древовидной структуры дан
ных легко может превратиться в кошмар.
Что же тогда делать? Для работы с форматом XML обычно использует
ся один из двух подходов. Существует такая вещь, как «simple API for
XML» (простой прикладной интерфейс для работы с форматом XML),
или SAX. Стандартная библиотека языка Python имеет в своем составе
анализатор SAX. Он обладает высокой скоростью работы и потребляет
совсем немного памяти при анализе XML. Но он основан на примене
нии функций обратного вызова, поэтому для определенных частей
данных, когда встречаются такие разделы документа XML, как от
крывающий и закрывающий теги, он просто вызывает определенные
методы. Это означает, что вам придется задать обработчики для дан
ных и самостоятельно отслеживать информацию о состоянии, что мо
жет оказаться далеко не простым делом. Это делает утверждение
«simple» (простой) в названии «simple API for XML» не совсем соот
ветствующим истине. Другой подход к обработке XML заключается
в использовании объектной модели документа (Document Object Mo
del, DOM). В состав стандартной библиотеки языка Python входит
и библиотека DOM XML. Как правило, анализатор DOM не отличается
высокой скоростью работы и потребляет больше памяти, чем SAX, по
тому что он считывает дерево XML в память целиком и создает отдель
ные объекты для каждого узла дерева. Преимущество использования
DOM заключается в том, что вам не придется отслеживать информа
цию о состоянии, так как каждый узел хранит информацию о роди
тельских и дочерних узлах. Однако прикладной интерфейс DOM в луч
шем случае приходится признать достаточно громоздким.
Имеется и третья возможность – ElementTree. ElementTree – это биб
лиотека синтаксического анализа XML, которая входит в состав стан
дартной библиотеки языка Python, начиная с версии Python 2.5. Биб
лиотеку ElementTree можно представить себе, как легковесный анали
затор DOM, с простым и удобным прикладным интерфейсом. В дополне
ние к простоте и удобству в использовании этот анализатор потребляет
незначительный объем памяти. Мы настоятельно рекомендуем ис
пользовать ElementTree. Если у вас возникнет потребность выполнять
синтаксический анализ документов XML, попробуйте сначала вос
пользоваться библиотекой ElementTree.
Чтобы с помощью ElementTree приступить к анализу файла в формате
XML, достаточно просто импортировать библиотеку и передать требуе
мый файл функции parse():
In [1]: from xml.etree import ElementTree as ET
```
```
In [2]: tcusers = ET.parse('/etc/tomcat5.5/tomcatusers.xml')
In [3]: tcusers
```
```
Out[3]: <xml.etree.ElementTree.ElementTree instance at 0xabb4d0></xml>
```
```
Здесь, чтобы сократить объем ввода с клавиатуры при работе с библио
текой, мы импортировали модуль ElementTree под именем ET. Далее,
мы предложили библиотеке выполнить разбор XMLфайла со списком
пользователей, полученного от механизма сервлетов Tomcat. Объект,
созданный библиотекой ElementTree, мы назвали tcusers. Объект tcus
ers имеет тип xml.etree.ElementTree.ElementTree.
Мы удалили из файла пользователей сервера Tomcat примечания о по
рядке использования и текст лицензионного соглашения, в результате
он принял следующий вид:
```
```
<?xml version="1.0" encoding="UTF8"?>
<tomcatusers>
<user name="tomcat" password="tomcat" roles="tomcat" />
<user name="role1" password="tomcat" roles="role1" />
<user name="both" password="tomcat" roles="tomcat,role1" />
</tomcatusers>
Во время разбора XMLфайла метод parse() из библиотеки ElementTree
создает и возвращает объект дерева, ссылка на который записывается
в переменную tcusers. После этого данная переменная может исполь
зоваться для организации доступа к различным узлам дерева в файле
XML. Наибольший интерес для нас представляют два метода этого
объекта: find() и findall(). Метод find() отыскивает первый узел, соот
ветствующий запросу, который ему передается, и возвращает объект
Element, представляющий этот узел. Метод findall() отыскивает все уз
лы, соответствующие запросу, и возвращает список объектов Element,
которые представляют эти узлы.
Перечень шаблонов, которые можно передавать методам find() и find
all(), ограничен подмножеством выражений на языке XPath. В каче
стве критериев поиска можно указывать имя тега, символ «*», соот
ветствующий всем дочерним элементам; символ «.», соответствую
щий текущему узлу; и комбинацию «//», соответствующую всем под
чиненным узлам, начиная от точки поиска. Символ слеша (/) может
использоваться в качестве разделителя критериев поиска. С помощью
метода find() и имени тега мы попробовали отыскать первый узел user
в файле пользователей Tomcat:
In [4]: first_user = tcusers.find('/user')
In [5]: first_user
Out[5]: <Element user at abdd88>
```
```
Мы передали методу find() критерий "/user". Начальный символ сле
ша указывает на абсолютный путь с началом в корневом узле. Текст
'user' определяет имя тега, который требуется отыскать. Отсюда сле
дует, что метод find() вернет первый узел с тегом user. Здесь видно, что
объект с именем first_user принадлежит к типу Element.
В число наиболее интересных для нас методов и атрибутов объекта
Element входят attrib, find(), findall(), get(), tag и text. Атрибут attrib –
это словарь атрибутов, принадлежащих данному объекту Element. Ме
тоды find() и findall() этого объекта работают точно так же, как одно
именные методы объекта ElementTree. Метод get() используется для из
влечения указанного атрибута из словаря атрибутов текущего тега
XML. Атрибут tag содержит имя тега текущего объекта Element. Атри
бут text содержит текст, расположенный в текстовом узле текущего
объекта Element.
Ниже приводится элемент документа XML, соответствующий объекту
first_user:
```
```
<user name="tomcat" password="tomcat" roles="tomcat" />
```
```
Теперь попробуем обратиться к методам и атрибутам объекта tcusers:
```
```
In [6]: first_user.attrib
Out[6]: {'name': 'tomcat', 'password': 'tomcat', 'roles': 'tomcat'}
In [7]: first_user.get('name')
Out[7]: 'tomcat'
```
```
In [8]: first_user.get('foo')
In [9]: first_user.tag
```
```
Out[9]: 'user'
In [10]: first_user.text
```
```
Теперь, когда вы получили некоторое представление о возможностях
библиотеки ElementTree, рассмотрим более сложный пример. Мы вы
полним разбор файла пользователей Tomcat и отыщем все узлы user,
где значение атрибута name соответствует значению, заданному нами
(в данном случае 'tomcat'), как показано в примере 3.27.
```
```
Пример 3.27. Разбор файла пользователей Tomcat с помощью
библиотеки ElementTree
#!/usr/bin/env python
```
```
from xml.etree import ElementTree as ET
if __name__ == '__main__':
infile = '/etc/tomcat5.5/tomcatusers.xml'
tomcat_users = ET.parse(infile)
for user in [e for e in tomcat_users.findall('/user') if
e.get('name') == 'tomcat']:
print user.attrib
```
```
Единственное, что представляет сложность в этом примере, – это ис
пользование генератора списков для поиска соответствующих атрибу
тов name. Этот сценарий возвращает следующий реультат:
```
```
jmjones@dinkgutsy:code$ python elementtree_tomcat_users.py
{'password': 'tomcat', 'name': 'tomcat', 'roles': 'tomcat'}
```
```
В заключение ниже приводится пример использования библиотеки
ElementTree для извлечения некоторой информации из неудачно
сформированного фрагмента XML. В операционной системе Mac OS X
имеется утилита с именем system_profiler, которая отображает инфор
мацию о системе. Формат XML является одним из выходных форма
тов, которые поддерживает утилита system_profiler, но похоже, что
поддержка формата XML была добавлена в самый последний момент.
Мы предполагаем извлечь информацию о версии операционной систе
мы, которая содержится в следующем фрагменте файла XML:
<dict>
<key>_dataType</key>
<string>SPSoftwareDataType</string>
<key>_detailLevel</key>
<integer>2</integer>
<key>_items</key>
<array>
<dict>
<key>_name</key>
<string>os_overview</string>
<key>kernel_version</key>
<string>Darwin 8.11.1</string>
<key>os_version</key>
<string>Mac OS X 10.4.11 (8S2167)</string>
</dict>
</array>
```
```
Вы спросите, почему на наш взгляд этот фрагмент XML оформлен не
удачно? Дело в том, что ни в одном из тегов XML нет ни одного атрибу
та. В основной своей массе теги представляют типы данных. И такие
теги с переменными значениями, как key и string, заключены в один
и тот же родительский тег. Взгляните на пример 3.28.
```
```
Пример 3.28. Разбор файла, полученного в результате вызова утилиты
system_profiler в Mac OS X
#!/usr/bin/env python
import sys
from xml.etree import ElementTree as ET
e = ET.parse('system_profiler.xml')
if __name__ == '__main__':
for d in e.findall('/array/dict'):
if d.find('string').text == 'SPSoftwareDataType':
sp_data = d.find('array').find('dict')
break
else:
print "SPSoftwareDataType NOT FOUND"
sys.exit(1)
record = []
for child in sp_data.getchildren():
record.append(child.text)
if child.tag == 'string':
print "%15s> %s" % tuple(record)
record = []
```
```
Сценарий отыскивает все теги dict, в которых имеется дочерний эле
мент string с текстом 'SPSoftwareataType'. Информация, которую тре
буется извлечь, находится в этом узле. В этом примере используется
единственный метод, который не обсуждался ранее, – это метод get
children(). Он просто возвращает список дочерних узлов указанного
элемента. Кроме того, этот пример достаточно ясен, хотя сам файл
XML можно было бы оформить лучше. Ниже приводится результат,
полученный от сценария, когда он был запущен на ноутбуке, работаю
щем под управлением операционной системы Mac OS X Tiger:
dink:~/code jmjones$ python elementtree_system_profile.py
_name> os_overview
kernel_version> Darwin 8.11.1
os_version> Mac OS X 10.4.11 (8S2167)
```
```
Библиотека стала прекрасным дополнением к стандартной библиотеке
языка Python. Мы долгое время пользуемся ею и рады, что у нас есть
такая возможность. Вы можете попробовать пользоваться библиотека
ми SAX и DOM, имеющимися в стандартной библиотеке языка Py
thon, но мы думаем, что рано или поздно вы вернетесь к библиотеке
ElementTree.

## В заключение.

В этой главе были обозначены некоторые фундаментальные принципы
обработки текста в языке Python. Мы имели дело со встроенным ти
пом string, с регулярными выражениями, стандартным вводом и вы
водом, с модулями StringIO и urllib из стандартной библиотеки. После
этого использовали все полученные знания в двух примерах анализа
файлов журналов вебсервера Apache. В заключение были рассмотре
ны основы применения библиотеки ElementTree и продемонстрирова
ны два примера использования для решения практических задач.
Складывается впечатление, что большинство специалистов по опера
ционной системе UNIX, когда речь заходит об обработке текста более
сложной, чем позволяют grep и awk, видят единственную альтерна
тиву – язык Perl. Хотя Perl представляет собой очень мощный язык
программирования, особенно в области обработки текста, мы полага
ем, что язык Python может предложить ничуть не меньше возможно
стей. Фактически, особенно если учесть чистоту синтаксиса и просто
ту, с какой можно перейти от процедурного к объектноориентирован
ному стилю программирования, мы считаем, что язык Python облада
ет преимуществами перед языком Perl. Поэтому мы надеемся, что
в следующий раз, когда вам придется столкнуться с необходимостью
реализовать обработку текста, вы сначала вспомните о языке Python.
