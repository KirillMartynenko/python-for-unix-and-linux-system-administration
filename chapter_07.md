# Глава 7. SNMP

**Введение**

Протокол SNMP может изменить вашу жизнь системного администра
тора. Отдача от использования SNMP ощущается не так скоро, как от
нескольких строк программного кода на языке Python, выполняющих
анализ файла журнала, например, но когда инфраструктура SNMP бу
дет настроена, работа с ней начинает удивлять.

В этой главе мы рассмотрим следующие аспекты SNMP: автообнару
жение, опрос/мониторинг, создание агентов, управление устройства
ми и, наконец, интеграцию оборудования средствами SNMP. Безус
ловно, все это можно реализовать на языке Python.

Если вы не знакомы с SNMP или вам требуется освежить свои знания
о SNMP, мы настоятельно рекомендуем прочитать книгу «Essential
SNMP» Дугласа Мауро (Douglas Mauro) и Кевина Шмидта (Kevin
Schmidt) (O’Reilly) или хотя бы держать ее под рукой. Хороший спра
вочник является основой к истинному пониманию возможностей
SNMP. В следующем разделе мы рассмотрим основы SNMP, но глубо
кое изучение этого протокола выходит далеко за рамки этой книги.
В действительности тема использования Python в комплексе с SNMP
настолько обширна, что заслуживает отдельной книги.

## Краткое введение в SNMP

**Обзор SNMP**

С высоты 3000 метров SNMP – это протокол управления устройствами в IP-сетях. Как правило, этот протокол работает с портами UDP 161
и 162, хотя вполне возможно использовать и порты TCP. Практически все современные устройства в центрах обработки данных поддерживают работу с протоколом SNMP, а это означает, что имеется возможность управлять не только коммутаторами и маршрутизаторами, но также серверами, принтерами, блоками бесперебойного питания, накопителями и другими устройствами.
Работа протокола SNMP основана на передаче хостам пакетов UDP
и ожидании ответов. Таким образом на самом простом уровне произво
дится мониторинг устройств. Тем не менее, протокол SNMP обладает
гораздо более широкими возможностями благодаря управляющим уст
ройствам и возможности создания агентов, отвечающих на запросы.
Наиболее типичными примерами того, что возможно с применением
SNMP, является мониторинг нагрузки на процессор, использования
диска и объема свободной памяти. Этот протокол может также исполь
зоваться для управления сетевыми коммутаторами, с его помощью
вполне возможно даже выполнять загрузку новых параметров на
стройки коммутатора. Мало кому известно, что точно так же можно
осуществлять мониторинг программного обеспечения, такого как веб
приложения и базы данных. Наконец, имеется поддержка RMON MIB
(Remote Monitoring Management Information Base – база управляющей
информации для удаленного мониторинга), которая обеспечивает мо
ниторинг «динамики», тогда как в обычном режиме SNMP применя
ется для мониторинга статических показателей.
Мы уже упомянули аббревиатуру MIB, поэтому сейчас объясним, что
это такое. SNMP – это всего лишь протокол, и он не делает никаких
предположений о данных. На подконтрольных устройствах выполняет
ся агент, snmpd, у которого имеется перечень объектов, подвергаемых
мониторингу. Фактически перечень представляет собой базу управ
ляющей информации, или MIB (Management Information Base). У каж
дого агента имеется, по крайней мере, одна база MIB, структура кото
рой соответствует спецификациям MIBII, определяемым в RFC 1213.
Базу MIB можно представить себе как файл, который используется
для трансляции имен в числа (чемто похоже на DNS), хотя на самом
деле все немного сложнее.
В этом файле находятся описания объектов управления. У каждого
объекта имеется три атрибута: имя, тип и синтаксис и данные для пе
редачи. Из них вам чаще всего придется работать с именами. Имена
часто еще называют идентификаторами объектов, или OID (Object
Identifier). Передавая этот OID агенту, вы тем самым сообщаете, что
именно хотели бы получить. Имена имеют две формы представления:
числовую и «удобочитаемую». Чаще используется удобочитаемая
форма имен, потому что числовые имена имеют большую длину и их
сложно запоминать. Одним из самых часто используемых OID являет
ся sysDescr. Если вы воспользуетесь инструментом командной строки
snmpwalk, чтобы получить значение идентификатора sysDescr, вы мо
жете использовать как удобочитаемую, так и числовую форму пред
ставления:

```
[root@rhel][H:4461]# snmpwalkv 2c c public localhost .1.3.6.1.2.1.1.1.0
SNMPv2MIB::sysDescr.0 = STRING: Linux localhost
2.6.188.1.15.el5 #1 SMP Mon Oct 22 08:32:04 EDT 2007 i686
[root@rhel][H:4461]# snmpwalkv 2c c public localhost sysDescr
SNMPv2MIB::sysDescr.0 = STRING: Linux localhost
2.6.188.1.15.el5 #1 SMP Mon Oct 22 08:32:04 EDT 2007 i686
```

К этому моменту мы нагрузили вас уймой аббревиатур и RFC, но при
зываем вас пересилить в себе желание встать и пойти спать. Мы обе
щаем, что очень скоро исправимся и приступим к разработке про
граммного кода.
```
**Установка и настройка SNMP**

```
Для упрощения дальнейшего повествования мы будем использовать
только пакет NetSNMP и соответствующее расширение Python к не
му. Но это не говорит о его большей ценности в сравнении с другими
библиотеками SNMP для Python, например PySNMP, используемой
в таких продуктах, как TwistwdSNMP и Zenoss. В Zenoss и в Twisted
SNMP библиотека PySNMP используется в асинхронном режиме. Это
очень правильный подход, который заслуживает рассмотрения, но у нас
просто нет места, чтобы описать оба эти продукта в данной главе.
Говоря в терминах NetSNMP, мы будем иметь дело с двумя различны
ми прикладными интерфейсами (API). Первый метод состоит в ис
пользовании модуля subprocess, чтобы «обернуть» инструменты ко
мандной строки из пакета NetSNMP, а второй – в использовании но
вых расширений для Python. Каждый из этих методов имеет свои пре
имущества и недостатки в зависимости от среды, в которой они
применяются.
В заключение мы также познакомимся с продуктом Zenoss, который
представляет собой весьма внушительное решение мониторинга сетей
посредством протокола SNMP, полностью реализованное на языке Py
thon и распространяемое с открытыми исходными текстами. При ис
пользовании Zenoss нам не придется писать средства управления SNMP
с чистого листа и вместо этого мы сможем взаимодействовать с ним по
средством его общедоступного API. Кроме того, проект Zenoss предос
тавляет нам возможность создавать собственные модули для этого про
дукта, вносить исправления и, наконец, расширять его функциональ
ность.
Чтобы добиться чегото полезного от SNMP, и в частности от NetSNMP,
его сначала нужно установить. К счастью, большинство операционных
систем UNIX и Linux устанавливаются вместе с пакетом NetSNMP, по
этому, если вам необходимо реализовать мониторинг устройства, для
этого достаточно будет выполнить необходимые настройки в конфигу
рационном файле snmpd.conf и запустить демон. Если вы предполагае
те разрабатывать на языке Python приложения, использующие пакет
```

Краткое введение в SNMP **255**

```
NetSNMP, о котором идет речь в этой главе, вам необходимо скомпи
лировать и установить расширения для Python. Если же вы предпола
гаете просто обертывать команды NetSNMP, такие как snmpget, snmp
walk, snmpdf и другие, тогда вам ничего не потребуется делать, если сам
пакет NetSNMP уже установлен.
Как вариант, вы можете загрузить виртуальную машину с исходными
текстами примеров для этой книги с сайта издательства http://www.ore>
illy.com/9780596515829. Вы можете также обращаться на сайт под
держки книги http://www.py4sa.com , где найдете последнюю информацию
о том, как можно опробовать примеры из этого раздела.
Кроме того, мы настроили эту виртуальную машину и с поддержкой
NetSNMP, и с необходимыми расширениями для Python. Вы можете
просто использовать эту виртуальную машину для запуска всех при
меров. Если мощность вашего компьютера позволяет, вы можете соз
дать несколько копий виртуальной машины и запускать под их управ
лением другие примеры из этой главы, чтобы имитировать взаимодей
ствия с несколькими компьютерами одновременно.
Если вы решите самостоятельно установить расширения для Python,
вам потребуется загрузить с сайта sourceforge.net NetSNMP вер
сии 5.4.x или выше. Расширения в этом пакете не скомпилированы
по умолчанию, поэтому вам придется самостоятельно собрать их, сле
дуя инструкциям в каталоге Python/README. В двух словах заметим,
что вам сначала надо будет скомпилировать эту версию NetSNMP,
а затем запустить сценарий setyp.py в каталоге Python. Мы считаем,
что процедура установки наименее утомительна в дистрибутиве Red
Hat Linux, где имеется пакет RPM с исходными текстами. Если вы ре
шили выполнить компиляцию, возможно, вам следует сначала попро
бовать сделать это в Red Hat, чтобы ознакомиться с самим процессом,
а затем приступать к установке в AIX, Solaris, OS X, HPUX и в других
операционных системах. Наконец, если столкнетесь с неприятностя
ми, то для запуска примеров просто воспользуйтесь виртуальной ма
шиной, а порядок компиляции и установки выясните позже.
И еще одно последнее замечание: обязательно выполните команду set
up.py build и затем setup.py test. Это сразу же позволит вам проверить
возможность работы с NetSNMP из Python. В качестве совета: если вы
столкнетесь с неприятностями во время компиляции, запустите ко
манду ldconfig, как показано ниже:
ldconfigv /usr/local/lib/
```
```
Если вам случится устанавливать пакет NetSNMP на стороне клиен
та, который предполагается подвергнуть мониторингу, вам следует
скомпилировать NetSNMP с параметром Host Resources MIB. Для
этого обычно достаточно выполнить следующую команду конфигури
рования процесса сборки:
./configurewithmibmodules=host
```

**256** Глава 7. SNMP

```
Обратите внимание, что при запуске сценария configure он попытается
запустить сценарий автоматической настройки. Но вам не обязатель
но делать это. Часто бывает проще вручную создать свой конфигура
ционный файл. В Red Hat настройки обычно сохраняются в файле
/etc/snmp/snmpd.conf и имеют примерно следующий вид:
syslocation "O'Reilly"
syscontact bofh@oreilly.com
rocommunity public
```
```
Этого простого файла будет вполне достаточно для опробования приме
ров в оставшейся части главы и запросов не для третьей версии SNMP.
Версия SNMPv3 имеет несколько более сложные настройки и не со
всем вписывается в тему данной главы, хотя при этом мы хотели бы
заметить, что в производстве лучше использовать SNMPv3, так как
версии 2 и 1 не имеют никакой защиты. Это значит, что никогда не
следует использовать SNMPv2 и SNMPv1 для передачи запросов через
Интернет, поскольку этот трафик может быть перехвачен. Известны
случаи высококлассных взломов, которые стали возможны благодаря
использованию этих версий.
```
### IPython и NetSNMP.

```
Если прежде вы никогда не занимались разработкой для SNMP, у вас
может возникнуть ощущение, что это не самая приятная работа. Чест
но говоря, это так и есть. Работа с SNMP чемто сродни головной бо
ли – изза высокой сложности протокола, изза необходимости читать
большое число RFC и изза высоких шансов допустить ошибку. Один
из способов попытаться ослабить эту боль состоит в том, чтобы для ис
следования SNMP и получения навыков обращения с API использо
вать оболочку IPython.
В примере 7.1 представлен очень короткий фрагмент программного
кода для запуска на локальной машине.
```
```
Пример 7.1. Использование IPython и Net>SNMP с расширениями Python
In [1]: import netsnmp
In [2]: oid = netsnmp.Varbind('sysDescr')
```
```
In [3]: result = netsnmp.snmpwalk(oid,
...: Version = 2,
...: DestHost="localhost",
...: Community="public")
```
```
Out[4]: ('Linux localhost 2.6.188.1.14.el5 #1 SMP Thu Aug 27 12:51:54 EDT
2008 i686',)
```
```
При исследовании библиотеки очень помогает использование функ
ции дополнения по нажатию клавиши табуляции. В этом примере мы
вовсю использовали функцию дополнения в IPython и с ее помощью
```

IPython и Net;SNMP **257**

```
создали очень простой запрос SNMPv2. В качестве общего примеча
ния: идентификатор sysDescr, о котором мы уже упоминали ранее,
представляет собой очень важный запрос, позволяющий получить ба
зовые характеристики машины. В выводе этого примера можно уви
деть нечто похожее, хотя и не идентичное, тому, что выводит команда
uname – a.
Как будет показано ниже в этой главе, анализ ответа на запрос sysDe
scr является важной частью исследования центров обработки данных.
К сожалению, как и многие составляющие SNMP, этот ответ не совсем
точен. Некоторые устройства могут не возвращать никакого ответа,
некоторые могут возвращать хоть и полезную, но неполную информа
цию, например: «Fibre Switch» (оптоволоконный коммутатор), неко
торые могут возвращать полную строку идентификации производите
ля. У нас недостаточно места, чтобы углубляться в детали решения
этой проблемы, но заметим, что умение анализировать все эти разли
чия как раз и есть то, на чем большие мальчики зарабатывают деньги.
Как вы уже знаете из главы 2 «IPython», существует возможность соз
дать определение класса или функции в виде отдельного файла прямо
из оболочки IPython, переключившись в редактор Vim, выполнив сле
дующую команду:
```
```
ed some_filename.py
```
```
После выхода из редактора вы получаете атрибуты созданного модуля
в своем пространстве имен и можете вывести их командой who. Этот
прием очень удобно использовать при работе с SNMP, так как итера
тивный стиль программирования естественным образом вписывается
в эту прикладную область. Давайте двинемся дальше и запишем сле
дующий ниже фрагмент программного кода в файл с именем snmp.py ,
выполнив команду:
```
```
ed snmp.py
```
```
В примере 7.2 приводится простой модуль, представляющий собой
шаблон создания сеанса с помощью NetSNMP.
```
```
Пример 7.2. Простой модуль создания сеанса с помощью Net>SNMP
#!/usr/bin/env python
import netsnmp
```
```
class Snmp(object):
"""Простой сеанс SNMP"""
def __init__(self,
oid = "sysDescr",
Version = 2,
DestHost = "localhost",
Community = "public"):
self.oid = oid
self.version = Version
```

**258** Глава 7. SNMP

```
self.destHost = DestHost
self.community = Community
```
```
def query(self):
"""Создает запрос SNMP"""
try:
result = netsnmp.snmpwalk(self.oid,
Version = self.version,
DestHost = self.destHost,
Community = self.community)
except Exception, err:
print err
result = None
return result
```
```
После того как вы сохраните этот файл и введете команду who, вы полу
чите следующее:
In [2]: who
Snmp netsnmp
```
```
Теперь, когда у нас имеется объектноориентированный интерфейс
к SNMP, можно воспользоваться им, чтобы выполнить запрос к ло
кальной машине:
```
```
In [3]: s = snmp()
In [4]: s.query()
Out[4]: ('Linux localhost 2.6.188.1.14.el5 #1 SMP Thu Sep 27 18:58:54 EDT
2007 i686',)
```
```
In [5]: result = s.query()
In [6]: len(result)
Out[6]: 1
```
```
Глядя на этот пример, можно сказать, что с помощью этого модуля
легко можно получать результаты, хотя в данном случае мы просто за
пустили сценарий, в котором жестко определили исходные данные;
поэтому теперь попробуем изменить значение объекта OID, чтобы вы
полнить обход всего поддерева системы:
```
```
In [7]: s.oid
Out[7]: 'sysDescr'
```
```
In [8]: s.oid = ".1.3.6.1.2.1.1"
In [9]: result = s.query()
```
```
In [10]: print result
('Linux localhost 2.6.188.1.14.el5 #1 SMP Thu Sep 27 18:58:54 EDT 2007 i686',
'.1.3.6.1.4.1.8072.3.2.10', '121219', 'me@localhost.com', 'localhost',
'"My Local Machine"', '0', '.1.3.6.1.6.3.10.3.1.1', '.1.3.6.1.6.3.11.3.1.1',
'.1.3.6.1.6.3.15.2.1.1', '.1.3.6.1.6.3.1',
'.1.3.6.1.2.1.49', '.1.3.6.1.2.1.4', '.1.3.6.1.2.1.50',
'.1.3.6.1.6.3.16.2.2.1', 'The SNMP Management Architecture MIB.',
```

IPython и Net;SNMP **259**

```
'The MIB for Message Processing and Dispatching.', 'The management information
definitions for the SNMP Userbased Security Model.',
'The MIB module for SNMPv2 entities', 'The MIB module for managing TCP
implementations', 'The MIB module for managing IP and ICMP implementations',
'The MIB module for managing UDP [snip]',
'Viewbased Access Control Model for SNMP.', '0', '0', '0', '0', '0', '0',
'0', '0')
```
```
Такой стиль интерактивного и исследовательского программирования
делает работу с SNMP более приятной. К этому моменту, если вы чув
ствуете в себе уверенность, можете приступить к выполнению запро
сов с другими значениями OID или даже выполнить обход всего дерева
MIB. Однако обход полного дерева MIB может занять некоторое время,
потому что потребуется выполнить запросы для множества значений
OID, поэтому на практике такой подход обычно не используется, так
как при этом будут потребляться ресурсы клиентской машины.
```
```
Не забывайте, что MIBII – это всего лишь файл со значениями
OID, который входит в состав большинства систем, обладающих
поддержкой SNMP. Другие MIB, уникальные для каждого про
изводителя, располагаются в отдельных файлах, к которым мо
жет обращаться агент, чтобы вернуть ответ на запрос. Если вы
захотите перейти на следующую ступень мастерства, вам при
дется найти специализированную документацию от производи
теля с описанием того, в какой базе MIB следует запрашивать
тот или иной OID.
```
```
Теперь перейдем к использованию особенности оболочки IPython, ко
торая позволяет запускать выполнение заданий в фоновом режиме:
```
```
In [11]: bg s.query()
Starting job # 0 in a separate thread.
```
```
In [12]: jobs[0].status
Out[12]: 'Completed'
```
```
In [16]: jobs[0].result
Out[16]:
('Linux localhost 2.6.188.1.14.el5 #1 SMP Thu Sep 27 18:58:54 EDT 2007 i686',
'.1.3.6.1.4.1.8072.3.2.10', '121219', 'me@localhost.com', 'localhost',
'"My Local Machine"',
'0', '.1.3.6.1.6.3.10.3.1.1', '.1.3.6.1.6.3.11.3.1.1',
'.1.3.6.1.6.3.15.2.1.1', '.1.3.6.1.6.3.1',
'.1.3.6.1.2.1.49', '.1.3.6.1.2.1.4', '.1.3.6.1.2.1.50',
'.1.3.6.1.6.3.16.2.2.1',
'The SNMP Management Architecture MIB.', 'The MIB for Message Processing and
Dispatching.',
'The management information definitions for the SNMP Userbased Security
Model.',
'The MIB module for SNMPv2 entities', 'The MIB module for managing TCP
implementations',
'The MIB module for managing IP and ICMP implementations', 'The MIB module for
```

**260** Глава 7. SNMP

```
managing UDP implementations',
'Viewbased Access Control Model for SNMP.', '0', '0', '0', '0', '0', '0',
'0', '0')
```
```
Прежде чем вы придете в восхищение, разрешите сообщить, что хотя
выполнение действий в фоновом режиме прекрасно реализовано в IPy
thon, тем не менее, этот режим может использоваться только при рабо
те с библиотеками, поддерживающими асинхронную модель выполне
ния. А расширения Python для NetSNMP работают в синхронном ре
жиме. В двух словах отметим, что вы не сможете писать многопоточ
ный программный код, ожидающий ответа, так как в основе лежат
блоки кода на языке C.
К счастью, как будет показано в главе, рассказывающей о процессах
и многозадачности, с помощью модуля обработки легко можно соз
давать дочерние процессы для параллельного выполнения запросов
SNMP. В следующем разделе мы рассмотрим проблему создания сце
нария, который будет автоматически исследовать центр обработки
данных.
```
### Исследование центра обработки данных.

```
Одна из наиболее полезных сторон SNMP заключается в использова
нии этого протокола для исследования центра обработки данных. Про
ще говоря, в ходе исследования составляется опись устройств, под
ключенных к сети, и производится сбор информации об этих устройст
вах. Более детальные виды исследований могут использоваться для
выявления связей между собранными данными, например, выяснение
точного MACадреса, под которым сервер известен коммутатору Cisco,
или схемы распределения памяти для оптоволоконного коммутатора
Brocade.
В этом разделе мы создадим простой сценарий, который будет отби
рать корректные IPадреса, MACадреса, основную информацию, по
ставляемую протоколом SNMP, и помещать ее в записи. Этот сценарий
может использоваться в вашей организации как основа для реализа
ции приложений, выполняющих исследование центра обработки дан
ных. При создании сценария мы будем использовать сведения, кото
рые рассматривались в других главах.
Существует несколько различных алгоритмов исследования, с кото
рыми нам приходилось сталкиваться, но только один из них мы пред
ставим вашему вниманию. Суть алгоритма состоит в следующем: по
слать серию запросов по протоколу ICMP; каждому ответившему уст
ройству послать простой запрос SNMP; проанализировать ответ; про
должить исследование на основе полученных данных. Другой алгоритм
подразумевает посылку серии запросов SNMP и сбор ответов с помо
щью другого процесса, но, как уже говорилось выше, мы сосредото
чимся на реализации первого алгоритма. Взгляните на пример 7.3.
```

Исследование центра обработки данных **261**

```
Небольшое замечание к программному коду ниже: поскольку
библиотека NetSNMP предусматривает возможность работы
только в синхронном режиме, мы создаем дочерние процессы
вызовом subprocess.call(). Это приводит к возможности появле
ния блокировок. В части использования утилиты ping мы могли
бы просто использовать subprocess.Popen, но чтобы сохранить
единообразие, мы используем один и тот же прием как для вы
полнения запросов SNMP, так и при использовании утилиты
ping.
```
```
Пример 7.3. Простой сценарий исследования центра обработки данных
#!/usr/bin/env python
from processing import Process, Queue, Pool
import time
import subprocess
import sys
from snmp import Snmp
```
```
q = Queue()
oq = Queue()
#ips = IP("10.0.1.0/24")
ips = ["192.19.101.250", "192.19.101.251", "192.19.101.252",
"192.19.101.253", "192.168.1.1"]
num_workers = 10
```
```
class HostRecord(object):
"""Записи с информацией о хостах"""
def __init__(self, ip=None, mac=None, snmp_response=None):
self.ip = ip
self.mac = mac
self.snmp_response = snmp_response
def __repr__(self):
return "[Host Record('%s','%s','%s')]" % (self.ip,
self.mac,
self.snmp_response)
```
```
def f(i,q,oq):
while True:
time.sleep(.1)
if q.empty():
sys.exit()
print "Process Number: %s Exit" % i
ip = q.get()
print "Process Number: %s" % i
ret = subprocess.call("pingc 1 %s" % ip,
shell=True,
stdout=open('/dev/null', 'w'),
stderr=subprocess.STDOUT)
if ret == 0:
print "%s: is alive" % ip
oq.put(ip)
```

**262** Глава 7. SNMP

```
else:
print "Process Number: %s didn’t find a response for %s " % (i, ip)
pass
def snmp_query(i,out):
while True:
time.sleep(.1)
if out.empty():
sys.exit()
print "Process Number: %s" % i
ipaddr = out.get()
s = Snmp()
h = HostRecord()
h.ip = ipaddr
h.snmp_response = s.query()
print h
return h
try:
q.putmany(ips)
finally:
for i in range(num_workers):
p = Process(target=f, args=[i,q,oq])
p.start()
for i in range(num_workers):
pp = Process(target=snmp_query, args=[i,oq])
pp.start()
print "main process joins on queue"
p.join()
#while not oq.empty():
# print "Validated", oq.get()
print "Main Program finished"
```
```
Когда мы запустили этот сценарий, то получили следующий результат:
[root@giftcsllc02][H:4849][J:0]> python discover.py
Process Number: 0
192.19.101.250: is alive
Process Number: 1
192.19.101.251: is alive
Process Number: 2
Process Number: 3
Process Number: 4
main process joins on queue
192.19.101.252: is alive
192.19.101.253: is alive
Main Program finished
[Host Record('192.19.101.250','None','('Linux linux.host 2.6.188.1.15.el5
#1 SMP Mon Oct 22 08:32:04 EDT 2007 i686',)')]
[Host Record('192.19.101.252','None','('Linux linux.host 2.6.188.1.15.el5
#1 SMP Mon Oct 22 08:32:04 EDT 2007 i686',)')]
[Host Record('192.19.101.253','None','('Linux linux.host 2.6.188.1.15.el5
```

Получение множества значений с помощью SNMP **263**

```
#1 SMP Mon Oct 22 08:32:04 EDT 2007 i686',)')]
[Host Record('192.19.101.251','None','('Linux linux.host 2.6.188.1.15.el5
#1 SMP Mon Oct 22 08:32:04 EDT 2007 i686',)')]
Process Number: 4 didn't find a response for 192.168.1.1
```
```
Полученные результаты показывают, как работает этот интересный
алгоритм исследования центра обработки данных. В этом сценарии
можно было бы коечто исправить: например, добавить запись MAC
адреса в объект HostRecord, переписать программный код в более объ
ектноориентированном стиле, – дополнений хватило бы еще на одну
книгу, и разработок хватило бы на целую компанию. Понимая это, мы
переходим к другому разделу.
```
### Получение множества значений с помощью SNMP

```
Получение единственного значения не представляет большой сложно
сти, хотя иногда бывает желательно проверить ответы или выполнить
некоторое действие, основанное, например, на типе операционной сис
темы, под управлением которой работает компьютер. Чтобы сделать
чтото более значимое, бывает необходимо получить несколько значе
ний и выполнить какиелибо действия над ними.
Часто возникает задача произвести инвентаризацию центра обработки
данных или отдела и собрать сведения о некоторых параметрах всех
имеющихся машин. Представим такую гипотетическую ситуацию: вы
готовитесь к крупному обновлению программного обеспечения и вам
сказали, что каждая система должна иметь как минимум 1 Гбайт ОЗУ.
Вы помните, что на большинстве компьютеров установлено памяти не
менее 1 Гбайта, но среди тысяч поддерживаемых вами компьютеров
имеется несколько таких, где памяти меньше требуемого объема.
Очевидно, что у вас имеется несколько вариантов действий. Рассмот
рим каждый из них:
Вариант 1
Физически обойти все компьютеры и проверить объем ОЗУ на каж
дом из них, запустив некоторую команду или вскрыв корпус. Дос
таточно очевидно, что это не самый привлекательный вариант.
Вариант 2
Зайти по сети на каждый компьютер и выполнить команду, чтобы
определить объем ОЗУ. Этот подход обладает массой недостатков,
но его хотя бы теоретически можно реализовать в виде сценария,
выполняющего команду средствами ssh. Одна из основных проблем
состоит в том, что сценарий должен учитывать различия между
платформами, так как все операционные системы в чемто немного
отличаются. Другая проблема заключается в необходимости знать,
где все эти компьютеры располагаются.
```

**264** Глава 7. SNMP

```
Вариант 3
Написать небольшой сценарий, который опросит все устройства,
включенные в сеть, и определит объем памяти на каждом из них
с помощью SNMP.
Вариант 3, основанный на использовании SNMP, позволяет легко соз
дать опись, в которой будут присутствовать только компьютеры, имею
щие менее 1 Гбайта ОЗУ. Точный идентификатор OID, который потре
буется запросить, носит имя «hrMemorySize». Протокол SNMP отно
сится к разряду тех инструментов, которые всегда выгоднее использо
вать в многозадачном режиме, но всетаки подобной оптимизации
лучше избегать, если это не является абсолютно необходимым. Помня
об этом, перейдем непосредственно к деталям.
Чтобы быстро проверить нашу идею, воспользуемся программным ко
дом из предыдущего примера.
Получение объема памяти с помощью SNMP:
In [1]: run snmpinput
```
```
In [2]: who
netsnmp Snmp
```
```
In [3]: s = Snmp()
In [4]: s.DestHost = "10.0.1.2"
```
```
In [5]: s.Community = "public"
In [6]: s.oid = "hrMemorySize"
```
```
In [7]: result = int(s.query()[0])
hrMemorySize = None ( None )
```
```
In [27]: print result
2026124
```
```
Как видите, реализовать подобный сценарий достаточно просто. Ре
зультат возвращается в виде кортежа в строке [6], поэтому мы извле
каем элемент с индексом 0 и преобразуем его в целое число. Теперь мы
имеем целое число, соответствующее объему памяти в килобайтах.
Единственное, что следует иметь в виду, – на разных компьютерах
объем ОЗУ вычисляется поразному. Поэтому в таких случаях лучше
принимать решение на основе приближенных, а не точных значений.
Например, можно было бы искать компьютеры, объем ОЗУ в которых
немного меньше 1 Гбайта – скажем, 990 Мбайт.
В приведенном примере мы можем примерно оценить, что полученное
число примерно соответствует объему ОЗУ 2 Гбайта. Вы можете пола
гаться на эту информацию, отвечая на запрос своего руководителя
о наличии компьютеров с ОЗУ менее 2 Гбайт, если известно, что новое
приложение, которое требуется установить, требует наличия памяти
не менее 2 Гбайт.
```

Получение множества значений с помощью SNMP **265**

```
Теперь, проверив основную идею, мы можем автоматизировать проце
дуру определения памяти. Если говорить более определенно, следует
опросить все компьютеры, выяснить, в каких из них установлено па
мяти менее 2 Гбайт ОЗУ и затем записать полученную информацию
в файл формата CSV^1 , чтобы ее потом проще было импортировать в Ex
cel или OpenOffice Calc.
Далее можно написать инструмент командной строки, который прини
мает диапазон сетевых адресов в качестве входного аргумента и, до
полнительно, значение идентификатора OID, по умолчанию используя
идентификатор «hrMemorySize». При этом в сценарии нам необходимо
будет предусмотреть обход сетевых адресов из указанного диапазона.
Всякий раз, когда системный администратор пишет программный
код, он сталкивается с определенными ограничениями. В состоянии
ли вы потратить несколько часов или даже дней на создание большого
объектноориентированного сценария, который потом можно будет
использовать для решения других задач, или вам нужно быстро полу
чить хотя бы приблизительные результаты? На наш взгляд, в боль
шинстве случаев вполне можно выполнить обе реализации. При ис
пользовании IPython вы можете быстро создавать заготовки сценари
ев и затем доводить их до окончательного состояния. Вообще – это хо
рошая идея писать программный код многократного использования,
поскольку эта привычка, как снежный ком, быстро обретает инерцию
движения.
Надеемся, что теперь вы понимаете, в чем заключается сила SNMP.
Давайте приступим к созданию нашего сценария...
```
**Поиск объема памяти**

```
В этом следующем примере мы реализуем инструмент командной
строки, определяющий объем памяти, установленной в компьютерах,
с помощью SNMP:
#!/usr/bin/env python
#Инструмент командной строки, определяющий общий объем памяти в компьютере
import netsnmp
import optparse
from IPy import IP
```
```
class SnmpSession(object):
"""Простой сеанс SNMP"""
def __init__(self,
oid="hrMemorySize",
Version=2,
DestHost="localhost",
```
(^1) CSV, или Comma Separated Values, – значения, разделенные запятыми. –
_Прим. перев._


**266** Глава 7. SNMP

```
Community="public"):
self.oid = oid
self.Version = Version
self.DestHost = DestHost
self.Community = Community
def query(self):
"""Создает запрос SNMP"""
try:
result = netsnmp.snmpwalk(self.oid,
Version = self.Version,
DestHost = self.DestHost,
Community = self.Community)
except:
#Несмотря на то, что это всего лишь пример,
#тем не менее, выведем, какое исключение возникло
import sys
print sys.exc_info()
result = None
return result
class SnmpController(object):
"""Использует модуль optparse для управления сеансом SnmpSession"""
def run(self):
results = {} #Место сбора и хранения результатов snmp
p = optparse.OptionParser(description="A tool that determines
memory installed",
prog="memorator",
version="memorator 0.1.0a",
usage="%prog [subnet range] [options]")
p.add_option('community', 'c',help='community string',
default='public')
p.add_option('oid', 'o', help='object identifier',
default='hrMemorySize')
p.add_option('verbose', 'v', action=’store_true',
help='increase verbosity')
p.add_option('quiet', 'q', action=’store_true',help=’
suppresses most messages')
p.add_option('threshold', 't', action=’store', type="int",
help='a number to filter queries with')
```
```
options, arguments = p.parse_args()
if arguments:
for arg in arguments:
try:
ips = IP(arg) #Преобразовать аргумент в строку
except:
if not options.quiet:
print 'Ignoring %s, not a valid IP address' % arg
continue
for i in ips:
ipAddr = str(i)
```

Получение множества значений с помощью SNMP **267**

```
if not options.quiet:
print 'Running snmp query for: ', ipAddr
session = SnmpSession(options.oid,
DestHost = ipAddr,
Community = options.community)
if options.oid == "hrMemorySize":
try:
memory = int(session.query()[0])/1024
except:
memory = None
output = memory
else:
#Обработка результатов, не имеющих отношения
#к объему памяти
output = session.query()
if not options.quiet:
print "%s returns %s" % (ipAddr,output)
#Поместить полученные результаты в словарь,
#Но только если был получен корректный ответ
if output != None:
if options.threshold: #если порог обозначен
if output < options.threshold:
results[ipAddr] = output
#если разрешен вывод результатов
if not options.quiet:
print "%s returns %s" % (ipAddr,output)
else:
results[ipAddr] = output
if not options.quiet:
print output
```
```
print "Results from SNMP Query %s for %s:\n" % (options.oid,
arguments), results
```
```
else:
p.print_help() #при отсутствии аргументов командной строки
#вывести инструкцию об использовании
def _main():
"""
Запускает процесс сбора информации.
"""
start = SnmpController()
start.run()
if __name__ =='__main__':
try:
import IPy
except:
print "Please install the IPy module to use this tool"
_main()
```

**268** Глава 7. SNMP

```
Теперь пройдемся по этому сценарию и посмотрим, что он делает. Мы
взяли целый класс из предыдущего примера и поместили его в новый
модуль. Затем мы написали классконтроллер, который анализирует
аргументы командной строки с помощью модуля optparse. Модуль IPy,
к которому мы обращаемся снова и снова, используется для автомати
ческой обработки IPадресов. Благодаря этому можно указать несколь
ко IPадресов или диапазон адресов, и наш модуль будет отсылать за
просы SNMP и возвращать результаты в виде словаря, в котором роль
ключей будут играть IPадреса, а роль значений – ответы SNMP.
Единственная сложность, которая здесь реализована, – это логика об
работки пустых ответов и проверки порогового значения. То есть мо
дуль возвращает только значения ниже указанного порога. При ис
пользовании порога мы можем получать значимые для нас результаты
и учесть различия в том, как разные компьютеры вычисляют объем
памяти.
Посмотрим на вывод, полученный в результате работы этого модуля:
```
```
[ngift@ngleplap][H:6518][J:0]> ./memory_tool_netsnmp.py 10.0.1.2 10.0.1.20
Running snmp query for: 10.0.1.2
hrMemorySize = None ( None )
1978
Running snmp query for: 10.0.1.20
hrMemorySize = None ( None )
372
Results from SNMP Query hrMemorySize for ['10.0.1.2', '10.0.1.20']:
{'10.0.1.2': 1978, '10.0.1.20': 372}
```
```
Как видите, результаты были получены для компьютеров в подсети
10.0.1.0/24. Теперь воспользуемся флагом threshold (порог), чтобы
сымитировать поиск машин, объем ОЗУ в которых меньше 2 Гбайт.
Как уже упоминалось выше, разные компьютеры поразному вычис
ляют имеющийся объем ОЗУ, поэтому для пущей уверенности возь
мем в качестве порогового значения число 1800, что примерно должно
соответствовать объему ОЗУ 1800 Мбайт. То есть, если в компьютере
объем ОЗУ составляет менее 1800 Мбайт, или примерно 2 Гбайта, ин
формация о нем будет включена в наш отчет.
Ниже приводится результат выполнения такого запроса:
[ngift@ngleplap][H:6519][J:0]>
./memory_tool_netsnmp.pythreshold 1800 10.0.1.2 10.0.1.20
Running snmp query for: 10.0.1.2
hrMemorySize = None ( None )
Running snmp query for: 10.0.1.20
hrMemorySize = None ( None )
10.0.1.20 returns 372
Results from SNMP Query hrMemorySize for ['10.0.1.2', '10.0.1.20']:
{'10.0.1.20': 372}
```

Получение множества значений с помощью SNMP **269**

```
Наш сценарий прекрасно справился с заданием, однако мы можем
сделать еще коечто, чтобы оптимизировать его. Если вам потребует
ся опросить несколько тысяч машин, то для выполнения работы этому
сценарию может потребоваться целый день или даже больше. Это, мо
жет быть, и не страшно, но если вам требуется получить результаты
очень быстро, вам необходимо будет обеспечить возможность парал
лельного выполнения нескольких запросов одновременно и организо
вать ветвление для каждого запроса, используя для этого библиотеку
стороннего производителя. Еще одно усовершенствование, которое
можно было бы внести, – это автоматическое создание файла отчета
в формате CSV из нашего словаря.
Но прежде чем мы перейдем к реализации этих задач, позвольте обра
тить ваше внимание на один момент, который вы, возможно, не заме
тили. Сценарий написан так, что позволяет запрашивать любой OID,
а не только определять объем памяти. Это очень удобно, потому что
у нас теперь имеется как инструмент определения объемов памяти,
так и универсальный инструмент, позволяющий выполнять любые за
просы SNMP.
Рассмотрим пример, который наглядно демонстрирует, что мы имеем
в виду:
```
```
[ngift@ngleplap][H:6522][J:0]> ./memory_tool_netsnmp.pyo sysDescr
10.0.1.2 10.0.1.20
Running snmp query for: 10.0.1.2
sysDescr = None ( None )
10.0.1.2 returns ('Linux cent 2.6.188.1.14.el5 #1 SMP
Thu Sep 27 19:05:32 EDT 2007 x86_64',)
('Linux cent 2.6.188.1.14.el5 #1 SMP Thu Sep 27 19:05:32 EDT 2007 x86_64',)
Running snmp query for: 10.0.1.20
sysDescr = None ( None )
10.0.1.20 returns ('Linux localhost.localdomain 2.6.188.1.14.el5 #1 SMP
Thu Sep 27 19:05:32 EDT 2007 x86_64',)
('Linux localhost.localdomain 2.6.188.1.14.el5 #1 SMP
Thu Sep 27 19:05:32 EDT 2007 x86_64',)
Results from SNMP Query sysDescr for ['10.0.1.2', '10.0.1.20']:
{'10.0.1.2': ('Linux cent 2.6.188.1.14.el5 #1 SMP
Thu Sep 27 19:05:32 EDT 2007 x86_64',), '10.0.1.20':
('Linux localhost.localdomain 2.6.188.1.14.el5 #1 SMP
Thu Sep 27 19:05:32 EDT 2007 x86_64',)}
```
```
Совсем не лишне учитывать это, приступая к работе над «одноразо
вым» инструментом для конкретного случая. Почему бы не потратить
дополнительные 30 минут, чтобы придать ему универсальность? В ре
зультате у вас может получиться инструмент, который будет находить
применение снова и снова, и эти 30 минут превратятся в ничто по срав
нению с тем временем, которое вам удастся сэкономить в будущем.
```

**270** Глава 7. SNMP

### Создание гибридных инструментов SNMP.

```
Мы уже показали вам несколько отдельных инструментов и хотим от
метить, что использованные нами приемы можно объединить для соз
дания весьма сложных инструментов. Начнем с создания серии про
стых узкоспециализированных инструментов, на основе которых позд
нее мы сможем создавать большие сценарии.
Ниже приводится полезный сценарий с именем snmpstatus, который
получает несколько различных запросов snmp и комбинирует из них
«состояние» опрашиваемого узла:
import subprocess
```
```
class Snmpdf(object):
"""Инструмент командной строки snmpstatus"""
def __init__(self,
Version="v2c",
DestHost="localhost",
Community="public",
verbose=True):
self.Version = Version
self.DestHost = DestHost
self.Community = Community
self.verbose = verbose
def query(self):
"""Создает запрос для snmpstatus"""
Version = self.Version
DestHost = self.DestHost
Community = self.Community
verbose = self.verbose
try:
snmpstatus = "snmpstatus %sc %s %s" % (Version, Community,
DestHost)
if verbose:
print "Running: %s" % snmpstatus
p = subprocess.Popen(snmpstatus,
shell=True,
stdout=subprocess.PIPE)
out = p.stdout.read()
return out
except:
import sys
print >> sys.stderr, "error running %s" % snmpstatus
```
```
def _main():
snmpstatus = Snmpdf()
result = snmpstatus.query()
print result
```

Расширение возможностей Net;SNMP **271**

```
if __name__ == "__main__":
_main()
```
```
Мы надеемся, что вы обратили внимание на тот факт, что этот сцена
рий не сильно отличается от команды snmpdf, за исключением некото
рых имен. Это отличный пример, когда было бы желательно перейти
на более высокий уровень абстракции и затем повторно использовать
общие компоненты. Если бы мы создали модуль, вмещающий весь об
щий программный код, наш новый сценарий состоял бы всего из не
скольких строк. Имейте это в виду, мы еще вернемся к этому.
Другой инструмент, имеющий отношение к SNMP, – это ARP, кото
рый использует протокол ARP. С помощью протокола ARP можно по
лучить MACадреса устройств по их IPадресам, при условии, что они
находятся в одной и той же сети. Давайте напишем и этот узкоспециа
лизированный инструмент. Он пригодится нам немного позже.
Оформить действия с протоколом ARP в виде сценария не составит ни
какого труда; можно сразу продемонстрировать работу этого примера,
используя интерактивную оболочку IPython. Итак, запустите IPython
и введите следующее:
```
```
import re
import subprocess
#некоторые переменные
ARP = "arp"
IP = "10.0.1.1"
CMD = "%s %s " % (ARP, IP)
macPattern = re.compile(":")
def getMac():
p = subprocess.Popen(CMD, shell=True, stdout=subprocess.PIPE)
out = p.stdout.read()
results = out.split()
for chunk in results:
if re.search(macPattern, chunk):
return chunk
if __name__ == "__main__":
macAddr = getMac()
print macAddr
```
```
Этот фрагмент нельзя назвать инструментом многократного использо
вания, но вы легко можете взять эту идею за основу и использовать ее
как часть общей библиотеки получения сведений об устройствах в сети
центра обработки данных.
```
### Расширение возможностей NetSNMP

```
Как уже говорилось ранее, в большинстве операционных систем *nix
пакет NetSNMP установлен в виде агента. По умолчанию агент может
возвращать определенный перечень информации, однако существует
```

**272** Глава 7. SNMP

```
возможность расширять этот перечень. Можно было бы указать агенту
на необходимость собирать некоторые сведения и затем возвращать их
по протоколу SNMP.
Файл EXAMPLE.conf , поставляемый в составе NetSNMP, – это один
из лучших источников информации по расширению возможностей
NetSNMP. Нелишним будет обратиться к команде man snmpd.conf, ко
торая выводит более подробную информацию с описанием API. Если
вас интересуют вопросы расширения возможностей «родных» агентов
пакета, оба эти источника справочной информации могут стать для
вас незаменимыми.
С точки зрения программистов на языке Python, возможность расши
рения NetSNMP является одним из самых захватывающих аспектов
работы с SNMP, потому что позволяет разработчикам писать про
граммный код, выполняющий мониторинг всего, что они сочтут необ
ходимым, и дополнительно иметь внутреннего агента, отвечающего
предъявляемым условиям.
Пакет NetSNMP предлагает достаточно много способов расширения
возможностей агента, и для начала мы напишем программу «Hello
World», которая будет выполняться по запросу snmp. Первый шаг за
ключается в создании простого файла snmpd.conf , посредством которо
го будет запускаться наша программа «Hello World», написанная на
языке Python. В примере 7.4 показано, как выглядит этот файл в опе
рационной системе Red Hat.
```
```
Пример 7.4. Конфигурационный файл SNMP, предусматривающий вызов
программы «Hello World»
syslocation "O'Reilly"
syscontact bofh@oreilly.com
rocommunity public
exec helloworld /usr/bin/pythonc "print 'hello world from Python'"
```
```
После этого следует сообщить демону snmpd о необходимости перечи
тать конфигурационный файл. Сделать это можно тремя разными спо
собами. В Red Hat можно использовать такую команду:
```
```
service snmpd reload
```
```
или сначала выполнить такую команду:
```
```
psef | grep snmpd
root 12345 1 0 Apr14?
00:00:30 /usr/sbin/snmpdLsd Lf /dev/null /var/run/snmpd.pid –a
```
```
а затем послать демону сигнал:
```
```
killHUP 12345
```
```
Наконец, можно с помощью команды snmpset присвоить целое число
(1) параметру UCD–SNMPMIB::versionUpdateConfig.0 и тем самым вынудить
демон snmpd перечитать конфигурационный файл.
```

Расширение возможностей Net;SNMP **273**

```
Теперь, когда демон snmpd перечитал измененный файл snmpd.conf , мы
можем двинуться дальше и послать нашей машине запрос с помощью
команды snmpwalk или с помощью расширения NetSNMP из оболочки
IPython. Ниже показано, что возвращает команда snmpwalk:
```
```
[root@giftcsllc02][H:4904][J:0]> snmpwalkv 1 c public localhost
.1.3.6.1.4.1.2021.8
UCDSNMPMIB::extIndex.1 = INTEGER: 1
UCDSNMPMIB::extNames.1 = STRING: helloworld
UCDSNMPMIB::extCommand.1 = STRING: /usr/bin/python
c "print 'hello world from Python'"
UCDSNMPMIB::extResult.1 = INTEGER: 0
UCDSNMPMIB::extOutput.1 = STRING: hello world from Python
UCDSNMPMIB::extErrFix.1 = INTEGER: noError(0)
UCDSNMPMIB::extErrFixCmd.1 = STRING:
```
```
Этот запрос требует некоторых пояснений, так как наблюдательный чи
татель может задаться вопросом, откуда взялся OID 1.3.6.1.4.1.2021.8.
Этот OID соответствует идентификатору ucdavis.extTable. Когда созда
ется расширение в snmpd.conf , оно присваивается этому OID. Дело не
сколько осложняется, когда возникает потребность создать свой OID.
Для этого необходимо обратиться в организацию iana.org и получить
уникальный номер для своего предприятия. После этого можно будет
использовать полученный номер для создания специализированных
запросов агенту. Основная причина таких сложностей состоит в необ
ходимости сохранить однородность пространства имен и избежать
конфликтов с числами, которые, возможно, получат поставщики обо
рудования в будущем.
Истинная сила Python заключается вовсе не в том, чтобы получить вы
вод от единственной команды – это было бы слишком просто. Ниже
приводится пример сценария, который определяет общее число обра
щений к вебсерверу Apache из броузера Firefox, анализируя файл жур
нала, и возвращает результат под нестандартным OID предприятия.
Начнем рассмотрение с конца и сначала посмотрим на полученные ре
зультаты:
snmpwalkv 2c c public localhost .1.3.6.1.4.1.2021.28664.100
UCDSNMPMIB::ucdavis.28664.100.1.1 = INTEGER: 1
UCDSNMPMIB::ucdavis.28664.100.2.1 = STRING: "FirefoxHits"
UCDSNMPMIB::ucdavis.28664.100.3.1 = STRING:
"/usr/bin/python /opt/local/snmp_scripts/agent_ext_logs.py"
UCDSNMPMIB::ucdavis.28664.100.100.1 = INTEGER: 0
UCDSNMPMIB::ucdavis.28664.100.101.1 = STRING:
"Total number of Firefox Browser Hits: 15702"
UCDSNMPMIB::ucdavis.28664.100.102.1 = INTEGER: 0
UCDSNMPMIB::ucdavis.28664.100.103.1 = ""
```
```
Если отыскать строку со значением 100.101.1, можно увидеть вывод,
полученный от сценария, который анализирует файл журнала вебсер
вера Apache и отыскивает записи, свидетельствующие об обращениях
```

**274** Глава 7. SNMP

```
с помощью броузера Firefox. Затем сценарий суммирует их и возвраща
ет по протоколу SNMP. В примере 7.5 приводится исходный текст сце
нария, который запускается при выполнении запроса к данному OID.
```
```
Пример 7.5. Сценарий поиска числа обращений к веб>серверу Apache
из броузера Firefox
import re
```
```
"""Возвращает число обращений из броузера Firefox"""
def grep(lines,pattern="Firefox"):
pat = re.compile(pattern)
for line in lines:
if pat.search(line): yield line
def increment(lines):
num = 0
for line in lines:
num += 1
return num
```
```
wwwlog = open("/home/noahgift/logs/noahgift.comcombinedlog")
column = (line.rsplit(None,1)[1] for line in wwwlog)
match = grep(column)
count = increment(match)
print "Total Number of Firefox Hits: %s" % count
```
```
Чтобы заставить этот запрос работать, мы сначала должны добавить
вфайл snmpd.conf информацию об этом сценарии, как показано ниже:
syslocation “O Reilly”
syscontact bofh@oreilly.com
rocommunity public
exec helloworld /usr/bin/pythonc "print 'hello world from Python'"
exec .1.3.6.1.4.1.2021.28664.100 FirefoxHits /usr/bin/python
/opt/local/snmp_scripts/agent_ext_logs.py
```
```
Самая магическая часть здесь – последняя строка с идентификатором
.1.3.6.1.4.1.2021, где 28664 является числом нашего предприятия,
а число 100 – просто некоторое число, которое мы решили использо
вать для примера. Это очень важно – следовать общепринятым прави
лам и использовать свое число предприятия, если вы планируете зани
маться расширением возможностей SNMP. Благодаря этому вы сумее
те избежать конфликтов при использовании в команде snmpset чисел,
уже занятых кемто другим.
Мы склонны считать, что тема использования SNMP является одной
из самых захватывающих тем в книге и что при этом SNMP попреж
нему остается малоизведанной областью. Можно привести массу при
меров, когда расширение возможностей NetSNMP может быть полез
ным, а при аккуратном использовании SNMPv3 вы сможете делать
удивительные вещи, реализовать которые с помощью протокола SNMP
```

Управление устройствами через SNMP **275**

```
совсем несложно и для которых применение ssh и сокетов могло бы по
казаться естественным выбором.
```
### Управление устройствами через SNMP.

```
Одним из самых интересных аспектов применения SNMP является
возможность управления устройствами по этому протоколу. Очевид
но, что такой способ управления маршрутизатором обладает сущест
венными преимуществами перед использованием, например, модуля
Pexpect ( http://sourceforge.net/projects/pexpect/ ), потому что реализу
ется намного проще.
Для краткости мы в примере будем рассматривать только использова
ние SNMPv1, но, если вам предстоит взаимодействовать с устройства
ми через незащищенную сеть, вам следует использовать SNMPv3. Пе
ред прочтением этого раздела было бы неплохо ознакомиться с книга
ми «Essential SNMP» и «Cisco IOS Cookbook» Кевина Дули (Kevin
Dooley) и Яна Дж. Брауна ( Ian. J. Brown) (O’Reilly), если они у вас име
ются или у вас имеется учетная запись для доступа к службе Safari.
Они содержат обширую информацию как об основах настройки, так
и о способах взаимодействия с устройствами Cisco по протоколу SNMP.
Поскольку перезагрузка параметров настройки в устройствах Cisco
красиво реализуется через протокол SNMP, мы выбрали эту тему для
разговора об управлении устройствами. Для опробования этого приме
ра вам потребуется работающий сервер TFTP, откуда маршрутизатор
будет забирать файл IOS, и маршрутизатор с разрешенным доступом
для чтения/записи по протоколу SNMP. В примере 7.6 приводится
сценарий на языке Python.
```
```
Пример 7.6. Выгрузка новой конфигурации в маршрутизатор Cisco
import netsnmp
vars = netsnmp.Varbind(netsnmp.VarList(netsnmp.Varbind(
".1.2.6.1.4.1.9.2.10.6.0", "1"),
(netsnmp.Varbind("cisco.example.com.1.3.6.1.4.1.9.2.10.12.172.25.1.1",
"isoconfig.bin")
result = netsnmp.snmpset(vars,
Version = 1,
DestHost='cisco.example.com',
Community='readWrite')
```
```
В этом примере мы использовали метод VarList из модуля netsnmp, что
бы сначала выполнить инструкцию, которая стирает информацию во
флешпамяти коммутатора, а затем загрузить новый образ файла IOS.
Этот программный код мог бы послужить основой сценария, выпол
няющего обновление настроек всех коммутаторов в вычислительном
центре. Как и любой другой программный код в этой книге, он должен
```

**276** Глава 7. SNMP

```
быть опробован на оборудовании, не включенном в работу, и вы не ока
жетесь перед фактом, что чтото натворили,.
И последнее замечание: протокол SNMP редко рассматривается как
способ управления устройствами и, тем не менее, он предоставляет
широкие возможности по управлению устройствами в вычислитель
ном центре, поскольку является универсальной спецификацией для
устройств, выпускавшихся начиная с 1988 года. В будущем возможно
очень интересное развитие протокола SNMP v3.
```
### Интеграция SNMP в сеть предприятия с помощью Zenoss

**с помощью Zenoss**

```
Zenoss представляет собой замечательную систему управления ло
кальными сетями уровня предприятия. Мало того, что Zenoss являет
ся приложением, распространяемым с открытыми исходными текста
ми, но оно еще целиком написано на языке Python. Система Zenoss яв
ляется представителем нового поколения приложений уровня пред
приятия, обладающих большими возможностями и допускающих
расширение с использованием интерфейса XMLRPC или ReST. За до
полнительной информацией о ReST обращайтесь к книге Леонарда
Ричардсона (Leonard Richardson) и Сэма Руби (Sam Ruby) «RESTful
Web Services» (O’Reilly).
Наконец, если у вас появится желание участвовать в разработке Ze
noss, вы можете предлагать свои исправления.
```
**Прикладной интерфейс Zenoss**

```
За последней информацией о прикладном интерфейсе Zenoss обра
щайтесь на сайт http://www.zenoss.com/community/docs/howtos/send>
events/.
```
```
Использование Zendmd
Система Zendoss не только поставляется в комплекте с системой мони
торинга и исследования SNMP, но и включает в себя прикладной ин
терфейс высокого уровня с именем zendmd. Вы можете открыть на
строенную командную оболочку Python и выполнять команды Zenoss
непосредственно.
Пример использования zendmd:
```
```
>>> d = find('build.zenoss.loc')
>>> d.os.interfaces.objectIds()
['eth0', 'eth1', 'lo', 'sit0', 'vmnet1', 'vmnet8']
>>> for d in dmd.Devices.getSubDevices():
>>> print d.id, d.getManageIp()
```

Интеграция SNMP в сеть предприятия с помощью Zenoss **277**

```
Прикладной интерфейс доступа к устройствам
С системой Zenoss можно также взаимодействовать через интерфейс
XMLRPC и добавлять или удалять устройства. Ниже приводятся два
примера:
С использованием ReST:
```
```
[zenos@zenoss $]
wget 'http://admin:zenoss@MYHOST:8080/zport/dmd
/ZenEventManager/manage_addEvent?device=MYDEVICE&component="
MYCOMPONENT&summary="
MYSUMMARY&severity=4&eclass=EVENTCLASS&eventClassKey=EVENTCLASSKEY
```
```
C использованием XMLRPC:
```
```
>>> from xmlrpclib import ServerProxy
>>> serv = ServerProxy(
'http://admin:zenoss@MYHOST:8080/zport/dmd/ZenEventManager')
>>> evt = {'device':'mydevice', 'component':'eth0',
'summary':'eth0 is down','severity':4, 'eventClass':'/Net'}
>>> serv.sendEvent(evt)
```
